<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/tx32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/tx16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Leetcode写在前面的一些话：把自己当做是一个什么都不懂的小孩，然后从零开始学起。每天保持一定的代码量，并且及时地去总结和复盘。这才是或者说这就是自己应该要做的事情。">
<meta property="og:type" content="article">
<meta property="og:title" content="数组入门">
<meta property="og:url" content="http://yoursite.com/2022/02/22/%E6%95%B0%E7%BB%84%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="Hello World">
<meta property="og:description" content="Leetcode写在前面的一些话：把自己当做是一个什么都不懂的小孩，然后从零开始学起。每天保持一定的代码量，并且及时地去总结和复盘。这才是或者说这就是自己应该要做的事情。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1640661811942.png">
<meta property="og:image" content="c:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1641459223451.png">
<meta property="og:image" content="c:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1640673548636.png">
<meta property="og:image" content="c:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1640674504454.png">
<meta property="og:image" content="c:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1640674519223.png">
<meta property="og:image" content="c:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1640760359920.png">
<meta property="og:image" content="c:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1641431986077.png">
<meta property="og:image" content="c:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1641433272682.png">
<meta property="og:image" content="c:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1641458310365.png">
<meta property="og:image" content="c:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1641457870892.png">
<meta property="og:image" content="c:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1641795661129.png">
<meta property="og:image" content="c:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1641795973059.png">
<meta property="og:image" content="c:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1641796040727.png">
<meta property="og:image" content="c:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1641796326094.png">
<meta property="article:published_time" content="2022-02-22T13:48:22.646Z">
<meta property="article:modified_time" content="2022-02-22T15:25:00.667Z">
<meta property="article:author" content="Dstin">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1640661811942.png">

<link rel="canonical" href="http://yoursite.com/2022/02/22/%E6%95%B0%E7%BB%84%E5%85%A5%E9%97%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>数组入门 | Hello World</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hello World</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/02/22/%E6%95%B0%E7%BB%84%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Dstin">
      <meta itemprop="description" content="这个人很懒 但是想留下点东西">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello World">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数组入门
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-22 21:48:22 / 修改时间：23:25:00" itemprop="dateCreated datePublished" datetime="2022-02-22T21:48:22+08:00">2022-02-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><h3 id="写在前面的一些话："><a href="#写在前面的一些话：" class="headerlink" title="写在前面的一些话："></a>写在前面的一些话：</h3><p>把自己当做是一个什么都不懂的小孩，然后从零开始学起。每天保持一定的代码量，并且及时地去总结和复盘。这才是或者说这就是自己应该要做的事情。</p>
<a id="more"></a>





<h3 id="基本刷题思路"><a href="#基本刷题思路" class="headerlink" title="基本刷题思路"></a>基本刷题思路</h3><p>刷题顺序： 推荐刷题顺序： 数组 -&gt;字符串 -&gt;链表-&gt;二分查找-&gt;排序-&gt;哈希表-&gt; 栈-&gt;队列 -&gt;树 、递归、回溯 -&gt; 堆 -&gt;动态规划。</p>
<p>一开始如果五分钟没有思路的话可以去看答案了。前期因为可能对做这种题目还不够擅长不够熟练，但是每隔一个礼拜要重新回过头来看看。</p>
<p>注意特殊情况，边界条件。这种细节如果不是自己重新写一遍代码的话是发现不了问题的。每道题的思考不要超过一个小时。</p>
<p> LeetCode刷题顺序<br>\1. 跟着教程的章节来刷题；剑指offer和程序员面试经典<br>\2. 按LeetCode分类中的频率从高到低刷，例如字符串、数组、二分查找、哈希表、链表、双指针、栈、树、深度优先搜索、广度优先搜索、回溯法、排序<br>\3. 拓展一道题的相似题目<br>\4. Top100或者精选200<br>\5. 参加LeetCode周赛或者双周赛，基本做出前三道，有时能做出第四道，以中等难度为主，简单难度热身，弄懂Top100或者精选200中困难难度<br>\6. 定期复习，面试前冲刺热题</p>
<p>往返重复，拿出对待高考的态度和方法：先做例题，再做课后题，最后再做各种模拟套题</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1640661811942.png" alt="1640661811942"></p>
<p><a href="https://bbs.csdn.net/skill/algorithm/algorithm-cbdd961fd6b9430c9d3750a9d9659cdb?category=202" target="_blank" rel="noopener">https://bbs.csdn.net/skill/algorithm/algorithm-cbdd961fd6b9430c9d3750a9d9659cdb?category=202</a></p>
<h3 id="1，两数之和（梦开始的地方）easy"><a href="#1，两数之和（梦开始的地方）easy" class="headerlink" title="1，两数之和（梦开始的地方）easy"></a>1，两数之和（梦开始的地方）easy</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<blockquote>
<p>初始思路：暴力解，然后开数组，以及哈希表。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无脑暴力解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)</span><br><span class="line">                <span class="keyword">return</span> &#123;i,j&#125;;  </span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>几个注意点：</p>
<ul>
<li>return之后要加分号以及 是大括号而不是小括号</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hashtable.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (it != hashtable.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>知识点：哈希表的时间复杂度为O（1），感觉很多题目的哈希映射都是用的大数组来表示。具体的还是有点看不懂，<strong>先占个坑之后来补。</strong></p>
<p>ps：本来是想用数组来做的，试一了一下，发现不行，感觉数组也算是哈希表的一种，但是因为数组设置的时候会出现负数，下标会有负数，不能成立。所以只能用哈希表。</p>
<p>nums={2 11 7 3}  taget=9。<br>9-11为-2 a[-2]不成立。</p>
</blockquote>
<h3 id="4，寻找两个正序数组的中位数-hard"><a href="#4，寻找两个正序数组的中位数-hard" class="headerlink" title="4，寻找两个正序数组的中位数 hard"></a>4，寻找两个正序数组的中位数 hard</h3><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p>
<p>算法的时间复杂度应该为 O(log (m+n)) 。</p>
<blockquote>
<p>思路其实比较简单，因为这里提到了是O（log（m+n））已经知道的和log相关的算法只有归并，快排，二分其他的什么堆排序 桶排序之类的我就都不会了。。。 思路简单 实现起来其实还挺难的</p>
<p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1641459223451.png" alt="1641459223451"></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//别人的就看看吧</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = nums1.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">int</span> m = nums2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (n &gt; m)  <span class="comment">//保证数组1一定最短 //为了加快速度 对长度短的进行二分</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> LMax1 = <span class="number">0</span>, LMax2 = <span class="number">0</span>, RMin1 = <span class="number">0</span>, RMin2 = <span class="number">0</span>, c1, c2, lo = <span class="number">0</span>, hi = n;</span><br><span class="line">		<span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">			c1 = (hi + lo + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">			c2 = (m + n) / <span class="number">2</span> - c1;</span><br><span class="line"></span><br><span class="line">			LMax1 = (c1 == <span class="number">0</span>) ? INT_MIN : nums1[c1 - <span class="number">1</span>];</span><br><span class="line">			RMin1 = (c1 == n) ? INT_MAX : nums1[c1];</span><br><span class="line">			LMax2 = (c2 == <span class="number">0</span>) ? INT_MIN : nums2[c2 - <span class="number">1</span>];</span><br><span class="line">			RMin2 = (c2 == m) ? INT_MAX : nums2[c2];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (LMax1 &gt; RMin2)</span><br><span class="line">				hi = c1 - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (LMax2 &gt; RMin1)</span><br><span class="line">				lo = c1 + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((m + n) % <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">min</span>(RMin1, RMin2);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> ((<span class="keyword">int64_t</span>)<span class="built_in">max</span>(LMax1, LMax2) + (<span class="keyword">int64_t</span>)<span class="built_in">min</span>(RMin1, RMin2)) / <span class="number">2.0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="11，盛最多水的容器-mid"><a href="#11，盛最多水的容器-mid" class="headerlink" title="11，盛最多水的容器 mid"></a>11，盛最多水的容器 mid</h3><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器。</p>
<p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1640673548636.png" alt="
"></p>
<blockquote>
<p>第一眼真的就暴力解，发现很多数组类的题目都可以暴力解，就是时间复杂度太高了。。。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无脑暴力解 是我不配了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> area=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">height</span>.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=<span class="built_in">height</span>.<span class="built_in">size</span>()<span class="number">-1</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> now=(j-i)*<span class="built_in">min</span>(<span class="built_in">height</span>[i],<span class="built_in">height</span>[j]);</span><br><span class="line">                area=<span class="built_in">max</span>(area,now);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>&#123;m&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> area=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="built_in">height</span>.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">int</span> now=(j-i)*<span class="built_in">min</span>(<span class="built_in">height</span>[i],<span class="built_in">height</span>[j]);</span><br><span class="line">            <span class="comment">//每次移动一小格，底都会-1，要满足题意，那高必须增加，要使得高增加那么就需要让更矮的一方向对方移动。</span></span><br><span class="line">            area=<span class="built_in">max</span>(now,area);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">height</span>[i]&lt;<span class="built_in">height</span>[j]) <span class="comment">//右边的更高一点,让左边的移动 </span></span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>&#123;area&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>正常解法：动态规划，双指针题目。从两边向中间靠拢. 背后的<strong>缩减搜索空间</strong>的思想去考虑题解。感觉有点点类似于快排，都是通过两者比较，一个移动一个不移动。</p>
<p>思想：从外到内，要使得area最大，又因为每次移动一小格，底都会-1，要满足题意，那高必须增加，要使得高增加那么就需要让更矮的一方向对方移动。</p>
<p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1640674504454.png" alt="1640674504454"><br><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1640674519223.png" alt="1640674519223"><br>为什么只需要移动最小的一边呢。因为如果移动大的一边的话，里面水的面积的最大值会小于初始值。<br>$$<br>min(x,y)<em>t_初始&gt;min(x,y_现在)</em>t_{现在}<br>$$<br> 因为t初始一定是要大于t现在的，所以x不能作为边界条件，需要继续向右移动。所以x不是边界条件</p>
</blockquote>
<h3 id="15，三数之和-mid"><a href="#15，三数之和-mid" class="headerlink" title="15，三数之和 mid"></a>15，三数之和 mid</h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<blockquote>
<p>思路：第一感觉是用暴力。有点类似于408的某年真题，直接排序然后三重for循环暴力求解。</p>
<p>第二的感觉：三个指针，或者固定一个用双指针,但具体怎么做也还是不知道</p>
<p>第三种感觉：哈希表，具体怎么实现不知道..</p>
</blockquote>
<blockquote>
<p>题目中要求找到所有「不重复」且和为 00 的三元组，<strong>这个「不重复」的要求使得我们无法简单地使用三重循环枚举所有的三元组</strong>。这是因为在最坏的情况下，数组中的元素全部为 00，即</p>
<p> [0, 0, 0, 0, 0, …, 0, 0, 0]</p>
<p><strong>最终的思路：</strong></p>
<p>排序+双指针 。先通过sort函数排序先确定nums[i]为第⼀一个元素，为了了避免重复，如果nums[i]和刚刚的nums[i-1]相同就跳过continue，然后begin指向i+1，end指向n-1，判断此时的sum是否等于0，如果等于0就将结果放⼊入result数组中，且begin++，end – -，为了了避免重复，如果begin++后的元素依旧和刚才的元素相同，继续begin++，end同理理～如果sum&gt;0就将end – -，如果sum&lt;0就将begin++，<br>最后返回result结果集</p>
</blockquote>
<p>注意sort的使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力破解法</span></span><br><span class="line">         解法<span class="number">1</span>，通过<span class="number">315</span>个案例，逻辑比较清晰，能够对<span class="built_in">vector</span>的sort count 以及尝试过的unique（在使用unique之前需要进行排序） 都有比较好的理解</span><br><span class="line">         <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">         <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">3</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> result;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>()<span class="number">-2</span>; i++)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>; j++)&#123;</span><br><span class="line">                 <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>; k&lt;nums.<span class="built_in">size</span>(); k++)&#123;</span><br><span class="line">                     <span class="keyword">if</span>(nums[i] + nums[j] + nums[k] == <span class="number">0</span>)&#123;</span><br><span class="line">                         <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">                         temp.push_back(nums[i]);</span><br><span class="line">                         temp.push_back(nums[j]);</span><br><span class="line">                         temp.push_back(nums[k]);</span><br><span class="line">                         sort(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">                         <span class="keyword">if</span>(count(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>(),temp) == <span class="number">0</span>)&#123;</span><br><span class="line">                             result.push_back(temp);</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个暴力破解没有写好，并不是说自己不会，而是c++的这种容器的形式还是不那么熟练，vector用的不够熟练，需要进行一些补充，之后把sort再看看。</p>
</blockquote>
<h5 id="最佳解法："><a href="#最佳解法：" class="headerlink" title="最佳解法："></a>最佳解法：</h5><p>排序+双指针：暂时没怎么看得懂 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span> &lt; <span class="number">3</span>)   <span class="keyword">return</span> &#123;&#125;;          <span class="comment">// 特判</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;res;            <span class="comment">// 保存结果（所有不重复的三元组）</span></span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">// 排序（默认递增）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)      <span class="comment">// 固定第一个数，转化为求两数之和</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)    <span class="keyword">return</span> res; <span class="comment">// 第一个数大于 0，后面都是递增正数，不可能相加为零了</span></span><br><span class="line">            <span class="comment">// 去重：如果此数已经选取过，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])  <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 双指针在nums[i]后面的区间中寻找和为0-nums[i]的另外两个数</span></span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = <span class="built_in">size</span> - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] + nums[right] &gt; -nums[i])</span><br><span class="line">                    right--;    <span class="comment">// 两数之和太大，右指针左移</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; -nums[i])</span><br><span class="line">                    left++;     <span class="comment">// 两数之和太小，左指针右移</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 找到一个和为零的三元组，添加到结果中，左右指针内缩，继续寻找</span></span><br><span class="line">                    res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="comment">// 去重：第二个数和第三个数也不重复选取</span></span><br><span class="line">                    <span class="comment">// 例如：[-4,1,1,1,2,3,3,3], i=0, left=1, right=5</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left<span class="number">-1</span>])  left++;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right+<span class="number">1</span>])    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自己的版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">3</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;<span class="comment">//定义一个容器vector</span></span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()); <span class="comment">//排序，加了cmp是递减，不加是递增</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">return</span> res;<span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">             <span class="comment">//因为是已经排好序了，所以如果相邻两个相同，说明就不需要选择了。</span></span><br><span class="line">            <span class="keyword">int</span> left=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((nums[left]+nums[right])&gt;-nums[i])</span><br><span class="line">                right--; <span class="comment">//两者相加大于-nums，说明需要变小，则right向左移动</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[left]+nums[right]&lt;-nums[i])</span><br><span class="line">                left++;  <span class="comment">//两者相加小于-nums，说明需要变大 则left向移动</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[left]+nums[right]==-nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                     res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left<span class="number">-1</span>])  left++;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right+<span class="number">1</span>])    right--;<span class="comment">//左边和右边去除重复项</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思考补充：既然三数之和可以使用双指针法，我们之前讲过的1.两数之和，可不可以使用双指针法呢？</p>
<p>如果不能，题意如何更改就可以使用双指针法呢？ 大家留言说出自己的想法吧！</p>
<p>两数之和 就不能使用双指针法，因为1.两数之和要求返回的是索引下标， 而双指针法一定要排序，一旦排序之后原数组的索引就被改变了。</p>
<p>如果1.两数之和要求返回的是数值的话，就可以使用双指针法了。</p>
</blockquote>
<h3 id="75，颜色分类-mid"><a href="#75，颜色分类-mid" class="headerlink" title="75，颜色分类 mid"></a>75，颜色分类 mid</h3><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<blockquote>
<p>初步思考：</p>
<p>1，暴力解快排 O（nlogn）</p>
<p>2，哈希表映射</p>
<p>3，数组 这道题目就可以用数组来表示，因为里面只有0,1,2没有负数。</p>
<p>4,双指针或者单指针</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用数组去求解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> color[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">               <span class="keyword">int</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">        color[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: color[<span class="number">0</span>]++;<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: color[<span class="number">1</span>]++;<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: color[<span class="number">2</span>]++;<span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//建立一个辅助数组来记录012的数目。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(color[i]&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[j++]=i;</span><br><span class="line">                color[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//重新赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单指针法求解，进行两趟遍历。第一步是是让0全部都排到前面去，每次都是交换0和头部，然后头部往后面移动一位。 之后再遍历一遍，让1移动</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ptr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums[i], nums[ptr]);</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ptr; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                swap(nums[i], nums[ptr]);</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> p0 = <span class="number">0</span>, p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                swap(nums[i], nums[p1]);</span><br><span class="line">                ++p1;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums[i], nums[p0]);</span><br><span class="line">                <span class="keyword">if</span> (p0 &lt; p1) &#123;</span><br><span class="line">                    swap(nums[i], nums[p1]);</span><br><span class="line">                &#125;</span><br><span class="line">                ++p0;</span><br><span class="line">                ++p1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>双指针法可以好好学学，感觉双指针用的还是比较多的</strong>，一次遍历即可排好序。</p>
<p> 方法一需要进行两次遍历，那么我们是否可以仅使用一次遍历呢？我们可以额外使用一个指针，即使用两个指针分别用来交换 0 和 1。 </p>
<p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1640760359920.png" alt="1640760359920"></p>
</blockquote>
<h3 id="76，最小覆盖子串-hard"><a href="#76，最小覆盖子串-hard" class="headerlink" title="76，最小覆盖子串 hard"></a>76，最小覆盖子串 hard</h3><ul>
<li><p>第一种思路，枚举出所有大于t长度的子串，然后再一个比对。</p>
</li>
<li><p>第二种思路：双指针（这道题目的思路和盛水最多的容器思路其实是一样的，先记录s和t每个字母的频数，然后让s不断地缩小</p>
</li>
</ul>
<p>第四种思想：hash map</p>
<blockquote>
<p>这里T是可能包含重复字符的，如果可能误解题目的意思，需要和面试官说清楚。可能到时候算法不一样。</p>
</blockquote>
<h5 id="新思想：滑动窗口"><a href="#新思想：滑动窗口" class="headerlink" title="新思想：滑动窗口"></a>新思想：滑动窗口</h5><p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1641431986077.png" alt="1641431986077"></p>
<blockquote>
<p>右边界右移</p>
<p>winFreq[s[right]]&lt;tFreq[s[right]]严格小于时，distance+1，当distance=t的长度时才说明包含所有字符。</p>
<p>左边界右移，如果出现winFreq[s[right]]&lt;tFreq[s[right]]时，说明不是包含的最小覆盖子串，此时不能移动，所以需要同时移动</p>
<p>时间复杂度O（1）</p>
<p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1641433272682.png" alt="1641433272682"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s == <span class="string">""</span> || t == <span class="keyword">null</span> || t == <span class="string">""</span> || s.length() &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//维护两个数组，记录已有字符串指定字符的出现次数，和目标字符串指定字符的出现次数</span></span><br><span class="line">        <span class="comment">//ASCII表总长128</span></span><br><span class="line">        <span class="keyword">int</span>[] need = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span>[] have = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将目标字符串指定字符的出现次数记录</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            need[t.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分别为左指针，右指针，最小长度(初始值为一定不可达到的长度)</span></span><br><span class="line">        <span class="comment">//已有字符串中目标字符串指定字符的出现总频次以及最小覆盖子串在原字符串中的起始位置</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, min = s.length() + <span class="number">1</span>, count = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> r = s.charAt(right);</span><br><span class="line">            <span class="comment">//说明该字符不被目标字符串需要，此时有两种情况</span></span><br><span class="line">            <span class="comment">// 1.循环刚开始，那么直接移动右指针即可，不需要做多余判断</span></span><br><span class="line">            <span class="comment">// 2.循环已经开始一段时间，此处又有两种情况</span></span><br><span class="line">            <span class="comment">//  2.1 上一次条件不满足，已有字符串指定字符出现次数不满足目标字符串指定字符出现次数，那么此时</span></span><br><span class="line">            <span class="comment">//      如果该字符还不被目标字符串需要，就不需要进行多余判断，右指针移动即可</span></span><br><span class="line">            <span class="comment">//  2.2 左指针已经移动完毕，那么此时就相当于循环刚开始，同理直接移动右指针</span></span><br><span class="line">            <span class="keyword">if</span> (need[r] == <span class="number">0</span>) &#123;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当且仅当已有字符串目标字符出现的次数小于目标字符串字符的出现次数时，count才会+1</span></span><br><span class="line">            <span class="comment">//是为了后续能直接判断已有字符串是否已经包含了目标字符串的所有字符，不需要挨个比对字符出现的次数</span></span><br><span class="line">            <span class="keyword">if</span> (have[r] &lt; need[r]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//已有字符串中目标字符出现的次数+1</span></span><br><span class="line">            have[r]++;</span><br><span class="line">            <span class="comment">//移动右指针</span></span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">//当且仅当已有字符串已经包含了所有目标字符串的字符，且出现频次一定大于或等于指定频次</span></span><br><span class="line">            <span class="keyword">while</span> (count == t.length()) &#123;</span><br><span class="line">                <span class="comment">//挡窗口的长度比已有的最短值小时，更改最小值，并记录起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; min) &#123;</span><br><span class="line">                    min = right - left;</span><br><span class="line">                    start = left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> l = s.charAt(left);</span><br><span class="line">                <span class="comment">//如果左边即将要去掉的字符不被目标字符串需要，那么不需要多余判断，直接可以移动左指针</span></span><br><span class="line">                <span class="keyword">if</span> (need[l] == <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果左边即将要去掉的字符被目标字符串需要，且出现的频次正好等于指定频次，那么如果去掉了这个字符，</span></span><br><span class="line">                <span class="comment">//就不满足覆盖子串的条件，此时要破坏循环条件跳出循环，即控制目标字符串指定字符的出现总频次(count）-1</span></span><br><span class="line">                <span class="keyword">if</span> (have[l] == need[l]) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//已有字符串中目标字符出现的次数-1</span></span><br><span class="line">                have[l]--;</span><br><span class="line">                <span class="comment">//移动左指针</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最小长度还为初始值，说明没有符合条件的子串</span></span><br><span class="line">        <span class="keyword">if</span> (min == s.length() + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回的为以记录的起始位置为起点，记录的最短长度为距离的指定字符串中截取的子串</span></span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>决策单调性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;hs,ht;<span class="comment">//定义两个hash表，一个是hs一个是ht</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> count:t) ht[count]++;<span class="comment">//对应的hash表里的字幕频数++</span></span><br><span class="line">        <span class="built_in">string</span> res;  <span class="comment">//定义最小字符串</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>; <span class="comment">//相当于distance，保证</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;right&lt;s.<span class="built_in">size</span>();right++)&#123;</span><br><span class="line">            hs[s[right]]++; <span class="comment">//这个是对应的hash表的数字加加！！！！</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(hs[s[right]]&lt;=ht[s[right]])</span><br><span class="line">             count++;<span class="comment">//注意这里是先++然后再进行比较，所以可以有&lt;=</span></span><br><span class="line">            </span><br><span class="line">                <span class="comment">//判断左边，让左边往右边移动</span></span><br><span class="line">            <span class="keyword">while</span>(hs[s[left]]&gt;ht[s[left]])</span><br><span class="line">                     &#123;</span><br><span class="line">                         hs[s[left]]--;</span><br><span class="line">                         left++;  <span class="comment">//左边向右移动一位</span></span><br><span class="line">                     &#125;</span><br><span class="line">            <span class="keyword">if</span>(count==t.<span class="built_in">size</span>())<span class="comment">//说明count此时已经包含了所有t里面的字母</span></span><br><span class="line">                     &#123;</span><br><span class="line">                         <span class="keyword">if</span>(res.empty()||right-left+<span class="number">1</span>&lt;res.<span class="built_in">size</span>())</span><br><span class="line">                             <span class="comment">//res.empty()表示的最开始的时候，需要直接运行一下。</span></span><br><span class="line">                             <span class="comment">//right-left+1表示的是此时的覆盖子串。res.size()表示的是之前的覆盖子串。当此时的覆盖子串小于现在的覆盖子串长度时，用现在的覆盖子串来代替，因为它更小</span></span><br><span class="line">                             res=s.substr(left,right-left+<span class="number">1</span>);</span><br><span class="line">                             </span><br><span class="line">                     &#125;</span><br><span class="line">                     </span><br><span class="line">        &#125;<span class="comment">//只需要遍历一遍即可，因为指针都是严格单调递增的</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//作者：lin-shen-shi-jian-lu-k</span></span><br><span class="line"><span class="comment">//链接：https://leetcode-cn.com/problems/minimum-window-substring/solution/leetcode-76-zui-xiao-fu-gai-zi-chuan-cja-lmqz/</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>补充： 意思是将t容器中的每一个元素从前往后枚举出来，并用 count 来表示，类似于Java中的 for each 语句 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123; <span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> count:nums)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count &lt;&lt;<span class="string">" "</span>; <span class="comment">//注意这里是count不是nums</span></span><br><span class="line">    system(<span class="string">"pause"</span>);<span class="comment">//输出为 0 2 1 1 0 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hs, ht;</span><br><span class="line">        <span class="keyword">for</span> (auto count: t) ht[count] ++ ;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>, left = <span class="number">0</span>; right &lt; s.size(); right ++ ) &#123;</span><br><span class="line">            hs[s[right]] ++ ; </span><br><span class="line">            <span class="keyword">if</span> (hs[s[right]] &lt;= ht[s[right]]) </span><br><span class="line">            count ++ ;      </span><br><span class="line">        <span class="keyword">while</span> (hs[s[left]] &gt; ht[s[left]]) </span><br><span class="line">        &#123;</span><br><span class="line">            hs[s[left]]--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (count == t.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.empty() || right - left + <span class="number">1</span> &lt; res.size())</span><br><span class="line">                res = s.substr(left, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>empty函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123; <span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span>(nums.empty()) <span class="comment">//判断是不是空，如果是空的话就运行，不是空的话就不运行</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ture"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt;<span class="string">"false"</span>;  <span class="comment">//这个不是空，所以运行false</span></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="142，环形链表-2-mid"><a href="#142，环形链表-2-mid" class="headerlink" title="142，环形链表 2 mid"></a>142，环形链表 2 mid</h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许修改 链表。</p>
<p>第一眼思路，没有思路…图都看不懂</p>
<p>head=[1,6,4,7,2,5]</p>
<p>pos=1，说明该链表的链尾是返回head[]的一号元素，即head[1]。</p>
<p>如果是pos=0,说明返回0号元素，即head[0]。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。 看样子之后要系统地学习一下hash表了，用的太多太多了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;ListNode *&gt; visited;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.count(head)) &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.insert(head);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>快指针和慢指针：终于用到了一个我自己比较熟悉的了，方式也很简单,不过主要就考察数学公式了。其实这种题目自己模拟一下就能够发现了。</p>
<p>快慢指针相类似的题目还有：<strong>408出现过的</strong></p>
<p>求中位数；求倒数第n个数等等；</p>
<p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1641458310365.png" alt="1641458310365"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="comment">//这里注意一下while的条件是fast和fast-&gt;next！=null</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                ListNode* index1 = fast;</span><br><span class="line">                ListNode* index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index2; <span class="comment">// 返回环的入口</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里提供一个更方便的题解</p>
<p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1641457870892.png" alt="1641457870892"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast=head,*low=head;<span class="comment">//定义两个指针类型 *表示是一个指针变量</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;low!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            low=low-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==low)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fast==<span class="literal">NULL</span>||fast-&gt;next==<span class="literal">NULL</span>) <span class="comment">//无环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        ListNode *record=fast; </span><br><span class="line">        low=low-&gt;next;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">1</span>;<span class="comment">//用来记录这个环有多少个节点 这里应该要从1开始 之前已经走过一个点了。经过了一个next</span></span><br><span class="line">        <span class="keyword">while</span>(low!=fast) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            low=low-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *fast2=head,*low2=head;  <span class="comment">//再次从头开始读取</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            fast2=fast2-&gt;next;</span><br><span class="line">        <span class="comment">//这里注意其实不是求的倒数第n个节点而是n+1个，画一下图就出来了</span></span><br><span class="line">        <span class="keyword">while</span>(fast2!=low2)&#123;</span><br><span class="line">            fast2=fast2-&gt;next;</span><br><span class="line">            low2=low2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="31，下一个队列"><a href="#31，下一个队列" class="headerlink" title="31，下一个队列"></a>31，下一个队列</h3><p>实现获取 <strong>下一个排列</strong> 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须<strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener"> 原地 </a></strong>修改，只允许使用额外常数空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;<span class="comment">//从右往左 找到第一个左小于右的数nums[i]</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">        &#125;<span class="comment">//从右往左 找到第一个大于nums[i]的数 nums[j] 并进行交换</span></span><br><span class="line">        sort(nums.<span class="built_in">begin</span>() + i + <span class="number">1</span>, nums.<span class="built_in">end</span>());</span><br><span class="line">		<span class="comment">//reverse(nums.begin() + i + 1, nums.end()); 这里无论是用reverse还是sort都是对的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>考察的其实就是字典序，<a href="https://blog.csdn.net/qq_37050329/article/details/86637183" target="_blank" rel="noopener">https://blog.csdn.net/qq_37050329/article/details/86637183</a><br><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1641795661129.png" alt="1641795661129"></p>
</blockquote>
<h3 id="38-剑指offer-字符串的排列"><a href="#38-剑指offer-字符串的排列" class="headerlink" title="38,剑指offer 字符串的排列"></a>38,剑指offer 字符串的排列</h3><p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1641795973059.png" alt="1641795973059"></p>
<p>这里比较难的一点在于两个，一个是全排列，直接输出，另外一个是去重，去重可以使用hash map来进行去重</p>
<blockquote>
<p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1641796040727.png" alt="1641796040727"></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码真漂亮，虽然回溯和递归我现在用的都不够熟练，之后再好好学吧</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">//为了让递归函数添加结果方便，定义到函数之外，这样无需带到递归函数的参数列表中</span></span><br><span class="line">    List&lt;<span class="keyword">String</span>&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//同；但是其赋值依赖c，定义声明分开</span></span><br><span class="line">    <span class="keyword">char</span>[] c;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span>[] permutation(<span class="keyword">String</span> s) &#123;</span><br><span class="line">        c = s.toCharArray();</span><br><span class="line">        <span class="comment">//从第一层开始递归</span></span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//将字符串数组ArrayList转化为String类型数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>.toArray(<span class="keyword">new</span> <span class="keyword">String</span>[<span class="built_in">list</span>.<span class="built_in">size</span>()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当递归函数到达第三层，就返回，因为此时第二第三个位置已经发生了交换</span></span><br><span class="line">        <span class="keyword">if</span> (x == c.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//将字符数组转换为字符串</span></span><br><span class="line">            <span class="built_in">list</span>.add(<span class="keyword">String</span>.valueOf(c));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为了防止同一层递归出现重复元素</span></span><br><span class="line">        HashSet&lt;Character&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//这里就很巧妙了,第一层可以是a,b,c那么就有三种情况，这里i = x,正巧dfs(0)，正好i = 0开始</span></span><br><span class="line">        <span class="comment">// 当第二层只有两种情况，dfs(1）i = 1开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; c.length; i++)&#123;</span><br><span class="line">            <span class="comment">//发生剪枝，当包含这个元素的时候，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">set</span>.contains(c[i]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">set</span>.add(c[i]);</span><br><span class="line">            <span class="comment">//交换元素，这里很是巧妙，当在第二层dfs(1),x = 1,那么i = 1或者 2， 不是交换1和1，要就是交换1和2</span></span><br><span class="line">            swap(i,x);</span><br><span class="line">            <span class="comment">//进入下一层递归</span></span><br><span class="line">            dfs(x + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//返回时交换回来，这样保证到达第1层的时候，一直都是abc。这里捋顺一下，开始一直都是abc，那么第一位置总共就3个交换</span></span><br><span class="line">            <span class="comment">//分别是a与a交换，这个就相当于 x = 0, i = 0;</span></span><br><span class="line">            <span class="comment">//     a与b交换            x = 0, i = 1;</span></span><br><span class="line">            <span class="comment">//     a与c交换            x = 0, i = 2;</span></span><br><span class="line">            <span class="comment">//就相当于上图中开始的三条路径</span></span><br><span class="line">            <span class="comment">//第一个元素固定后，每个引出两条路径,</span></span><br><span class="line">            <span class="comment">//     b与b交换            x = 1, i = 1;</span></span><br><span class="line">            <span class="comment">//     b与c交换            x = 1, i = 2;</span></span><br><span class="line">            <span class="comment">//所以，结合上图，在每条路径上标注上i的值，就会非常容易好理解了</span></span><br><span class="line">            swap(i,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = c[i];</span><br><span class="line">        c[i] = c[x];</span><br><span class="line">        c[x] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全排列+哈希表去重( 解题思路参考 46.全排列 )</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        dfs(s,<span class="number">0</span>,n);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            hash[res[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=hash.<span class="built_in">begin</span>();it!=hash.<span class="built_in">end</span>();it++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.emplace_back(it-&gt;first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span>&amp; s,<span class="keyword">int</span> first,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first==n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.emplace_back(s);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=first;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(s[i],s[first]);</span><br><span class="line">            dfs(s,first+<span class="number">1</span>,n);</span><br><span class="line">            swap(s[i],s[first]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>













<h3 id="283，移动0"><a href="#283，移动0" class="headerlink" title="283，移动0"></a>283，移动0</h3><p> 给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序 </p>
<p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1641796326094.png" alt="1641796326094"></p>
<p>这里提到了不能拷贝其他的数组，感觉空间复杂度只能为O(1),那么就不好用hash map之类的,感觉有点点像是双指针，但不好怎么去使用，</p>
<p>使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。</p>
<p>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</p>
<p>注意到以下性质：</p>
<p>左指针左边均为非零数；</p>
<p>右指针左边直到左指针处均为零。</p>
<p>因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左右指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(), left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right]) &#123;</span><br><span class="line">                swap(nums[left], nums[right]); <span class="comment">//这一部分画个图就知道了 0 1 0 3 12 5 6 相当于不断地让0往后面移动</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法二，这个其实就是有点类似于整个辅助数组或者说快慢指针之类的，r永远走的比l快，那么非0的数字都赋给nums[l]，l++，最后再让l之后的都变为0 一次遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r=<span class="number">0</span>,l=<span class="number">0</span>,<span class="built_in">size</span>=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (r&lt;<span class="built_in">size</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[r])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[l++]=nums[r];            &#125;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;<span class="built_in">size</span>;i++) <span class="comment">//注意这里的i=l不是i=l+1，原因是已经加过1了 在nums[l++]里面</span></span><br><span class="line">        nums[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>








    </div>

    
    
    

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2022/02/22/C++%E5%9F%BA%E7%A1%80/" rel="next" title="Hello World">
                  <i class="fa fa-chevron-left"></i> Hello World
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2022/02/22/balbalal/" rel="prev" title="balbalal">
                  balbalal <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode"><span class="nav-number">1.</span> <span class="nav-text">Leetcode</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#写在前面的一些话："><span class="nav-number">1.0.1.</span> <span class="nav-text">写在前面的一些话：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本刷题思路"><span class="nav-number">1.0.2.</span> <span class="nav-text">基本刷题思路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">1.1.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">题目</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1，两数之和（梦开始的地方）easy"><span class="nav-number">1.1.1.</span> <span class="nav-text">1，两数之和（梦开始的地方）easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4，寻找两个正序数组的中位数-hard"><span class="nav-number">1.1.2.</span> <span class="nav-text">4，寻找两个正序数组的中位数 hard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11，盛最多水的容器-mid"><span class="nav-number">1.1.3.</span> <span class="nav-text">11，盛最多水的容器 mid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15，三数之和-mid"><span class="nav-number">1.1.4.</span> <span class="nav-text">15，三数之和 mid</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#最佳解法："><span class="nav-number">1.1.4.0.1.</span> <span class="nav-text">最佳解法：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#75，颜色分类-mid"><span class="nav-number">1.1.5.</span> <span class="nav-text">75，颜色分类 mid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#76，最小覆盖子串-hard"><span class="nav-number">1.1.6.</span> <span class="nav-text">76，最小覆盖子串 hard</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#新思想：滑动窗口"><span class="nav-number">1.1.6.0.1.</span> <span class="nav-text">新思想：滑动窗口</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#142，环形链表-2-mid"><span class="nav-number">1.1.7.</span> <span class="nav-text">142，环形链表 2 mid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31，下一个队列"><span class="nav-number">1.1.8.</span> <span class="nav-text">31，下一个队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#38-剑指offer-字符串的排列"><span class="nav-number">1.1.9.</span> <span class="nav-text">38,剑指offer 字符串的排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#283，移动0"><span class="nav-number">1.1.10.</span> <span class="nav-text">283，移动0</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Dstin"
    src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Dstin</p>
  <div class="site-description" itemprop="description">这个人很懒 但是想留下点东西</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Value-Jack" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;Value-Jack" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dstin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
















  

  

</body>
</html>
