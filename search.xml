<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>链表队列栈</title>
      <link href="/2022/02/27/lian-biao-dui-lie-zhan/"/>
      <url>/2022/02/27/lian-biao-dui-lie-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="链表队列栈"><a href="#链表队列栈" class="headerlink" title="链表队列栈"></a>链表队列栈</h1><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><img src="%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97%E6%A0%88.assets/202202251509813.png" alt="1642473585612"></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="234-，回文链表"><a href="#234-，回文链表" class="headerlink" title="234 ，回文链表"></a>234 ，回文链表</h3><p>给你一个单链表的头结点head，请判断是不是回文链表，是返回true</p><blockquote><p>怎么判断回文数，得到那个数，然后从最后与最前面的开始比较，一直比到中间的数。</p><p>链表也差不多，先用快慢指针找到<strong>中间链表</strong>，记录中间节点，然后把之后的<strong>逆置</strong>，再从头到尾<strong>比较</strong>，是不是一样的。</p><p>这道题目挺综合的出的不错</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//看到了一个和我思路一模一样的</span><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode() {} *     ListNode(int val) { this.val = val; } *     ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 找中点 1=>1 123=>2 1234=>2</span>        ListNode A_end <span class="token operator">=</span> <span class="token function">mid</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode B_start <span class="token operator">=</span> A_end<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        A_end<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 翻转后半部分</span>        B_start <span class="token operator">=</span> <span class="token function">reverse</span><span class="token punctuation">(</span>B_start<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 比对</span>        <span class="token keyword">boolean</span> res <span class="token operator">=</span> <span class="token function">compare</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> B_start<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 还原 也可以就不还原了</span>        A_end<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">reverse</span><span class="token punctuation">(</span>B_start<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 链表找中点，快慢指针法</span>    ListNode <span class="token function">mid</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode p <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode q <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> q<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>             p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>             q <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 链表反转模板</span>    ListNode <span class="token function">reverse</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 三人行模板</span>        ListNode pre <span class="token operator">=</span> null<span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ListNode temp <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 松手先保存</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>            pre <span class="token operator">=</span> cur<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 归位</span>            cur <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> pre<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 链表比对模板(len(B) &lt;= len(A))</span>    <span class="token keyword">boolean</span> <span class="token function">compare</span><span class="token punctuation">(</span>ListNode A<span class="token punctuation">,</span> ListNode B<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>B <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>val <span class="token operator">!=</span> B<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            A <span class="token operator">=</span> A<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            B <span class="token operator">=</span> B<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) {} *     ListNode(int x) : val(x), next(nullptr) {} *     ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//说明只有一个数</span>        ListNode <span class="token operator">*</span>half<span class="token operator">=</span><span class="token function">halfList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode <span class="token operator">*</span>end<span class="token operator">=</span><span class="token function">reverse</span><span class="token punctuation">(</span>half<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//翻转</span>        ListNode <span class="token operator">*</span>p1<span class="token operator">=</span>head<span class="token punctuation">;</span>        ListNode <span class="token operator">*</span>p2<span class="token operator">=</span>end<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//p2表示翻转后的尾结点 </span>        <span class="token comment" spellcheck="true">//判断</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p2<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p1<span class="token operator">-</span><span class="token operator">></span>val<span class="token operator">!=</span>p2<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            p1<span class="token operator">=</span>p1<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            p2<span class="token operator">=</span>p2<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//寻找到中间节点偏右的</span>    ListNode <span class="token operator">*</span><span class="token function">halfList</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span>        ListNode<span class="token operator">*</span> fast<span class="token operator">=</span>head<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> slow<span class="token operator">=</span>head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token operator">&amp;&amp;</span> fast<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            fast<span class="token operator">=</span>fast<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//fast可能为空</span>            slow<span class="token operator">=</span>slow<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//寻找到偏左的,</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> slow<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果要找偏右的则需要最后加一个 slow->next</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//翻转 ban指针的经典问题</span>    ListNode <span class="token operator">*</span><span class="token function">reverse</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//这里必须用ListNode 因为是定义的指针类型  返回的是指针</span>    <span class="token punctuation">{</span>        ListNode <span class="token operator">*</span>pre<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span>        ListNode <span class="token operator">*</span>cur<span class="token operator">=</span>head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//   这里没有判断head是否为空节点了</span>        ListNode <span class="token operator">*</span>t<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            ListNode<span class="token operator">*</span> nextTemp <span class="token operator">=</span> cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>pre<span class="token punctuation">;</span>            pre<span class="token operator">=</span>cur<span class="token punctuation">;</span>            cur<span class="token operator">=</span>nextTemp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>           <span class="token keyword">return</span> pre<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//最后是pre的最后一个节点往回指</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里必须用ListNode 因为是定义的指针类型 ,不能使用 void函数，否则会报错，具体情况还不是很清楚，之后再研究研究</p></blockquote><h3 id="19删除列表的倒数第n个节点"><a href="#19删除列表的倒数第n个节点" class="headerlink" title="19删除列表的倒数第n个节点"></a>19删除列表的倒数第n个节点</h3><p>408某年的考题</p><p> 这玩意没有头节点。。。靠<br>边界条件写了好久才对，对照后两个样例数据不难写出。<br>后面看了看官方的答案，添加一个<strong><em>哑节点</em></strong>很棒，可以避免好多判断条件，学习到了。 </p><p>这个头结点极其诡异，需要考虑边界情况，正常应该是n-1，这里变成了n就有点迷。</p><pre class="line-numbers language-cpp"><code class="language-cpp">ListNode<span class="token operator">*</span> <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ListNode <span class="token operator">*</span>first <span class="token operator">=</span> head<span class="token punctuation">,</span> <span class="token operator">*</span>second <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        first <span class="token operator">=</span> first<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>first <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> head<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>first<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        first <span class="token operator">=</span> first<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        second <span class="token operator">=</span> second<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    second<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> second<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//直接让它的下一个等于下一个的下一个了</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) {} *     ListNode(int x) : val(x), next(nullptr) {} *     ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode <span class="token operator">*</span>fast<span class="token operator">=</span>head<span class="token punctuation">;</span>        ListNode <span class="token operator">*</span>slow<span class="token operator">=</span>head<span class="token punctuation">;</span>        ListNode <span class="token operator">*</span>pre<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>        head<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        fast<span class="token operator">=</span>fast<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>fast <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> head<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            fast<span class="token operator">=</span>fast<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            slow<span class="token operator">=</span>slow<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        slow<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>slow<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>官方答案</strong></p><p>解题思路<br>额外dummy指针，初始化让它的next指针指向head，方便做删除操作。不然删除第一个节点比较麻烦<br>cur为工作指针，这里用了两次，一次是用来计算链表的长度。第二次让cur指向待删除节点的前一个节点（有可能是dummy节点，如果删除的是第一个节点的话）<br>dummy-&gt;next即答案</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) {} *     ListNode(int x) : val(x), next(nullptr) {} *     ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        cur<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            len <span class="token operator">++</span> <span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cur <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> len <span class="token operator">-</span> n<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">&amp;&amp;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cur <span class="token operator">=</span> cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            k <span class="token operator">--</span> <span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">)</span> cur<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> dummy<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148 排序链表"></a>148 排序链表</h3><p> 给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。 </p><blockquote><p>无脑快排好吧，好吧 快排好像不现实，只能用归并排序了。</p></blockquote><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h4><p>使用归并排序的套路，归并排序要求首先需要找到中间点将两个链表一分为二，再分两部分进行递归排序，最后使用合并两个有序链表的方法合并两部分。</p><p>合并两个有序链表可以参考 Leetcode 21 题，由于链表不像数组，数组用新空间存储会造成额外的开销，但是链表仅仅是新建了一个头指针，其余节点都是原地的连接。</p><p>找到链表中间节点可以参考 Leetcode 816题，此处有一点不同的是，不同于数组的归并，找到mid位置后可以使用索引进行分段处理，链表必须实实在在的将其分成两部分，故 mid 作为第二条链的头指针， 同时需要维护将第一条链的末尾置为nullptr。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) {} *     ListNode(int x) : val(x), next(nullptr) {} *     ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">sortList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> head<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> mid <span class="token operator">=</span> <span class="token function">middleNode</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> left <span class="token operator">=</span> <span class="token function">sortList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> right <span class="token operator">=</span> <span class="token function">sortList</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ListNode<span class="token operator">*</span> <span class="token function">middleNode</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode<span class="token operator">*</span> fast <span class="token operator">=</span> head<span class="token punctuation">,</span> <span class="token operator">*</span>slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> prev <span class="token operator">=</span> slow<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">&amp;&amp;</span> fast<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            prev <span class="token operator">=</span> slow<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            slow <span class="token operator">=</span> slow<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        prev<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> slow<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ListNode<span class="token operator">*</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode<span class="token operator">*</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> tail <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">&amp;&amp;</span> l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">&lt;=</span> l2<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                tail<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>                l1 <span class="token operator">=</span> l1<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                tail<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>                l2 <span class="token operator">=</span> l2<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            tail <span class="token operator">=</span> tail<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        tail<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> l1 <span class="token operator">?</span> l1 <span class="token operator">:</span> l2<span class="token punctuation">;</span>        <span class="token keyword">return</span> head<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160 相交链表"></a>160 相交链表</h3><p> 给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。 </p><blockquote><p>这不又是一道408的原题嘛… 先计算出两个单链表的长度，然后再相减，让长度长的多走两步</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//没有特别多的技术含量 正常做</span><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode <span class="token operator">*</span><span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>headA<span class="token punctuation">,</span> ListNode <span class="token operator">*</span>headB<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        ListNode <span class="token operator">*</span>La<span class="token operator">=</span>headA<span class="token punctuation">,</span><span class="token operator">*</span>Lb<span class="token operator">=</span>headB<span class="token punctuation">;</span>        ListNode <span class="token operator">*</span>la<span class="token operator">=</span>headA<span class="token punctuation">,</span><span class="token operator">*</span>lb<span class="token operator">=</span>headB<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>La<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            a<span class="token operator">++</span><span class="token punctuation">;</span>            La<span class="token operator">=</span>La<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>Lb<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            b<span class="token operator">++</span><span class="token punctuation">;</span>            Lb<span class="token operator">=</span>Lb<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">></span>b<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>a<span class="token operator">-</span>b<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            la<span class="token operator">=</span>la<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>la<span class="token operator">!=</span>lb<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//这里注意是两个条件一个 la!=lb 还有一个需要长度不能太长</span>            <span class="token punctuation">{</span>                la<span class="token operator">=</span>la<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>                lb<span class="token operator">=</span>lb<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>la<span class="token operator">==</span>lb<span class="token punctuation">)</span>            <span class="token keyword">return</span> la<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>  <span class="token comment" spellcheck="true">//b比a更长 b要先走几步</span>        <span class="token punctuation">{</span>               <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>b<span class="token operator">-</span>a<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            lb<span class="token operator">=</span>lb<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>la<span class="token operator">!=</span>lb<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//注意这里的判断条件 la！=lb 且j要小于a，可能出现到末尾的时候还不满足，此时j=a 退出循环，如果只有一个判断条件那么会出现死循环，一直卡在这里</span>            <span class="token punctuation">{</span>                la<span class="token operator">=</span>la<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>                lb<span class="token operator">=</span>lb<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>la<span class="token operator">==</span>lb<span class="token punctuation">)</span>            <span class="token keyword">return</span> la<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="哈希表法"><a href="#哈希表法" class="headerlink" title="哈希表法"></a>哈希表法</h4><p>总结一下，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p><p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p><p>判断两个链表是否相交，可以使用哈希集合存储链表节点。</p><p>首先遍历链表$ \textit{headA}$，并将链表 $\textit{headA}headA$ 中的每个节点加入哈希集合中。然后遍历链表$ headB$，对于遍历到的每个节点，判断该节点是否在哈希集合中：</p><p>如果当前节点不在哈希集合中，则继续遍历下一个节点；</p><p>如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都在两个链表的相交部分，因此在链表 headB 中遍历到的第一个在哈希集合中的节点就是两个链表相交的节点，返回该节点。</p><p>如果链表 $\textit{headB}headB$ 中的所有节点都不在哈希集合中，则两个链表不相交，返回 $\text{null}null$。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode <span class="token operator">*</span><span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>headA<span class="token punctuation">,</span> ListNode <span class="token operator">*</span>headB<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unordered_set<span class="token operator">&lt;</span>ListNode <span class="token operator">*</span><span class="token operator">></span> visited<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//注意这里是定义的指针类型 这里是用unordered_set 因为只要查找就行</span>        ListNode <span class="token operator">*</span>temp <span class="token operator">=</span> headA<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>temp <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            visited<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//将temp插入到visited容器中</span>            temp <span class="token operator">=</span> temp<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        temp <span class="token operator">=</span> headB<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>temp <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//如果能够寻找到这个指针，表示在这个哈希集合里面，那么就返回该指针     里面存在temp</span>                <span class="token keyword">return</span> temp<span class="token punctuation">;</span>               <span class="token punctuation">}</span>            temp <span class="token operator">=</span> temp<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里要搞清楚unordered_set 和unordered_map的区别</p></blockquote><h3 id="206反转列表"><a href="#206反转列表" class="headerlink" title="206反转列表"></a>206反转列表</h3><h4 id="班指针"><a href="#班指针" class="headerlink" title="班指针"></a>班指针</h4><p><strong>写在前面：</strong><br><strong>我清晰记得，以前在数据结构课上，老师和我们说：涉及到链表的操作，一定要在纸上把过程先画出来，再写程序。</strong></p><p>现在想想，这句话简直是真理啊！</p><p>好理解的双指针<br>定义两个指针： prepre 和 curcur ；prepre 在前 curcur 在后。<br>每次让 prepre 的 nextnext 指向 curcur ，实现一次局部反转<br>局部反转完成之后，prepre 和 curcur 同时往前移动一个位置<br>循环上述过程，直至 prepre 到达链表尾部</p><p><strong>画个图就出来了，这个并不是说靠记忆，而是靠理解</strong></p><p>中间的线是断开的，pre一直都是指向的下一个，只有前面的cur不是指向的下一个而是指向的前一个</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode <span class="token operator">*</span>pre<span class="token operator">=</span>head<span class="token punctuation">;</span>        ListNode <span class="token operator">*</span>cur<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span>        ListNode <span class="token operator">*</span>t<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>pre<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            t<span class="token operator">=</span>pre<span class="token punctuation">;</span>            pre<span class="token operator">=</span>pre<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            t<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>cur<span class="token punctuation">;</span>            cur<span class="token operator">=</span>t<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cur<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">*</span>pre <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>pre <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ListNode<span class="token operator">*</span> t <span class="token operator">=</span> pre<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            pre<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//局部反转 然后让cur=pre，pre=t</span>            cur <span class="token operator">=</span> pre<span class="token punctuation">;</span>            pre <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cur<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><p>使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 retret .<br>此后，每次函数在返回的过程中，让当前结点的下一个结点的 nextnext 指针指向当前节点。<br>同时让当前结点的 nextnext 指针指向 NULLNULL ，从而实现从链表尾部开始的局部反转<br>当递归函数全部出栈后，链表反转完成。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> head<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode<span class="token operator">*</span> ret <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>head<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        head<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        head<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这个还挺有意思的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">reverse</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> pre<span class="token punctuation">,</span>ListNode<span class="token operator">*</span> cur<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> pre<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> temp <span class="token operator">=</span> cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        cur<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步</span>        <span class="token comment" spellcheck="true">// pre = cur;</span>        <span class="token comment" spellcheck="true">// cur = temp;</span>        <span class="token keyword">return</span> <span class="token function">reverse</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ListNode<span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 和双指针法初始化是一样的逻辑</span>        <span class="token comment" spellcheck="true">// ListNode* cur = head;</span>        <span class="token comment" spellcheck="true">// ListNode* pre = NULL;</span>        <span class="token keyword">return</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p> 我们可以发现，上面的递归写法和双指针法实质上都是从前往后翻转指针指向，其实还有另外一种与双指针法不同思路的递归写法：从后往前翻转指针指向。 </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 边缘条件判断</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 递归调用，翻转第二个节点开始往后的链表</span>        ListNode <span class="token operator">*</span>last <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>head<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 翻转头节点与第二个节点的指向</span>        head<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 此时的 head 节点为尾节点，next 需要指向 NULL</span>        head<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> last<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="203-移出链表元素"><a href="#203-移出链表元素" class="headerlink" title="203 移出链表元素"></a>203 移出链表元素</h3><p> 给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。 </p><p>这里需要一个dummy节点会更好一点</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>链表的定义具有递归的性质，因此链表题目常可以用递归的方法求解。这道题要求删除链表中所有节点值等于特定值的节点，可以用递归实现。</p><p>对于给定的链表，首先对除了头节点 \textit{head}head 以外的节点进行删除操作，然后判断 \textit{head}head 的节点值是否等于给定的 \textit{val}val。如果 \textit{head}head 的节点值等于 \textit{val}val，则 \textit{head}head 需要被删除，因此删除操作后的头节点为 \textit{head}.\textit{next}head.next；如果 \textit{head}head 的节点值不等于 \textit{val}val，则 \textit{head}head 保留，因此删除操作后的头节点还是 \textit{head}head。上述过程是一个递归的过程。</p><p>递归的终止条件是 \textit{head}head 为空，此时直接返回 \textit{head}head。当 \textit{head}head 不为空时，递归地进行删除操作，然后判断 \textit{head}head 的节点值是否等于 \textit{val}val 并决定是否要删除 \textit{head}head。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">removeElements</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        head<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> <span class="token function">removeElements</span><span class="token punctuation">(</span>head<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> head<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">==</span> val <span class="token operator">?</span> head<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">:</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//好吧这个remove当做一个函数来看待，那么就可以返回head->next</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>1，递归参数和返回值  2，终止条件 3，确定单层递归的逻辑 感觉基本上可以用循环的地方就能够用递归</p></blockquote><h4 id="设置虚拟头结点"><a href="#设置虚拟头结点" class="headerlink" title="设置虚拟头结点"></a>设置虚拟头结点</h4><p>dummyHead 设置虚拟头结点也是一个用得特别多的一个操作,这样//留下前一个节点</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">removeElements</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode<span class="token operator">*</span> dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 设置一个虚拟头结点</span>        dummyHead<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将虚拟头结点指向head，这样方面后面做删除操作</span>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                ListNode<span class="token operator">*</span> tmp <span class="token operator">=</span> cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>                cur<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>                <span class="token keyword">delete</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                cur <span class="token operator">=</span> cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        head <span class="token operator">=</span> dummyHead<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token keyword">delete</span> dummyHead<span class="token punctuation">;</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707 设计链表"></a><strong>707 设计链表</strong></h3><p><img src="%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97%E6%A0%88.assets/202202251509814.png" alt="1642473653462"></p><p>单链表的两个属性</p><p>这道题目设计链表的五个接口：</p><ul><li>获取链表第index个节点的数值</li><li>在链表的最前面插入一个节点</li><li>在链表的最后面插入一个节点</li><li>在链表第index个节点前面插入一个节点</li><li>删除链表的第index个节点</li></ul><p>可以说这五个接口，已经覆盖了链表的常见操作，是练习链表操作非常好的一道题目</p><p><strong>链表操作的两种方式：</strong></p><ol><li>直接使用原来的链表来进行操作。</li><li>设置一个虚拟头结点在进行操作。</li></ol><p>下面采用的设置一个虚拟头结点（这样更方便一些，大家看代码就会感受出来）。</p><p> <strong>虚拟头结点法的好处：使得原链表的所有节点都可以按照统一的方式进行增加或者删除，从而不必再写两段代码进行判断和增加删除。</strong> </p><p>pre–表示之前的 post–表示之后的 current–表示现在的</p><blockquote><p>这道题目并不难，但是十分的经典，涉及到了链表的基本操作，自己手打一遍</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyLinkedList</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// 定义链表节点结构体</span>    <span class="token keyword">struct</span> LinkedNode <span class="token punctuation">{</span>        <span class="token keyword">int</span> val<span class="token punctuation">;</span>        LinkedNode<span class="token operator">*</span> next<span class="token punctuation">;</span>        <span class="token function">LinkedNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">val</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化链表</span>    <span class="token function">MyLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        _dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">LinkedNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点</span>        _size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//初始时长度为0</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点</span>    <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">></span> <span class="token punctuation">(</span>_size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span> index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//>size-1 说明超出了最大值的范围</span>        <span class="token punctuation">}</span>        LinkedNode<span class="token operator">*</span> cur <span class="token operator">=</span> _dummyHead<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>index<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果--index 就会陷入死循环，如果index=0的话，先--直接为负数了，然后就陷入死循环了</span>            cur <span class="token operator">=</span> cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cur<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点 哑结点的作用是为了更好地插入</span>    <span class="token keyword">void</span> <span class="token function">addAtHead</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LinkedNode<span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">LinkedNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        newNode<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> _dummyHead<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        _dummyHead<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//dummyhead 永远是个虚拟指针</span>        _size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 在链表最后面添加一个节点</span>    <span class="token keyword">void</span> <span class="token function">addAtTail</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LinkedNode<span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">LinkedNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        LinkedNode<span class="token operator">*</span> cur <span class="token operator">=</span> _dummyHead<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            cur <span class="token operator">=</span> cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cur<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        _size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span>    <span class="token comment" spellcheck="true">// 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span>    <span class="token comment" spellcheck="true">// 如果index大于链表的长度，则返回空</span>    <span class="token keyword">void</span> <span class="token function">addAtIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">></span> _size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        LinkedNode<span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">LinkedNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        LinkedNode<span class="token operator">*</span> cur <span class="token operator">=</span> _dummyHead<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>index<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cur <span class="token operator">=</span> cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        newNode<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        cur<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        _size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的</span>    <span class="token keyword">void</span> <span class="token function">deleteAtIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">>=</span> _size <span class="token operator">||</span> index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        LinkedNode<span class="token operator">*</span> cur <span class="token operator">=</span> _dummyHead<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>index<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cur <span class="token operator">=</span> cur <span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        LinkedNode<span class="token operator">*</span> tmp <span class="token operator">=</span> cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        cur<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token keyword">delete</span> tmp<span class="token punctuation">;</span>        _size<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 打印链表</span>    <span class="token keyword">void</span> <span class="token function">printLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        LinkedNode<span class="token operator">*</span> cur <span class="token operator">=</span> _dummyHead<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cout <span class="token operator">&lt;&lt;</span> cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> _size<span class="token punctuation">;</span>    LinkedNode<span class="token operator">*</span> _dummyHead<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyLinkedList</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//定义一个链表</span>    <span class="token keyword">struct</span> LinkedNode <span class="token punctuation">{</span> <span class="token keyword">int</span> val<span class="token punctuation">;</span>        LinkedNode<span class="token operator">*</span> next<span class="token punctuation">;</span>        <span class="token function">LinkedNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">val</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">MyLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">LinkedNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义的节点是虚拟的头结点，方便用于删除操作</span>        size<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//开始时size为0</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">></span><span class="token punctuation">(</span>size<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">||</span> index<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//index要小于等于size-1 并且大于等于0</span>        LinkedNode <span class="token operator">*</span>cur<span class="token operator">=</span>dummyhead<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>index<span class="token operator">--</span><span class="token punctuation">)</span>        cur<span class="token operator">=</span>cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> cur<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">addAtHead</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LinkedNode <span class="token operator">*</span>newNode<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">LinkedNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        newNode<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>dummyhead<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        dummyhead<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>newNode<span class="token punctuation">;</span>         size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">addAtTail</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LinkedNode <span class="token operator">*</span>newNode<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">LinkedNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        LinkedNode<span class="token operator">*</span> cur <span class="token operator">=</span> dummyhead<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>        cur<span class="token operator">=</span>cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>newNode<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">addAtIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">></span>size<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>        LinkedNode <span class="token operator">*</span>newNode<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">LinkedNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义新节点</span>        LinkedNode <span class="token operator">*</span>cur<span class="token operator">=</span>dummyhead<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>index<span class="token operator">--</span><span class="token punctuation">)</span>        cur<span class="token operator">=</span>cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        newNode<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>newNode<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">deleteAtIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">></span>size<span class="token number">-1</span><span class="token operator">||</span>index<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>        LinkedNode <span class="token operator">*</span>cur<span class="token operator">=</span>dummyhead<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>index<span class="token operator">--</span><span class="token punctuation">)</span>        cur<span class="token operator">=</span>cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        LinkedNode <span class="token operator">*</span>tmp<span class="token operator">=</span>cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token keyword">delete</span> tmp<span class="token punctuation">;</span>        size<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span><span class="token operator">:</span>  <span class="token comment" spellcheck="true">//这里有个私有类型，是已经定义过了的</span>    <span class="token keyword">int</span> _size<span class="token punctuation">;</span>    LinkedNode<span class="token operator">*</span> _dummyHead<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList* obj = new MyLinkedList(); * int param_1 = obj->get(index); * obj->addAtHead(val); * obj->addAtTail(val); * obj->addAtIndex(index,val); * obj->deleteAtIndex(index); */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里忽略了一个<strong>私有类型</strong> private，所以说细节还是很重要的，你以为你懂了，自己手写一遍发现错的还是很多</p></blockquote><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24 两两交换链表中的节点"></a>24 两两交换链表中的节点</h3><p> 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 </p><h4 id="迭代：三个指针"><a href="#迭代：三个指针" class="headerlink" title="迭代：三个指针"></a>迭代：三个指针</h4><blockquote><p><strong>dummy指针用起来简直不要太舒服,要善于使用dummy</strong></p><p>//还需要用一个指针来记录前一个 两个指针不够用,每次交换完之后是前进两个格子</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token operator">||</span>head<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>        ListNode <span class="token operator">*</span>dummy<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode <span class="token operator">*</span>tmp<span class="token operator">=</span>dummy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//tmp是辅助指针</span>        dummy<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>tmp<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token operator">&amp;&amp;</span>tmp<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果是单数的话就会卡在倒数第二个地方，然后退出循环了</span>        <span class="token punctuation">{</span>               ListNode <span class="token operator">*</span>cur<span class="token operator">=</span>tmp<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">,</span><span class="token operator">*</span>post<span class="token operator">=</span>tmp<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//</span>            tmp<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>post<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            post<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>cur<span class="token punctuation">;</span>            tmp<span class="token operator">=</span>cur<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//tmp=tmp->next->next ;一样的 自己画个图就能看出来了</span>        <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//还需要用一个指针来记录前一个,dummy用起来真的不要太舒服了</span>        <span class="token keyword">return</span> dummy<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><p>LeetCode官方解答</p><p>可以通过递归的方式实现两两交换链表中的节点。</p><p>递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。</p><p>如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。</p><p>用 head 表示原始链表的头节点，新的链表的第二个节点，用 newHead 表示新的链表的头节点，原始链表的第二个节点，则原始链表中的其余节点的头节点是 newHead.next。令 head.next = swapPairs(newHead.next)，表示将其余节点进行两两交换，交换后的新的头节点为 head 的下一个节点。然后令 newHead.next = head，即完成了所有节点的交换。最后返回新的链表的头节点 newHead。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> head<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode<span class="token operator">*</span> newHead <span class="token operator">=</span> head<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        head<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>newHead<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        newHead<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">return</span> newHead<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//最后的这个newhead是头结点 不得不说还是挺秒的</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="队列与栈"><a href="#队列与栈" class="headerlink" title="队列与栈"></a>队列与栈</h2><h3 id="20有效的括号"><a href="#20有效的括号" class="headerlink" title="20有效的括号"></a>20有效的括号</h3><p> 给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。 </p><blockquote><p>方法一：栈<br>判断括号的有效性可以使用「栈」这一数据结构来解决。</p><p>我们遍历给定的字符串 ss。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。</p><p>当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 ss 无效，返回 \text{False}False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。</p><p>在遍历结束后，如果栈中没有左括号，说明我们将字符串 ss 中的所有左括号闭合，返回 \text{True}True，否则返回 \text{False}False。</p><p>注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 \text{False}False，省去后续的遍历判断过程。</p></blockquote><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isValid</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> size<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>size<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//如果是奇数的话那么可以直接判断是错误的了</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//判别用哈希表来判别 unordered_map一般用来查找，unordered_set一般用来去重 有两个&lt;int,int>的感觉主要用map  &lt;int> 一个的主要用set</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">></span>pairs<span class="token operator">=</span><span class="token comment" spellcheck="true">//可以直接定义map</span>        <span class="token punctuation">{</span>            <span class="token punctuation">{</span><span class="token string">')'</span><span class="token punctuation">,</span><span class="token string">'('</span><span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span><span class="token string">']'</span><span class="token punctuation">,</span><span class="token string">'['</span><span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span><span class="token string">'}'</span><span class="token punctuation">,</span><span class="token string">'{'</span><span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//  中间是用逗号隔开的  前面是对应的key后面是对应的value</span>        stack<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> stk<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义一个字符类型的栈</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> ch<span class="token operator">:</span>s<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//对于数组或者容器类都可以这样写</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>pairs<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">||</span>stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span>pairs<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//pairs[ch]必须与最上面的相匹配 ((}}  这样的话top为'('  pairs[ch]为‘}’不等于，说明出现了错误   </span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//出栈    </span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//说明对应的count为0，暂时为空</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将对应的值入栈</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果里面还有偶数个字符，说明不为空，不是一一对应的，    (()){{ 这样子 就说明不为空</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>for (char ch: s)</strong> 参考网站：<a href="https://blog.csdn.net/wuxiecsdn/article/details/114589773" target="_blank" rel="noopener">https://blog.csdn.net/wuxiecsdn/article/details/114589773</a></p><p>1)这是cpp11中新增的一种循环写法，对数组(或容器类,如<a href="https://so.csdn.net/so/search?q=vector&spm=1001.2101.3001.7020" target="_blank" rel="noopener">vector</a>和array)的每个元素执行相同的操作，此外string类也支持这种对字符的遍历循环操作。<br>如: double prices[5] = {4.99,5.99,6.99,7.99,8.99};<br><strong>for(double x:prices)</strong><br><strong>cout &lt;&lt; x &lt;&lt; endl;</strong><br>其中,x最初表示数组prices的第一个元素,显示第一个元素后,不断执行循环,而x依次表示数组的其他元素。 </p></blockquote><h4 id="不用哈希表"><a href="#不用哈希表" class="headerlink" title="不用哈希表"></a>不用哈希表</h4><p>第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false</p><p>第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return false</p><p>第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号return false</p><p>那么什么时候说明左括号和右括号全都匹配了呢，就是字符串遍历完之后，栈是空的，就说明全都匹配了。</p><p>这个方法比哈希表更容易看懂一点点。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isValid</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'{'</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'}'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'['</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">']'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false</span>            <span class="token comment" spellcheck="true">// 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//如果为空或者</span>            <span class="token keyword">else</span> st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// st.top() 与 s[i]相等，栈弹出元素 即{} （） 【】是一一对应的。</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true</span>        <span class="token keyword">return</span> st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="21，合并两个有序链表"><a href="#21，合并两个有序链表" class="headerlink" title="21，合并两个有序链表"></a>21，合并两个有序链表</h3><h4 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h4><p>递归真的感觉有点学不来啊啊啊啊啊 好难，感觉还没开始就已经结束了。。。</p><p>要学习一下使用递归的特征，自己学的递归都太浅显了。</p><p><img src="%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97%E6%A0%88.assets/202202251509815.png" alt="1642215071068"></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> l2<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> l1<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">&lt;</span> l2<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            l1<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> l1<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            l2<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> l2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>复杂度分析</p><p>时间复杂度：O(n + m)O(n+m)，其中 nn 和 mm 分别为两个链表的长度。因为每次调用递归都会去掉 <strong>l1 或者 l2 的头节点（直到至少有一个链表为空）</strong>，函数 mergeTwoList 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 O(n+m)O(n+m)。</p><p>空间复杂度：O(n + m)O(n+m)，其中 nn 和 mm 分别为两个链表的长度。递归调用 mergeTwoLists 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 n+mn+m 次，因此空间复杂度为 O(n+m)O(n+m)。</p></blockquote><p>递归</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//(1,1):代表第一次进入递归函数，并且从第一个口进入，并且记录进入前链表的状态</span><span class="token function">merge</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span>null<span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">6</span><span class="token operator">-</span><span class="token operator">></span>null    <span class="token function">merge</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span>null<span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">6</span><span class="token operator">-</span><span class="token operator">></span>null        <span class="token function">merge</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span>null<span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">6</span><span class="token operator">-</span><span class="token operator">></span>null            <span class="token function">merge</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span>null<span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">6</span><span class="token operator">-</span><span class="token operator">></span>null                <span class="token function">merge</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span>null<span class="token punctuation">,</span> <span class="token number">6</span><span class="token operator">-</span><span class="token operator">></span>null                    <span class="token function">merge</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span>null<span class="token punctuation">,</span> <span class="token number">6</span><span class="token operator">-</span><span class="token operator">></span>null                        <span class="token function">merge</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token operator">:</span> null<span class="token punctuation">,</span> <span class="token number">6</span><span class="token operator">-</span><span class="token operator">></span>null                        <span class="token keyword">return</span> l2                    l1<span class="token punctuation">.</span>next <span class="token operator">--</span><span class="token operator">-</span> <span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">6</span><span class="token operator">-</span><span class="token operator">></span>null<span class="token punctuation">,</span> <span class="token keyword">return</span> l1                l1<span class="token punctuation">.</span>next <span class="token operator">--</span><span class="token operator">-</span> <span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">6</span><span class="token operator">-</span><span class="token operator">></span>null<span class="token punctuation">,</span> <span class="token keyword">return</span> l1            l2<span class="token punctuation">.</span>next <span class="token operator">--</span><span class="token operator">-</span> <span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">6</span><span class="token operator">-</span><span class="token operator">></span>null<span class="token punctuation">,</span> <span class="token keyword">return</span> l2        l2<span class="token punctuation">.</span>next <span class="token operator">--</span><span class="token operator">-</span> <span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">6</span><span class="token operator">-</span><span class="token operator">></span>null<span class="token punctuation">,</span> <span class="token keyword">return</span> l2    l2<span class="token punctuation">.</span>next <span class="token operator">--</span><span class="token operator">-</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">6</span><span class="token operator">-</span><span class="token operator">></span>null<span class="token punctuation">,</span> <span class="token keyword">return</span> l2l1<span class="token punctuation">.</span>next <span class="token operator">--</span><span class="token operator">-</span> <span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">1</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">4</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">5</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">6</span><span class="token operator">-</span><span class="token operator">></span>null<span class="token punctuation">,</span> <span class="token keyword">return</span> l1   <span class="token comment" spellcheck="true">//这个可以好好看看</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>思路</p><p>我们可以用迭代的方法来实现上述算法。当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。</p><p>首先，我们设定一个哨兵节点 prehead ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前节点的值小于等于 l2 ，我们就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把 prev 向后移一位。</p><p>在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。</p><p>需要设置一个虚拟的头结点</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> list1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> list2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode <span class="token operator">*</span>list<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//新建一个节点</span>        ListNode <span class="token operator">*</span>dummyhead<span class="token operator">=</span>list<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//需要设置一个虚拟的头结点 </span>        <span class="token comment" spellcheck="true">//基本逻辑思路没有什么问题，就是如何用代码实现有点困难</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>list1<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token operator">&amp;&amp;</span>list2<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>list1<span class="token operator">-</span><span class="token operator">></span>val<span class="token operator">></span>list2<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//这里 前面是指针，所以需要使用-></span>            <span class="token punctuation">{</span>                list<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>list2<span class="token punctuation">;</span>                list<span class="token operator">=</span>list<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>                list2<span class="token operator">=</span>list2<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                list<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>list1<span class="token punctuation">;</span>                list<span class="token operator">=</span>list<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>                list1<span class="token operator">=</span>list1<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//只会有一个没有运行完成。 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span>        list<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>list1<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token operator">?</span>list2<span class="token operator">:</span>list1<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//这一部分就有点像是归并排序的内容了</span>        <span class="token keyword">return</span> dummyhead<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//需要返回头结点 dummy的下一个才是对应的第一个结点，自己设计案例的时候可以看得到的</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p> 结构体引用中点（.）与箭头（-&gt;）的区别：<br> （推荐使用-&gt; 对于结构体类型的变量的成员的访问，无论数据类型如何都可以使用箭头访问!!）<br> <strong>（1）箭头（-&gt;）：左边必须为指针</strong><br> <strong>（2）点号（.）：左边必须为实体</strong> </p><p> 推荐全部使用-&gt;val</p></blockquote><h3 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84 柱状图中最大的矩形"></a>84 柱状图中最大的矩形</h3><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><img src="%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97%E6%A0%88.assets/202202251509816.png" alt="1642215370650" style="zoom:67%;"><blockquote><p>怎么感觉有点点像是那个盛水最多的容器呀，估计大概率要用到动态规划相关的内容，都是求的一个最大的面积</p></blockquote><h4 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h4><p>首先的话肯定可以暴力破解，O（n2）的时间复杂度,但是发现用双指针还不大好做，因为这里需要比较的是中间的指针</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> heights<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> size<span class="token operator">=</span>heights<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> area<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一定要定义 不然的话就错了 可能会显示出一个比较大的数</span>        <span class="token keyword">int</span> r<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>l<span class="token operator">&lt;</span>size<span class="token punctuation">;</span>l<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>r<span class="token operator">=</span>size<span class="token number">-1</span><span class="token punctuation">;</span>r<span class="token operator">>=</span>l<span class="token punctuation">;</span>r<span class="token operator">--</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                 <span class="token keyword">int</span> minheight<span class="token operator">=</span>INT_MAX<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//表示的是一个足够大的数 每次都重新定义 这个需要放在里面</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>r<span class="token punctuation">;</span>i<span class="token operator">>=</span>l<span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>                minheight<span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>minheight<span class="token punctuation">,</span>heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用来确定在r和l的范围内的最小高度 求这个数组内的最小值</span>                area<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>area<span class="token punctuation">,</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>minheight<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> area<span class="token punctuation">;</span>    <span class="token punctuation">}</span>          <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//超时了 但是结果没什么问题</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="单调栈（典型的空间换时间）（先放着吧-真的不大会）"><a href="#单调栈（典型的空间换时间）（先放着吧-真的不大会）" class="headerlink" title="单调栈（典型的空间换时间）（先放着吧 真的不大会）"></a>单调栈（典型的空间换时间）（先放着吧 真的不大会）</h4><p>其实可以把这个想象成锯木板，如果木板都是递增的那我很开心，如果突然遇到一块木板i矮了一截，那我就先找之前最戳出来的一块（其实就是第i-1块），计算一下这个木板单独的面积，然后把它锯成次高的，这是因为我之后的计算都再也用不着这块木板本身的高度了。再然后如果发觉次高的仍然比现在这个i木板高，那我继续单独计算这个次高木板的面积（应该是第i-1和i-2块），再把它俩锯短。直到发觉不需要锯就比第i块矮了，那我继续开开心心往右找更高的。当然为了避免到了最后一直都是递增的，所以可以在最后加一块高度为0的木板。</p><p>这个算法的关键点是把那些戳出来的木板早点单独拎出来计算，然后就用不着这个值了。说实话真的很佩服第一个想出来的人……</p><p>单调栈<br>单调栈分为单调递增栈和单调递减栈</p><ol start="11"><li>单调递增栈即栈内元素保持单调递增的栈</li><li>同理单调递减栈即栈内元素保持单调递减的栈</li></ol><p>操作规则（下面都以单调递增栈为例）</p><ol start="21"><li>如果新的元素比栈顶元素大，就入栈</li><li>如果新的元素较小，那就一直把栈内元素弹出来，直到栈顶比新元素小</li></ol><p>加入这样一个规则之后，会有什么效果</p><ol start="31"><li>栈内的元素是递增的</li><li>当元素出栈时，说明这个新元素是出栈元素向后找第一个比其小的元素</li></ol><p>举个例子，配合下图，现在索引在 6 ，栈里是 1 5 6 。<br>接下来新元素是 2 ，那么 6 需要出栈。<br>当 6 出栈时，右边 2 代表是 6 右边第一个比 6 小的元素。</p><p>当元素出栈后，说明新栈顶元素是出栈元素向前找第一个比其小的元素<br>当 6 出栈时，5 成为新的栈顶，那么 5 就是 6 左边第一个比 6 小的元素。</p><p> <strong>栈中存放的元素具有单调性</strong> </p><p>左边的高度和右边的高度都要小于自己，那么要使得最大，就是两边的</p><p>当前元素高度严格小于栈顶元素高度时需要出栈。符合后进先出的情况。</p><p>矩形宽度：当前元素下标-去除栈顶元素后拿的新的当前栈顶元素下标再-1。4-1-1=2</p><p><strong>思路</strong></p><ol><li>对于一个高度，如果能得到向左和向右的边界</li><li>那么就能对每个高度求一次面积</li><li>遍历所有高度，即可得出最大面积</li><li>使用单调栈，在出栈操作时得到前后边界并计算面积</li><li></li></ol><p>拓展：</p><p><img src="%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97%E6%A0%88.assets/202202251509817.png" alt="1643012399525"></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stack></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>heights<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size <span class="token operator">=</span> heights<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> heights<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> stk<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> heights<span class="token punctuation">[</span>stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">></span> heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> length <span class="token operator">=</span> heights<span class="token punctuation">[</span>stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> weight <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    weight <span class="token operator">=</span> i <span class="token operator">-</span> stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> length <span class="token operator">*</span> weight<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> length <span class="token operator">=</span> heights<span class="token punctuation">[</span>stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> weight <span class="token operator">=</span> size<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                weight <span class="token operator">=</span> size <span class="token operator">-</span> stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> length <span class="token operator">*</span> weight<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232 用栈实现队列"></a>232 用栈实现队列</h3><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p><p>实现 MyQueue 类：</p><p>void push(int x) 将元素 x 推到队列的末尾<br>int pop() 从队列的开头移除并返回元素<br>int peek() 返回队列开头的元素<br>boolean empty() 如果队列为空，返回 true ；否则，返回 false</p><p>说明：</p><p>你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p><p>进阶：</p><p>你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>队列是先进先出，后端入队，前端出队。栈是后进先出LIFO （last in first out）用两个栈即可，先是把所有元素都压下去，然后再弹出来。一个是输出栈，一个是输入栈</p><h4 id="两个栈"><a href="#两个栈" class="headerlink" title="两个栈"></a>两个栈</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyQueue</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> stIn<span class="token punctuation">;</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> stOut<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//定义两个栈，一个用来进，一个用来出</span>    <span class="token function">MyQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//入栈比较简单</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        stIn<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//出栈， 需要把所有的值都从stin放到stout中，如果stin中有元素的话就要把元素全都放在stout中，如果没有元素的话直接pop了</span>    <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>stOut<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//只有当stout为空的时候才能把stin的数据导入到stout</span>        <span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stIn<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                stOut<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>stIn<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把stin的栈顶元素放到stout中</span>                stIn<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//stin 出栈</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> result<span class="token operator">=</span>stOut<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stOut<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//经过了这个操作后stin中没有元素了，而stout里面有很多元素。</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//从队列的开头移除元素并且返回该元素</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 直接调用已有的pop函数，注意这里一定要调用一次pop，因为如果不调用pop的话，可能一直都在push使得stOut里面没有东西。</span>        stOut<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 因为pop函数弹出了元素res，所以再添加回去</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> stIn<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>stOut<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//两个都为空才是空的</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="225，用队列实现栈"><a href="#225，用队列实现栈" class="headerlink" title="225，用队列实现栈"></a>225，用队列实现栈</h3><p>使用队列实现栈的下列操作：</p><ul><li>push(x) – 元素 x 入栈</li><li>pop() – 移除栈顶元素</li><li>top() – 获取栈顶元素</li><li>empty() – 返回栈是否为空</li></ul><p>注意:</p><ul><li><p>你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。</p></li><li><p>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p></li><li><p>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</p></li></ul><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>上一道题目的镜像问题。只需要留下队列的最后一个元素即可。然后用一个队列作为辅助队列</p><h4 id="两个队列"><a href="#两个队列" class="headerlink" title="两个队列"></a>两个队列</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyStack</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> que1<span class="token punctuation">;</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> que2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 辅助队列，用来备份</span>    <span class="token comment" spellcheck="true">/** Initialize your data structure here. */</span>    <span class="token function">MyStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** Push element x onto stack. */</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        que1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** Removes the element on top of the stack and returns that element. */</span>    <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> que1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        size<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>size<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 将que1 导入que2，但要留下最后一个元素</span>            que2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>que1<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            que1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> que1<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 留下的最后一个元素就是要返回的值</span>        que1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        que1 <span class="token operator">=</span> que2<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 再将que2赋值给que1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>que2<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 清空que2</span>            que2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** Get the top element. */</span>    <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> que1<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** Returns whether the stack is empty. */</span>    <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> que1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>其实这道题目就是用一个队列就够了。</p><p>pop: 1234-&gt;4123-&gt;123</p><p><strong>一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyStack</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> que<span class="token punctuation">;</span>    <span class="token function">MyStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//入列</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//把队列反过来使用 这里画个图更好看出来</span>        <span class="token keyword">int</span> size<span class="token operator">=</span>que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        size<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>size<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把对头放到对尾</span>            que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//之后size=0了</span>        <span class="token keyword">int</span> res<span class="token operator">=</span>que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//还是得出来</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> que<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里是有相对应的队尾操作，但是栈就没有 不然的话还有点麻烦</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->top(); * bool param_4 = obj->empty(); */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>队列的相关操作；</p><pre class="line-numbers language-cpp"><code class="language-cpp">que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//表示队头</span>que<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//表队队尾 这个栈没有相对应的算法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="1047-删除字符串中所有相邻的重复项"><a href="#1047-删除字符串中所有相邻的重复项" class="headerlink" title="1047,删除字符串中所有相邻的重复项"></a>1047,删除字符串中所有相邻的重复项</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>这道题目用栈就行，当对应的s[i]和栈顶元素相同时，那么就出栈，否则的话就入栈，</p><p>无语了，结果不是定义一个栈，而是可以直接用string里pop和back。</p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>这里多说一句，也可以用栈，然后用两个栈，一个输入栈一个输出栈，还有一个string，然后一边弹出一边插入；不过就复杂许多了。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        string st<span class="token punctuation">;</span>        <span class="token keyword">int</span> size<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>st<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                st<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//pop_back();</span>            <span class="token keyword">else</span>                st<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> st<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97%E6%A0%88.assets/202202251509818.png" alt></p><p><a href="http://www.cplusplus.com/reference/string/string/back/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/string/string/back/</a> </p><p>参考的官方文档</p><p>这个几个还挺好用的，可以记录一下</p><p>char a=’i’    //char的定义 注意是单引号</p><h3 id="150，逆波兰表达式"><a href="#150，逆波兰表达式" class="headerlink" title="150，逆波兰表达式"></a>150，逆波兰表达式</h3><p>后缀表达式 ：左右中</p><p>示例 2：</p><ul><li>输入: [“4”, “13”, “5”, “/“, “+”]</li><li>输出: 6</li><li>解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</li></ul><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>如果是表达式的话，那么就出栈两次，并且将结果入栈。如果是数字的话就也入栈；</p><p>逆波兰表达式：</p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><p>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。<br>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。<br>逆波兰表达式主要有以下两个优点：</p><p>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。<br>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</p><h4 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">evalRPN</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> tokens<span class="token punctuation">)</span> <span class="token punctuation">{</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tokens<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"+"</span> <span class="token operator">||</span> tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"-"</span> <span class="token operator">||</span> tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"*"</span> <span class="token operator">||</span> tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//这里是双引号表示的是字符串的容器 {</span>                <span class="token keyword">int</span> num1 <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> num2 <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"+"</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>num2 <span class="token operator">+</span> num1<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"-"</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>num2 <span class="token operator">-</span> num1<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"*"</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>num2 <span class="token operator">*</span> num1<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"/"</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>num2 <span class="token operator">/</span> num1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">stoi</span><span class="token punctuation">(</span>tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 把栈里最后一个元素弹出（其实不弹出也没事）</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//这里出错的原因 返回的4 13 5之类的 tokens数组存放的是字符串 tokens[i]得到的是字符串  所以用if进行==比较吧，用switch还需要转化一下，switch只能对字符进行判断，不能对字符串进行判断 。   ''单引号表示的是字符 ""双引号表示的是字符串</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">evalRPN</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> tokens<span class="token punctuation">)</span> <span class="token punctuation">{</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">int</span> size<span class="token operator">=</span>tokens<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">char</span> k<span class="token operator">=</span>tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">switch</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">case</span> <span class="token string">"+"</span><span class="token operator">:</span><span class="token punctuation">{</span>                 <span class="token keyword">int</span> a<span class="token operator">=</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">int</span> b<span class="token operator">=</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">break</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span>                <span class="token keyword">case</span> <span class="token string">"-"</span><span class="token operator">:</span><span class="token punctuation">{</span>                 <span class="token keyword">int</span> a<span class="token operator">=</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">int</span> b<span class="token operator">=</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>b<span class="token operator">-</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">break</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span>                 <span class="token keyword">case</span> <span class="token string">"*"</span><span class="token operator">:</span><span class="token punctuation">{</span>                 <span class="token keyword">int</span> a<span class="token operator">=</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">int</span> b<span class="token operator">=</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>b<span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">break</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span>                <span class="token keyword">case</span> <span class="token string">"/"</span><span class="token operator">:</span><span class="token punctuation">{</span>                 <span class="token keyword">int</span> a<span class="token operator">=</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">int</span> b<span class="token operator">=</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>b<span class="token operator">/</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">break</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span>                <span class="token keyword">default</span><span class="token operator">:</span>st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">stoi</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="239-滑动窗口（困难）"><a href="#239-滑动窗口（困难）" class="headerlink" title="239 滑动窗口（困难）"></a>239 滑动窗口（困难）</h3><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p>进阶：</p><p>你能在线性时间复杂度内解决此题吗？</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p><strong>这里还是建议自己去看一下视频，视频解析比较好</strong></p><p>之前做过单调栈的问题，这次的题目是单调队列，先进先出，如果里面为空的话就push，如果的队尾小于nums[i]那么就push，当已经满了3个之后，将队尾元素放入到设计的vector中，之后再pop一个，如果比队尾大就push，</p><p><strong>只需要维护可能成为最大值的队列就可以了，它是单调递减的</strong></p><p>思路不是特别难，但是里面的一些细节真的让人觉得挺恶心的</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>q<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                q<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            q<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans <span class="token operator">=</span> <span class="token punctuation">{</span>nums<span class="token punctuation">[</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>q<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                q<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            q<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> i <span class="token operator">-</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                q<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MonotonicQueue</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> data<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>data<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>             data<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        data<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> data<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>data<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> n<span class="token punctuation">)</span>            data<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    MonotonicQueue window<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//先填满窗口的前 k - 1</span>            window<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 窗口向前滑动</span>            window<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            window<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//自己的写法 不过有问题 </span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">int</span> size<span class="token operator">=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>size<span class="token operator">==</span><span class="token number">0</span><span class="token operator">||</span>size<span class="token operator">==</span><span class="token number">1</span><span class="token operator">||</span>k<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//先处理边界条件</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>k<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">||</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span>q<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//比队尾元素大</span>            q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//把k个元素都放进去</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>k<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//要清楚什么情况下才要出栈！！！ 不是什么情况下都要出栈 注意这里需要先出栈 不然的话 [7,2,4] 2 这个就不能完成 7>4就错了</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">||</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>q<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//要两种条件满足一个就插入队列</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//代码随想录里的答案</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">class</span> <span class="token class-name">MyQueue</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//单调队列（从大到小）</span>    <span class="token keyword">public</span><span class="token operator">:</span>        deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> que<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用deque来实现单调队列</span>        <span class="token comment" spellcheck="true">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span>        <span class="token comment" spellcheck="true">// 同时pop之前判断队列当前是否为空。</span>        <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> value <span class="token operator">==</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                que<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span>        <span class="token comment" spellcheck="true">// 这样就保持了队列里的数值是单调从大到小的了。</span>        <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> value <span class="token operator">></span> que<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                que<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            que<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。</span>        <span class="token keyword">int</span> <span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MyQueue que<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> result<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 先将前k的元素放进队列</span>            que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// result 记录前k的元素的最大值</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 滑动窗口移除最前面元素</span>            que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 滑动窗口前加入最后面的元素</span>            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 记录对应的最大值</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="347，前K个高频元素"><a href="#347，前K个高频元素" class="headerlink" title="347，前K个高频元素"></a>347，前K个高频元素</h3><p>（不大会建堆，思路上问题不大 之后等学到排序的时候再重新回来看看）</p><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><p>示例 1:</p><ul><li>输入: nums = [1,1,1,2,2,3], k = 2</li><li>输出: [1,2]</li></ul><p>示例 2:</p><ul><li>输入: nums = [1], k = 1</li><li>输出: [1]</li></ul><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p><img src="%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97%E6%A0%88.assets/202202251509820.png" alt="1642473139523"></p><p>首先遍历整个数组，并使用哈希表记录每个数字出现的次数，并形成一个「出现次数数组」。找出原数组的前 kk 个高频元素，就相当于找出「出现次数数组」的前 kk 大的值。</p><p>最简单的做法是给「出现次数数组」排序。但由于可能有 O(N)O(N) 个不同的出现次数（其中 NN 为原数组长度），故总的算法复杂度会达到 O(N\log N)O(NlogN)，不满足题目的要求。</p><p>这竟然和我想的一模一样，不过这样的话好像时间复杂度就太高了</p><p>建堆的过程等到了堆排序部分再好好学学</p><p>查找频率前几的队列，首先需要统计频率，使用unordered_map来统计总共有多少种数字，然后再通过对它进行排序，并且从高到低输出，时间复杂度太高了 </p><h4 id="优先级队列-小顶堆"><a href="#优先级队列-小顶堆" class="headerlink" title="优先级队列 小顶堆"></a>优先级队列 小顶堆</h4><p> 堆，优先队列 很好的练习，因此有必要自己用python实现研究一下。<strong>堆 处理海量数据的 topK，分位数 非常合适，优先队列 应用在元素优先级排序，比如本题的频率排序非常合适。</strong>与基于比较的排序算法 时间复杂度 O(nlogn)O(nlogn) 相比，使用 堆，优先队列 复杂度可以下降到 O(nlogk)O(nlogk)，在总体数据规模 n 较大，而维护规模 k 较小时，时间复杂度优化明显。</p><p><strong>今年408考研出了堆排序呀 哎，还是得多做题</strong></p><p><img src="%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97%E6%A0%88.assets/202202251509821.png" alt="1642474128539"></p><p>更多的关于堆的练习</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> m<span class="token punctuation">,</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> m<span class="token punctuation">.</span>second <span class="token operator">></span> n<span class="token punctuation">.</span>second<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//    用来比较大小</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> occurrences<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> v <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            occurrences<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数</span>        priority_queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cmp<span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">q</span><span class="token punctuation">(</span>cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> count<span class="token punctuation">]</span> <span class="token operator">:</span> occurrences<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second <span class="token operator">&lt;</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ret<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>            q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="394字符串编码（中等-1-18写一下这个-没做）"><a href="#394字符串编码（中等-1-18写一下这个-没做）" class="headerlink" title="394字符串编码（中等 1.18写一下这个 没做）"></a>394字符串编码（中等 1.18写一下这个 没做）</h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>第一眼看上去应该是用栈来解决，而且不算是单调栈，就是正常的栈，感觉和有效的括号和逆波兰表达式有一定的相似之处，但是更难</p><h4 id="辅助栈法"><a href="#辅助栈法" class="headerlink" title="辅助栈法"></a>辅助栈法</h4><p> 需要<strong>从内向外</strong>生成与拼接字符串，这与栈的<strong>先入后出</strong>特性对应。 FILO，后进的最先进行运算 //明天写一下这个</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">decodeString</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        string res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//用来记录数字或者字幕</span>        stack <span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">;</span>        stack <span class="token operator">&lt;</span>string<span class="token operator">></span> strs<span class="token punctuation">;</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span>         <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token string">'0'</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token string">'9'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果是数字的话就放进去</span>            <span class="token punctuation">{</span>                num <span class="token operator">=</span> num <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token string">'a'</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token string">'z'</span><span class="token punctuation">)</span> <span class="token operator">||</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token string">'A'</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token string">'Z'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                res <span class="token operator">=</span> res <span class="token operator">+</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//如果是字母的话就放进res中</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'['</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//将‘[’前的数字压入nums栈内， 字母字符串压入strs栈内</span>            <span class="token punctuation">{</span>                nums<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>                num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                strs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>                 res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token comment" spellcheck="true">//遇到‘]’时，操作与之相配的‘[’之间的字符，使用分配律</span>            <span class="token punctuation">{</span>                <span class="token keyword">int</span> times <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                nums<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//把数字栈弹出一个与str栈结合起来</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> times<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span>                    strs<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span><span class="token operator">=</span> res<span class="token punctuation">;</span>                res <span class="token operator">=</span> strs<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//之后若还是字母，就会直接加到res之后，因为它们是同一级的运算</span>                                  <span class="token comment" spellcheck="true">//若是左括号，res会被压入strs栈，作为上一层的运算</span>                strs<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//把那个已经用过的strs弹出来</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h4><p>我们也可以用递归来解决这个问题，从左向右解析字符串：</p><p>如果当前位置为数字位，那么后面一定包含一个用方括号表示的字符串，即属于这种情况：k[…]：<br>我们可以先解析出一个数字，然后解析到了左括号，递归向下解析后面的内容，遇到对应的右括号就返回，此时我们可以根据解析出的数字 xx 解析出的括号里的字符串 s’s<br>′<br>  构造出一个新的字符串 x \times s’x×s<br>′<br> ；<br>我们把 k[…] 解析结束后，再次调用递归函数，解析右括号右边的内容。<br>如果当前位置是字母位，那么我们直接解析当前这个字母，然后递归向下解析这个字母后面的内容。<br>如果觉得这里讲的比较抽象，可以结合代码理解一下这个过程</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//官方答案 看不懂，不大会.... 之后学递归的时候再重新看</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    string src<span class="token punctuation">;</span>     size_t ptr<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">getDigits</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>ptr <span class="token operator">&lt;</span> src<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isdigit</span><span class="token punctuation">(</span>src<span class="token punctuation">[</span>ptr<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ret <span class="token operator">=</span> ret <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> src<span class="token punctuation">[</span>ptr<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    string <span class="token function">getString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> src<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> src<span class="token punctuation">[</span>ptr<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">']'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// String -> EPS</span>            <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">char</span> cur <span class="token operator">=</span> src<span class="token punctuation">[</span>ptr<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">int</span> repTime <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        string ret<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isdigit</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// String -> Digits [ String ] String</span>            <span class="token comment" spellcheck="true">// 解析 Digits</span>            repTime <span class="token operator">=</span> <span class="token function">getDigits</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 过滤左括号</span>            <span class="token operator">++</span>ptr<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 解析 String</span>            string str <span class="token operator">=</span> <span class="token function">getString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 过滤右括号</span>            <span class="token operator">++</span>ptr<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 构造字符串</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>repTime<span class="token operator">--</span><span class="token punctuation">)</span> ret <span class="token operator">+</span><span class="token operator">=</span> str<span class="token punctuation">;</span>         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isalpha</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// String -> Char String</span>            <span class="token comment" spellcheck="true">// 解析 Char</span>            ret <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> src<span class="token punctuation">[</span>ptr<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ret <span class="token operator">+</span> <span class="token function">getString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    string <span class="token function">decodeString</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        src <span class="token operator">=</span> s<span class="token punctuation">;</span>        ptr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">getString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3，无重复字符的最长子串"><a href="#3，无重复字符的最长子串" class="headerlink" title="3，无重复字符的最长子串"></a>3，无重复字符的最长子串</h3><p> 给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。 </p><p>输入: s = “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。<br>示例 4:</p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>如果是子序列的话直接用哈希表来做就可以了，用哈希表记录每个字符出现的次数，然后最后统一输出数组。map用来查找，set用来去重。</p><p>思路就是滑动窗口，使其满足条件</p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>什么是滑动窗口？</p><p>其实就是一个队列,比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！</p><p>如何移动？</p><p>我们只要把队列的左边的元素移出就行了，直到满足题目要求！</p><p>一直维持这样的队列，找出队列出现最长的长度时候，求出解！</p><p>时间复杂度：O(n)</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        unordered_set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> lookup<span class="token punctuation">;</span>        <span class="token keyword">int</span> maxStr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>lookup<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> lookup<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                lookup<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                left <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            maxStr <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxStr<span class="token punctuation">,</span>i<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            lookup<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxStr<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习01</title>
      <link href="/2022/02/24/ji-qi-xue-xi-01/"/>
      <url>/2022/02/24/ji-qi-xue-xi-01/</url>
      
        <content type="html"><![CDATA[<h3 id="1-2-什么是机器学习"><a href="#1-2-什么是机器学习" class="headerlink" title="1-2 什么是机器学习"></a>1-2 什么是机器学习</h3>]]></content>
      
      
      
        <tags>
            
            <tag> -机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/02/23/hello-world/"/>
      <url>/2022/02/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cpp基础</title>
      <link href="/2022/02/23/c-ji-chu/"/>
      <url>/2022/02/23/c-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="cpp基础"><a href="#cpp基础" class="headerlink" title="cpp基础"></a>cpp基础</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span><span class="token string">"hello world"</span> <span class="token operator">&lt;&lt;</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>cin表示输入；cout表示输出 ；endl表示换行</p><h3 id="基本头文件"><a href="#基本头文件" class="headerlink" title="基本头文件"></a>基本头文件</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostraem></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cmath></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstring></span></span><span class="token comment" spellcheck="true">//相当于是把.h改为了前面＋c</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组的相关表示"><a href="#数组的相关表示" class="headerlink" title="数组的相关表示"></a>数组的相关表示</h3><pre class="line-numbers language-cpp"><code class="language-cpp">num<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//表示数组的长度</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="string类的基本操作"><a href="#string类的基本操作" class="headerlink" title="string类的基本操作"></a>string类的基本操作</h3><pre class="line-numbers language-cpp"><code class="language-cpp">string s1<span class="token operator">=</span><span class="token string">"hello world"</span><span class="token punctuation">;</span>string s2<span class="token punctuation">;</span>cin <span class="token operator">>></span> s1<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//注意用cin读入字符串的时候是以空格为分隔符</span>cout <span class="token operator">&lt;&lt;</span>s1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//基本输入输出</span><span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//读一行的字符串包括空格</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//输出字符串的长度</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>s.length用来表述字符的长度。</p><p>string 中还有个很常⽤的函数叫做 substr ，作⽤是截取某个字符串中的⼦串，⽤法有两种形式：</p><pre class="line-numbers language-cpp"><code class="language-cpp">string s2 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 表示从下标4开始⼀直到结束</span>string s3 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 表示从下标5开始，3个字符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>cpp的引⽤&amp;和传值的区别<br>这个引⽤符号 &amp; 要和C语⾔⾥⾯的取地址运算符 &amp; 区分开来，他们没有什么关系，cpp⾥⾯的引⽤是指在变量名之前加⼀个 &amp; 符号，⽐如在函数传⼊的参数中 int &amp;a ，那么对这个引⽤变量 a 做的所有操作都是直接对传⼊的原变量进⾏的操作，并没有像原来 int a ⼀样只是拷⻉⼀个副本（传值），举两个例⼦：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//都会传给之前的n</span><span class="token punctuation">{</span>    a<span class="token operator">=</span><span class="token number">99</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">fun</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//输出结果为99</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    a<span class="token operator">=</span><span class="token number">99</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">fun</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//输出结果为0 还是不变，只是拷贝了一个对应的值</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="string类的clear-erase-back-pop-back之类的"><a href="#string类的clear-erase-back-pop-back之类的" class="headerlink" title="string类的clear/erase/back/pop_back之类的"></a>string类的clear/erase/back/pop_back之类的</h4><p><a href="https://blog.csdn.net/cainv89/article/details/48102991" target="_blank" rel="noopener">https://blog.csdn.net/cainv89/article/details/48102991</a></p><h3 id="struct结构体的应用"><a href="#struct结构体的应用" class="headerlink" title="struct结构体的应用"></a>struct结构体的应用</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token function">BiNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> BiNode <span class="token operator">*</span>rchild<span class="token punctuation">,</span><span class="token operator">*</span>lchild<span class="token punctuation">;</span><span class="token punctuation">}</span>BiNode<span class="token punctuation">;</span>BiNode root<span class="token punctuation">,</span>root<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//不需要加别的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="STL相关"><a href="#STL相关" class="headerlink" title="STL相关"></a>STL相关</h3><p>​    这个属于是重难点了。自己做的话估计会比较难，还是从题目中取慢慢地领会其中的做法吧。加油加油。</p><h4 id="sort的使用："><a href="#sort的使用：" class="headerlink" title="sort的使用："></a>sort的使用：</h4><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251507264.png" alt="1640680089552"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251507265.png" alt="1640680117931"></p><p>简单概括就是排序</p><p> vertor用sort (v.begin()，v.end（))</p><p>数组使用sort（a，a+n） <u>默认从小到大</u></p><p>如果是要从大到小则需要加一个bool型的cmp函数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a<span class="token operator">></span>b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>a<span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">,</span>cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">;</span>        <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>empty函数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//判断是不是空，如果是空的话就运行，不是空的话就不运行</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ture"</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> cout <span class="token operator">&lt;&lt;</span><span class="token string">"false"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//这个不是空，所以运行false</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>auto的用法：</p><p>补充： 意思是将t容器中的每一个元素从前往后枚举出来，并用 count 来表示，类似于Java中的 for each 语句 </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> count<span class="token operator">:</span>nums<span class="token punctuation">)</span>    cout <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//注意这里是count不是nums</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出为 0 2 1 1 0 2</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="unordered-map-unordered-set-map和set的用法和区别"><a href="#unordered-map-unordered-set-map和set的用法和区别" class="headerlink" title="unordered_map,unordered_set,map和set的用法和区别"></a>unordered_map,unordered_set,map和set的用法和区别</h3><p><a href="http://www.javashuo.com/article/p-zzwukzrv-hz.html" target="_blank" rel="noopener">http://www.javashuo.com/article/p-zzwukzrv-hz.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/296360525" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/296360525</a></p><pre class="line-numbers language-cpp"><code class="language-cpp">set<span class="token operator">&lt;</span>key<span class="token operator">></span> map<span class="token operator">&lt;</span>key<span class="token punctuation">,</span>value<span class="token operator">></span><span class="token comment" spellcheck="true">//unordered指无序</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>set一般用于去重（），map一般用于快速查询，find</p><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>在 cpp 中，每一个对象都能通过 <strong>this</strong> 指针来访问自己的地址。<strong>this</strong> 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。</p><p>友元函数没有 <strong>this</strong> 指针，因为友元不是类的成员。只有成员函数才有 <strong>this</strong> 指针。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstdlib></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">setname</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">setage</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">setscore</span><span class="token punctuation">(</span><span class="token keyword">float</span> score<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">float</span> score<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> Student<span class="token operator">::</span><span class="token function">setname</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> Student<span class="token operator">::</span><span class="token function">setage</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> Student<span class="token operator">::</span><span class="token function">setscore</span><span class="token punctuation">(</span><span class="token keyword">float</span> score<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>score <span class="token operator">=</span> score<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> Student<span class="token operator">::</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>name<span class="token operator">&lt;&lt;</span><span class="token string">"名字是"</span><span class="token operator">&lt;&lt;</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>age<span class="token operator">&lt;&lt;</span><span class="token string">"年龄是"</span><span class="token operator">&lt;&lt;</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>score<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Student <span class="token operator">*</span>pstu <span class="token operator">=</span> <span class="token keyword">new</span> Student<span class="token punctuation">;</span>    pstu <span class="token operator">-</span><span class="token operator">></span> <span class="token function">setname</span><span class="token punctuation">(</span><span class="token string">"lihua"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pstu <span class="token operator">-</span><span class="token operator">></span> <span class="token function">setage</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pstu <span class="token operator">-</span><span class="token operator">></span> <span class="token function">setscore</span><span class="token punctuation">(</span><span class="token number">96.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pstu <span class="token operator">-</span><span class="token operator">></span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以this是被调用对象访问调用他的对象的工</p><p>具，可以理解为this指向调用他的对象。默认情况下，this的类型是指向类类型非常量的常量指针，所以默认情况下，初始化时，我们不能把this绑定到</p><p>一个常量对象上去，因此，在参数列表的后面加上 const 修改this的属性，让其可以指向一个常量对象，可以增加函数的灵活性，这个成员函数也叫常</p><p>量成员函数。</p><pre class="line-numbers language-cpp"><code class="language-cpp">res<span class="token operator">=</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//表示调用了pop这个函数，指向了调用他的结果</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="stl之队列和栈"><a href="#stl之队列和栈" class="headerlink" title="stl之队列和栈"></a>stl之队列和栈</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//头文件</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;queue></span></span><span class="token comment" spellcheck="true">// 队列 </span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stack></span></span><span class="token comment" spellcheck="true">//栈</span><span class="token comment" spellcheck="true">//定义方式</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>  s<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//参数也是数据类型，这是栈的定义方式</span>queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>  q<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//参数是数据类型，这是队列的定义方式</span><span class="token comment" spellcheck="true">//栈</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果栈为空返回true，否则返回false  </span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//返回栈中元素的个数  </span>s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//删除栈顶元素但不返回其值  </span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//返回栈顶的元素，但不删除该元素  </span>s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//在栈顶压入新元素 ，参数X为要压入的元素</span><span class="token comment" spellcheck="true">//队列</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 如果队列为空返回true，否则返回false  </span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 返回队列中元素的个数  </span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//删除队列首元素但不返回其值  </span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 返回队首元素的值，但不删除该元素  </span>q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//在队尾压入新元素 ，X为要压入的元素</span>q<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//返回队列尾元素的值，但不删除该元素</span><span class="token comment" spellcheck="true">//例子</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stack></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span>    stack<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> s<span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> q<span class="token punctuation">.</span><span class="token function">enpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    s<span class="token punctuation">,</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="pair的用法"><a href="#pair的用法" class="headerlink" title="pair的用法"></a>pair的用法</h3><p><a href="https://blog.csdn.net/wqw1672/article/details/105501165/" target="_blank" rel="noopener">https://blog.csdn.net/wqw1672/article/details/105501165/</a></p><p><a href="https://zhuanlan.zhihu.com/p/99796723" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/99796723</a></p><p> pair是将2个数据组合成一组数据， pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//头文件</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;utility></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> <strong>创建pair</strong><br>在创建pair对象时，必须提供两个类型名，两个对应的类型名的类型不必相同 </p><pre class="line-numbers language-cpp"><code class="language-cpp">pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span> anon<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建一个空对象anon，两个元素类型都是string</span>pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> word_count<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 创建一个空对象 word_count, 两个元素类型分别是string和int类型</span>pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> line<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 创建一个空对象line，两个元素类型分别是string和vector类型</span>st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里都是成对插入的 与pair相对应    </span>stack<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">>></span> sta<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="C-中public、private"><a href="#C-中public、private" class="headerlink" title="C ++中public、private"></a>C ++中public、private</h3><p>1.public</p><p>定义的变量和常数都可以被其他类型变量（该类的孩子，兄弟等，其他类）使用， 类似公共用品。以public继承基类，基类的所有的属性和方法都保持原样不变。</p><p>2.private<br>只能在类里面调用，但是private修饰的变量也不是不能被其他类改变，可以通过该类中的public方法调用private变量<br>private继承基类，所有的方法和变量都变为private，类似于集合的关系</p><p>第一: private,public,protected的访问范围:</p><p>private: 只能由该类中的函数、其友元函数访问,不能被任何其他访问，该类的对象也不能访问.<br>protected: 可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问<br>public: 可以被该类中的函数、子类的函数、其友元函数访问,也可以由该类的对象访问<br>注：友元函数包括两种：设为友元的全局函数，设为友元类中的成员函数</p><p>第二:类的继承后方法属性变化:</p><p>使用private继承,父类的所有方法在子类中变为private; 使用protected继承,父类的protected和public方法在子类中变为protected,private方法不变; 使用public继承,父类中的方法属性不发生改变;</p><p>public:可以被任意实体访问</p><p>protected:只允许子类及本类的成员函数访问</p><p>private:只允许本类的成员函数访问</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><a href="https://www.cnblogs.com/averyfork/p/14420238.html" target="_blank" rel="noopener">https://www.cnblogs.com/averyfork/p/14420238.html</a></p><p><strong>2.auto遍历</strong></p><p>auto是声明自动变量格式为<strong>for(元素类型</strong> <strong>遍历值：数组/容器)，</strong></p><p>之所以用auto是可以根据赋值自动推导出变量类型。</p><p>加&amp;是引用，如果没有&amp;，每次遍历都会给重新开辟空间存放遍历的值，空间复杂度是O（n），而<strong>使用引用的话，即使用同一块空间</strong>。</p><p>同时，<strong>引用的情况下可以修改原来的值</strong>。</p><p>此外还有 for(auto&amp;&amp; count: counts)，其与for(auto&amp; count: counts)的区别在于auto的推导是否受初始化值的影响。</p><p><strong><code>auto&amp;&amp;</code> 的推导收到初始化值的 value category 的影响。用左值初始化，推导得结果是一个左值引用；否则是一个右值引用。</strong></p><p><strong><code>auto&amp;</code> 的推导与初始化值的 value category 无关。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组入门</title>
      <link href="/2021/02/23/shu-zu-ru-men/"/>
      <url>/2021/02/23/shu-zu-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><h3 id="写在前面的一些话："><a href="#写在前面的一些话：" class="headerlink" title="写在前面的一些话："></a>写在前面的一些话：</h3><p>把自己当做是一个什么都不懂的小孩，然后从零开始学起。每天保持一定的代码量，并且及时地去总结和复盘。这才是或者说这就是自己应该要做的事情。</p><h3 id="基本刷题思路"><a href="#基本刷题思路" class="headerlink" title="基本刷题思路"></a>基本刷题思路</h3><p>刷题顺序： 推荐刷题顺序： 数组 -&gt;字符串 -&gt;链表-&gt;二分查找-&gt;排序-&gt;哈希表-&gt; 栈-&gt;队列 -&gt;树 、递归、回溯 -&gt; 堆 -&gt;动态规划。</p><p>一开始如果五分钟没有思路的话可以去看答案了。前期因为可能对做这种题目还不够擅长不够熟练，但是每隔一个礼拜要重新回过头来看看。</p><p>注意特殊情况，边界条件。这种细节如果不是自己重新写一遍代码的话是发现不了问题的。每道题的思考不要超过一个小时。</p><p> LeetCode刷题顺序<br>\1. 跟着教程的章节来刷题；剑指offer和程序员面试经典<br>\2. 按LeetCode分类中的频率从高到低刷，例如字符串、数组、二分查找、哈希表、链表、双指针、栈、树、深度优先搜索、广度优先搜索、回溯法、排序<br>\3. 拓展一道题的相似题目<br>\4. Top100或者精选200<br>\5. 参加LeetCode周赛或者双周赛，基本做出前三道，有时能做出第四道，以中等难度为主，简单难度热身，弄懂Top100或者精选200中困难难度<br>\6. 定期复习，面试前冲刺热题</p><p>往返重复，拿出对待高考的态度和方法：先做例题，再做课后题，最后再做各种模拟套题</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509506.png" alt="1640661811942"></p><p><a href="https://bbs.csdn.net/skill/algorithm/algorithm-cbdd961fd6b9430c9d3750a9d9659cdb?category=202" target="_blank" rel="noopener">https://bbs.csdn.net/skill/algorithm/algorithm-cbdd961fd6b9430c9d3750a9d9659cdb?category=202</a></p><h3 id="1，两数之和（梦开始的地方）easy"><a href="#1，两数之和（梦开始的地方）easy" class="headerlink" title="1，两数之和（梦开始的地方）easy"></a>1，两数之和（梦开始的地方）easy</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><blockquote><p>初始思路：暴力解，然后开数组，以及哈希表。</p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">//无脑暴力解法class Solution {public:    vector<int> twoSum(vector<int>& nums, int target) {        int i,j;        for(i=0;i<nums.size();i++)            for(j=i+1;j<nums.size();j++){                if(nums[i]+nums[j]==target)                return {i,j};              }        return {};    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>几个注意点：</p><ul><li>return之后要加分号以及 是大括号而不是小括号</li></ul></blockquote><pre class="line-numbers language-c++"><code class="language-c++">//哈希表法class Solution {public:    vector<int> twoSum(vector<int>& nums, int target) {        unordered_map<int, int> hashtable;        for (int i = 0; i < nums.size(); ++i) {            auto it = hashtable.find(target - nums[i]);            if (it != hashtable.end()) {                return {it->second, i};            }            hashtable[nums[i]] = i;        }        return {};    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>知识点：哈希表的时间复杂度为O（1），感觉很多题目的哈希映射都是用的大数组来表示。具体的还是有点看不懂，<strong>先占个坑之后来补。</strong></p><p>ps：本来是想用数组来做的，试一了一下，发现不行，感觉数组也算是哈希表的一种，但是因为数组设置的时候会出现负数，下标会有负数，不能成立。所以只能用哈希表。</p><p>nums={2 11 7 3}  taget=9。<br>9-11为-2 a[-2]不成立。</p></blockquote><h3 id="4，寻找两个正序数组的中位数-hard"><a href="#4，寻找两个正序数组的中位数-hard" class="headerlink" title="4，寻找两个正序数组的中位数 hard"></a>4，寻找两个正序数组的中位数 hard</h3><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p><p>算法的时间复杂度应该为 O(log (m+n)) 。</p><blockquote><p>思路其实比较简单，因为这里提到了是O（log（m+n））已经知道的和log相关的算法只有归并，快排，二分其他的什么堆排序 桶排序之类的我就都不会了。。。 思路简单 实现起来其实还挺难的</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509507.png" alt="1641459223451"></p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">//别人的就看看吧    class Solution {public:    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {        int n = nums1.size();        int m = nums2.size();        if (n > m)  //保证数组1一定最短 //为了加快速度 对长度短的进行二分        {            return findMedianSortedArrays(nums2, nums1);        }        int LMax1 = 0, LMax2 = 0, RMin1 = 0, RMin2 = 0, c1, c2, lo = 0, hi = n;        while (lo <= hi) {            c1 = (hi + lo + 1) / 2;            c2 = (m + n) / 2 - c1;            LMax1 = (c1 == 0) ? INT_MIN : nums1[c1 - 1];            RMin1 = (c1 == n) ? INT_MAX : nums1[c1];            LMax2 = (c2 == 0) ? INT_MIN : nums2[c2 - 1];            RMin2 = (c2 == m) ? INT_MAX : nums2[c2];            if (LMax1 > RMin2)                hi = c1 - 1;            else if (LMax2 > RMin1)                lo = c1 + 1;            else                break;        }        if ((m + n) % 2)            return min(RMin1, RMin2);        else            return ((int64_t)max(LMax1, LMax2) + (int64_t)min(RMin1, RMin2)) / 2.0;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11，盛最多水的容器-mid"><a href="#11，盛最多水的容器-mid" class="headerlink" title="11，盛最多水的容器 mid"></a>11，盛最多水的容器 mid</h3><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器。</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509508.png" alt=""></p><blockquote><p>第一眼真的就暴力解，发现很多数组类的题目都可以暴力解，就是时间复杂度太高了。。。</p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">//无脑暴力解 是我不配了class Solution {public:    int maxArea(vector<int>& height) {        int area=0;        for(int i=0;i<height.size()-1;i++)        {            for(int j=i+1;j<=height.size()-1;j++)            {                int now=(j-i)*min(height[i],height[j]);                area=max(area,now);            }        }        return{m};    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">class Solution {public:    int maxArea(vector<int>& height) {        int area=0;        int i=0,j=height.size()-1;        while(i<j){            int now=(j-i)*min(height[i],height[j]);            //每次移动一小格，底都会-1，要满足题意，那高必须增加，要使得高增加那么就需要让更矮的一方向对方移动。            area=max(now,area);            if(height[i]<height[j]) //右边的更高一点,让左边的移动             i++;            else j--;        }        return{area};    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>正常解法：动态规划，双指针题目。从两边向中间靠拢. 背后的<strong>缩减搜索空间</strong>的思想去考虑题解。感觉有点点类似于快排，都是通过两者比较，一个移动一个不移动。</p><p>思想：从外到内，要使得area最大，又因为每次移动一小格，底都会-1，要满足题意，那高必须增加，要使得高增加那么就需要让更矮的一方向对方移动。</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509509.png" alt="1640674504454"><br><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509510.png" alt="1640674519223"><br>为什么只需要移动最小的一边呢。因为如果移动大的一边的话，里面水的面积的最大值会小于初始值。<br>$$<br>min(x,y)<em>t_初始&gt;min(x,y_现在)</em>t_{现在}<br>$$<br> 因为t初始一定是要大于t现在的，所以x不能作为边界条件，需要继续向右移动。所以x不是边界条件</p></blockquote><h3 id="15，三数之和-mid"><a href="#15，三数之和-mid" class="headerlink" title="15，三数之和 mid"></a>15，三数之和 mid</h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><blockquote><p>思路：第一感觉是用暴力。有点类似于408的某年真题，直接排序然后三重for循环暴力求解。</p><p>第二的感觉：三个指针，或者固定一个用双指针,但具体怎么做也还是不知道</p><p>第三种感觉：哈希表，具体怎么实现不知道..</p></blockquote><blockquote><p>题目中要求找到所有「不重复」且和为 00 的三元组，<strong>这个「不重复」的要求使得我们无法简单地使用三重循环枚举所有的三元组</strong>。这是因为在最坏的情况下，数组中的元素全部为 00，即</p><p> [0, 0, 0, 0, 0, …, 0, 0, 0]</p><p><strong>最终的思路：</strong></p><p>排序+双指针 。先通过sort函数排序先确定nums[i]为第⼀一个元素，为了了避免重复，如果nums[i]和刚刚的nums[i-1]相同就跳过continue，然后begin指向i+1，end指向n-1，判断此时的sum是否等于0，如果等于0就将结果放⼊入result数组中，且begin++，end – -，为了了避免重复，如果begin++后的元素依旧和刚才的元素相同，继续begin++，end同理理～如果sum&gt;0就将end – -，如果sum&lt;0就将begin++，<br>最后返回result结果集</p></blockquote><p>注意sort的使用</p><pre class="line-numbers language-c++"><code class="language-c++">//暴力破解法         解法1，通过315个案例，逻辑比较清晰，能够对vector的sort count 以及尝试过的unique（在使用unique之前需要进行排序） 都有比较好的理解         vector<vector<int>> result;         if(nums.size()<3){             return result;         }         for(int i = 0; i<nums.size()-2; i++){             for(int j = i+1; j<nums.size()-1; j++){                 for(int k=j+1; k<nums.size(); k++){                     if(nums[i] + nums[j] + nums[k] == 0){                         vector<int> temp;                         temp.push_back(nums[i]);                         temp.push_back(nums[j]);                         temp.push_back(nums[k]);                         sort(temp.begin(),temp.end());                         if(count(result.begin(),result.end(),temp) == 0){                             result.push_back(temp);                         }                     }                 }            }         }return result;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这个暴力破解没有写好，并不是说自己不会，而是c++的这种容器的形式还是不那么熟练，vector用的不够熟练，需要进行一些补充，之后把sort再看看。</p></blockquote><h5 id="最佳解法："><a href="#最佳解法：" class="headerlink" title="最佳解法："></a>最佳解法：</h5><p>排序+双指针：暂时没怎么看得懂 </p><pre class="line-numbers language-c++"><code class="language-c++">class Solution {public:    vector<vector<int>> threeSum(vector<int>& nums)     {        int size = nums.size();        if (size < 3)   return {};          // 特判        vector<vector<int> >res;            // 保存结果（所有不重复的三元组）        sort(nums.begin(), nums.end());// 排序（默认递增）        for (int i = 0; i < size; i++)      // 固定第一个数，转化为求两数之和        {            if (nums[i] > 0)    return res; // 第一个数大于 0，后面都是递增正数，不可能相加为零了            // 去重：如果此数已经选取过，跳过            if (i > 0 && nums[i] == nums[i-1])  continue;            // 双指针在nums[i]后面的区间中寻找和为0-nums[i]的另外两个数            int left = i + 1;            int right = size - 1;            while (left < right)            {                if (nums[left] + nums[right] > -nums[i])                    right--;    // 两数之和太大，右指针左移                else if (nums[left] + nums[right] < -nums[i])                    left++;     // 两数之和太小，左指针右移                else                {                    // 找到一个和为零的三元组，添加到结果中，左右指针内缩，继续寻找                    res.push_back(vector<int>{nums[i], nums[left], nums[right]});                    left++;                    right--;                    // 去重：第二个数和第三个数也不重复选取                    // 例如：[-4,1,1,1,2,3,3,3], i=0, left=1, right=5                    while (left < right && nums[left] == nums[left-1])  left++;                    while (left < right && nums[right] == nums[right+1])    right--;                }            }        }        return res;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">//自己的版本class Solution {public:    vector<vector<int>> threeSum(vector<int>& nums) {        if(nums.size()<3) return {};        vector<vector<int>> res;//定义一个容器vector        sort(nums.begin(),nums.end()); //排序，加了cmp是递减，不加是递增         for (int i = 0; i < nums.size(); i++)         {            if(nums[i]>0) return res;//            if(i>0&&nums[i]==nums[i-1])            continue;             //因为是已经排好序了，所以如果相邻两个相同，说明就不需要选择了。            int left=i+1;            int right=nums.size()-1;            while(left<right)            {                if((nums[left]+nums[right])>-nums[i])                right--; //两者相加大于-nums，说明需要变小，则right向左移动                else if (nums[left]+nums[right]<-nums[i])                left++;  //两者相加小于-nums，说明需要变大 则left向移动                else if(nums[left]+nums[right]==-nums[i])                {                     res.push_back(vector<int>{nums[i], nums[left], nums[right]});                    left++;                    right--;                    while (left < right && nums[left] == nums[left-1])  left++;                    while (left < right && nums[right] == nums[right+1])    right--;//左边和右边去除重复项                }            }        }    return res;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>思考补充：既然三数之和可以使用双指针法，我们之前讲过的1.两数之和，可不可以使用双指针法呢？</p><p>如果不能，题意如何更改就可以使用双指针法呢？ 大家留言说出自己的想法吧！</p><p>两数之和 就不能使用双指针法，因为1.两数之和要求返回的是索引下标， 而双指针法一定要排序，一旦排序之后原数组的索引就被改变了。</p><p>如果1.两数之和要求返回的是数值的话，就可以使用双指针法了。</p></blockquote><h3 id="75，颜色分类-mid"><a href="#75，颜色分类-mid" class="headerlink" title="75，颜色分类 mid"></a>75，颜色分类 mid</h3><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><blockquote><p>初步思考：</p><p>1，暴力解快排 O（nlogn）</p><p>2，哈希表映射</p><p>3，数组 这道题目就可以用数组来表示，因为里面只有0,1,2没有负数。</p><p>4,双指针或者单指针</p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">//用数组去求解class Solution {public:    void sortColors(vector<int>& nums) {        int color[3];        int j=0;        vector<vector<int>> res;               int size = nums.size();        if (nums.size() < 2) {            return;        }        for(int i=0;i<3;i++)        color[i]=0;        for(int i=0;i<nums.size();i++)        {            switch(nums[i])            {                case 0: color[0]++;continue;                case 1: color[1]++;continue;                case 2: color[2]++;continue;            }        }//建立一个辅助数组来记录012的数目。        for(int i=0;i<3;i++)        {            while(color[i]>0)            {                nums[j++]=i;                color[i]--;            }        }//重新赋值    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">//单指针法求解，进行两趟遍历。第一步是是让0全部都排到前面去，每次都是交换0和头部，然后头部往后面移动一位。 之后再遍历一遍，让1移动class Solution {public:    void sortColors(vector<int>& nums) {        int n = nums.size();        int ptr = 0;        for (int i = 0; i < n; ++i) {            if (nums[i] == 0) {                swap(nums[i], nums[ptr]);                ++ptr;            }        }        for (int i = ptr; i < n; ++i) {            if (nums[i] == 1) {                swap(nums[i], nums[ptr]);                ++ptr;            }        }    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">//双指针法class Solution {public:    void sortColors(vector<int>& nums) {        int n = nums.size();        int p0 = 0, p1 = 0;        for (int i = 0; i < n; ++i) {            if (nums[i] == 1) {                swap(nums[i], nums[p1]);                ++p1;            } else if (nums[i] == 0) {                swap(nums[i], nums[p0]);                if (p0 < p1) {                    swap(nums[i], nums[p1]);                }                ++p0;                ++p1;            }        }    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>双指针法可以好好学学，感觉双指针用的还是比较多的</strong>，一次遍历即可排好序。</p><p> 方法一需要进行两次遍历，那么我们是否可以仅使用一次遍历呢？我们可以额外使用一个指针，即使用两个指针分别用来交换 0 和 1。 </p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509511.png" alt="1640760359920"></p></blockquote><h3 id="76，最小覆盖子串-hard"><a href="#76，最小覆盖子串-hard" class="headerlink" title="76，最小覆盖子串 hard"></a>76，最小覆盖子串 hard</h3><ul><li><p>第一种思路，枚举出所有大于t长度的子串，然后再一个比对。</p></li><li><p>第二种思路：双指针（这道题目的思路和盛水最多的容器思路其实是一样的，先记录s和t每个字母的频数，然后让s不断地缩小</p></li></ul><p>第四种思想：hash map</p><blockquote><p>这里T是可能包含重复字符的，如果可能误解题目的意思，需要和面试官说清楚。可能到时候算法不一样。</p></blockquote><h5 id="新思想：滑动窗口"><a href="#新思想：滑动窗口" class="headerlink" title="新思想：滑动窗口"></a>新思想：滑动窗口</h5><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509512.png" alt="1641431986077"></p><blockquote><p>右边界右移</p><p>winFreq[s[right]]&lt;tFreq[s[right]]严格小于时，distance+1，当distance=t的长度时才说明包含所有字符。</p><p>左边界右移，如果出现winFreq[s[right]]&lt;tFreq[s[right]]时，说明不是包含的最小覆盖子串，此时不能移动，所以需要同时移动</p><p>时间复杂度O（1）</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509513.png" alt="1641433272682"></p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">minWindow</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s <span class="token operator">==</span> <span class="token string">""</span> <span class="token operator">||</span> t <span class="token operator">==</span> null <span class="token operator">||</span> t <span class="token operator">==</span> <span class="token string">""</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//维护两个数组，记录已有字符串指定字符的出现次数，和目标字符串指定字符的出现次数</span>        <span class="token comment" spellcheck="true">//ASCII表总长128</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> need <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> have <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将目标字符串指定字符的出现次数记录</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            need<span class="token punctuation">[</span>t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//分别为左指针，右指针，最小长度(初始值为一定不可达到的长度)</span>        <span class="token comment" spellcheck="true">//已有字符串中目标字符串指定字符的出现总频次以及最小覆盖子串在原字符串中的起始位置</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> min <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">char</span> r <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//说明该字符不被目标字符串需要，此时有两种情况</span>            <span class="token comment" spellcheck="true">// 1.循环刚开始，那么直接移动右指针即可，不需要做多余判断</span>            <span class="token comment" spellcheck="true">// 2.循环已经开始一段时间，此处又有两种情况</span>            <span class="token comment" spellcheck="true">//  2.1 上一次条件不满足，已有字符串指定字符出现次数不满足目标字符串指定字符出现次数，那么此时</span>            <span class="token comment" spellcheck="true">//      如果该字符还不被目标字符串需要，就不需要进行多余判断，右指针移动即可</span>            <span class="token comment" spellcheck="true">//  2.2 左指针已经移动完毕，那么此时就相当于循环刚开始，同理直接移动右指针</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>need<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//当且仅当已有字符串目标字符出现的次数小于目标字符串字符的出现次数时，count才会+1</span>            <span class="token comment" spellcheck="true">//是为了后续能直接判断已有字符串是否已经包含了目标字符串的所有字符，不需要挨个比对字符出现的次数</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>have<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&lt;</span> need<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//已有字符串中目标字符出现的次数+1</span>            have<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//移动右指针</span>            right<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//当且仅当已有字符串已经包含了所有目标字符串的字符，且出现频次一定大于或等于指定频次</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//挡窗口的长度比已有的最短值小时，更改最小值，并记录起始位置</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">&lt;</span> min<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    min <span class="token operator">=</span> right <span class="token operator">-</span> left<span class="token punctuation">;</span>                    start <span class="token operator">=</span> left<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">char</span> l <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//如果左边即将要去掉的字符不被目标字符串需要，那么不需要多余判断，直接可以移动左指针</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>need<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    left<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//如果左边即将要去掉的字符被目标字符串需要，且出现的频次正好等于指定频次，那么如果去掉了这个字符，</span>                <span class="token comment" spellcheck="true">//就不满足覆盖子串的条件，此时要破坏循环条件跳出循环，即控制目标字符串指定字符的出现总频次(count）-1</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>have<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> need<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    count<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//已有字符串中目标字符出现的次数-1</span>                have<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//移动左指针</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//如果最小长度还为初始值，说明没有符合条件的子串</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//返回的为以记录的起始位置为起点，记录的最短长度为距离的指定字符串中截取的子串</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> start <span class="token operator">+</span> min<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>决策单调性</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution {public:    string minWindow(string s, string t) {        unordered_map<char,int>hs,ht;//定义两个hash表，一个是hs一个是ht        for(auto count:t) ht[count]++;//对应的hash表里的字幕频数++        string res;  //定义最小字符串        int count=0; //相当于distance，保证        for(int left=0,right=0;right<s.size();right++){            hs[s[right]]++; //这个是对应的hash表的数字加加！！！！            if(hs[s[right]]<=ht[s[right]])             count++;//注意这里是先++然后再进行比较，所以可以有<=                //判断左边，让左边往右边移动            while(hs[s[left]]>ht[s[left]])                     {                         hs[s[left]]--;                         left++;  //左边向右移动一位                     }            if(count==t.size())//说明count此时已经包含了所有t里面的字母                     {                         if(res.empty()||right-left+1<res.size())                             //res.empty()表示的最开始的时候，需要直接运行一下。                             //right-left+1表示的是此时的覆盖子串。res.size()表示的是之前的覆盖子串。当此时的覆盖子串小于现在的覆盖子串长度时，用现在的覆盖子串来代替，因为它更小                             res=s.substr(left,right-left+1);                     }        }//只需要遍历一遍即可，因为指针都是严格单调递增的    return res;    }            };//作者：lin-shen-shi-jian-lu-k//链接：https://leetcode-cn.com/problems/minimum-window-substring/solution/leetcode-76-zui-xiao-fu-gai-zi-chuan-cja-lmqz/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>补充： 意思是将t容器中的每一个元素从前往后枚举出来，并用 count 来表示，类似于Java中的 for each 语句 </p><pre class="line-numbers language-c++"><code class="language-c++">int main(){    vector<int> nums = { 0,2,1,1,0,2 };    for(auto count:nums)    cout << count <<" "; //注意这里是count不是nums    system("pause");//输出为 0 2 1 1 0 2    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">minWindow</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> hs<span class="token punctuation">,</span> ht<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>auto count<span class="token operator">:</span> t<span class="token punctuation">)</span> ht<span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token punctuation">;</span>        string res<span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> right <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            hs<span class="token punctuation">[</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token punctuation">;</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span>hs<span class="token punctuation">[</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> ht<span class="token punctuation">[</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>             count <span class="token operator">++</span> <span class="token punctuation">;</span>              <span class="token keyword">while</span> <span class="token punctuation">(</span>hs<span class="token punctuation">[</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">></span> ht<span class="token punctuation">[</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>            hs<span class="token punctuation">[</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>            left<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                res <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>empty函数</p><pre class="line-numbers language-c++"><code class="language-c++">int main(){ vector<int> nums = { 0,2,1,1,0,2 };    if(nums.empty()) //判断是不是空，如果是空的话就运行，不是空的话就不运行    cout << "ture";    else cout <<"false";  //这个不是空，所以运行false    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="142，环形链表-2-mid"><a href="#142，环形链表-2-mid" class="headerlink" title="142，环形链表 2 mid"></a>142，环形链表 2 mid</h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p><p>第一眼思路，没有思路…图都看不懂</p><p>head=[1,6,4,7,2,5]</p><p>pos=1，说明该链表的链尾是返回head[]的一号元素，即head[1]。</p><p>如果是pos=0,说明返回0号元素，即head[0]。</p><pre class="line-numbers language-c++"><code class="language-c++">//哈希表遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。 看样子之后要系统地学习一下hash表了，用的太多太多了class Solution {public:    ListNode *detectCycle(ListNode *head) {        unordered_set<ListNode *> visited;        while (head != nullptr) {            if (visited.count(head)) {                return head;            }            visited.insert(head);            head = head->next;        }        return nullptr;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>快指针和慢指针：终于用到了一个我自己比较熟悉的了，方式也很简单,不过主要就考察数学公式了。其实这种题目自己模拟一下就能够发现了。</p><p>快慢指针相类似的题目还有：<strong>408出现过的</strong></p><p>求中位数；求倒数第n个数等等；</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509514.png" alt="1641458310365"></p><pre class="line-numbers language-c++"><code class="language-c++">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    ListNode *detectCycle(ListNode *head) {        ListNode* fast = head;        ListNode* slow = head;        //这里注意一下while的条件是fast和fast->next！=null        while(fast != NULL && fast->next != NULL) {            slow = slow->next;            fast = fast->next->next;            // 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇            if (slow == fast) {                ListNode* index1 = fast;                ListNode* index2 = head;                while (index1 != index2) {                    index1 = index1->next;                    index2 = index2->next;                }                return index2; // 返回环的入口            }        }        return NULL;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里提供一个更方便的题解</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509515.png" alt="1641457870892"></p><pre class="line-numbers language-c++"><code class="language-c++">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    ListNode *detectCycle(ListNode *head) {        ListNode *fast=head,*low=head;//定义两个指针类型 *表示是一个指针变量        while(fast!=NULL&&low!=NULL){            fast=fast->next->next;            low=low->next;            if(fast==low)            break;        }        if (fast==NULL||fast->next==NULL) //无环        return NULL;        ListNode *record=fast;         low=low->next;        int n=1;//用来记录这个环有多少个节点 这里应该要从1开始 之前已经走过一个点了。经过了一个next        while(low!=fast) {            n++;            low=low->next;        }        ListNode *fast2=head,*low2=head;  //再次从头开始读取        for(int i=0;i<n;i++)            fast2=fast2->next;        //这里注意其实不是求的倒数第n个节点而是n+1个，画一下图就出来了        while(fast2!=low2){            fast2=fast2->next;            low2=low2->next;        }        return low2;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="31，下一个队列"><a href="#31，下一个队列" class="headerlink" title="31，下一个队列"></a>31，下一个队列</h3><p>实现获取 <strong>下一个排列</strong> 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须<strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener"> 原地 </a></strong>修改，只允许使用额外常数空间。</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution {public:    void nextPermutation(vector<int>& nums) {        int i = nums.size() - 2;        while (i >= 0 && nums[i] >= nums[i + 1]) {            i--;        }//从右往左 找到第一个左小于右的数nums[i]        if (i >= 0) {            int j = nums.size() - 1;            while (j >= 0 && nums[i] >= nums[j]) {                j--;            }            swap(nums[i], nums[j]);        }//从右往左 找到第一个大于nums[i]的数 nums[j] 并进行交换        sort(nums.begin() + i + 1, nums.end());        //reverse(nums.begin() + i + 1, nums.end()); 这里无论是用reverse还是sort都是对的    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>考察的其实就是字典序，<a href="https://blog.csdn.net/qq_37050329/article/details/86637183" target="_blank" rel="noopener">https://blog.csdn.net/qq_37050329/article/details/86637183</a><br><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509516.png" alt="1641795661129"></p></blockquote><h3 id="38-剑指offer-字符串的排列"><a href="#38-剑指offer-字符串的排列" class="headerlink" title="38,剑指offer 字符串的排列"></a>38,剑指offer 字符串的排列</h3><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509517.png" alt="1641795973059"></p><p>这里比较难的一点在于两个，一个是全排列，直接输出，另外一个是去重，去重可以使用hash map来进行去重</p><blockquote><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509518.png" alt="1641796040727"></p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">//代码真漂亮，虽然回溯和递归我现在用的都不够熟练，之后再好好学吧class Solution {    //为了让递归函数添加结果方便，定义到函数之外，这样无需带到递归函数的参数列表中    List<String> list = new ArrayList<>();    //同；但是其赋值依赖c，定义声明分开    char[] c;    public String[] permutation(String s) {        c = s.toCharArray();        //从第一层开始递归        dfs(0);        //将字符串数组ArrayList转化为String类型数组        return list.toArray(new String[list.size()]);    }    private void dfs(int x) {        //当递归函数到达第三层，就返回，因为此时第二第三个位置已经发生了交换        if (x == c.length - 1) {            //将字符数组转换为字符串            list.add(String.valueOf(c));            return;        }        //为了防止同一层递归出现重复元素        HashSet<Character> set = new HashSet<>();        //这里就很巧妙了,第一层可以是a,b,c那么就有三种情况，这里i = x,正巧dfs(0)，正好i = 0开始        // 当第二层只有两种情况，dfs(1）i = 1开始        for (int i = x; i < c.length; i++){            //发生剪枝，当包含这个元素的时候，直接跳过            if (set.contains(c[i])){                continue;            }            set.add(c[i]);            //交换元素，这里很是巧妙，当在第二层dfs(1),x = 1,那么i = 1或者 2， 不是交换1和1，要就是交换1和2            swap(i,x);            //进入下一层递归            dfs(x + 1);            //返回时交换回来，这样保证到达第1层的时候，一直都是abc。这里捋顺一下，开始一直都是abc，那么第一位置总共就3个交换            //分别是a与a交换，这个就相当于 x = 0, i = 0;            //     a与b交换            x = 0, i = 1;            //     a与c交换            x = 0, i = 2;            //就相当于上图中开始的三条路径            //第一个元素固定后，每个引出两条路径,            //     b与b交换            x = 1, i = 1;            //     b与c交换            x = 1, i = 2;            //所以，结合上图，在每条路径上标注上i的值，就会非常容易好理解了            swap(i,x);        }    }    private void swap(int i, int x) {        char temp = c[i];        c[i] = c[x];        c[x] = temp;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>全排列+哈希表去重( 解题思路参考 46.全排列 )</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution {public:    vector<string> res;    vector<string> permutation(string s)     {        int n=s.size();        dfs(s,0,n);        unordered_map<string,int> hash;        for(int i=0;i<res.size();i++)        {            hash[res[i]]++;        }        res.clear();        for(auto it=hash.begin();it!=hash.end();it++)        {            res.emplace_back(it->first);        }        return res;    }    void dfs(string& s,int first,int n)    {        if(first==n)        {            res.emplace_back(s);            return ;        }        for(int i=first;i<n;i++)        {            swap(s[i],s[first]);            dfs(s,first+1,n);            swap(s[i],s[first]);        }    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="283，移动0"><a href="#283，移动0" class="headerlink" title="283，移动0"></a>283，移动0</h3><p> 给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序 </p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509519.png" alt="1641796326094"></p><p>这里提到了不能拷贝其他的数组，感觉空间复杂度只能为O(1),那么就不好用hash map之类的,感觉有点点像是双指针，但不好怎么去使用，</p><p>使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。</p><p>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</p><p>注意到以下性质：</p><p>左指针左边均为非零数；</p><p>右指针左边直到左指针处均为零。</p><p>因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。</p><pre class="line-numbers language-c++"><code class="language-c++">//左右指针class Solution {public:    void moveZeroes(vector<int>& nums) {        int n = nums.size(), left = 0, right = 0;        while (right < n) {            if (nums[right]) {                swap(nums[left], nums[right]); //这一部分画个图就知道了 0 1 0 3 12 5 6 相当于不断地让0往后面移动                left++;            }            right++;        }    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">//法二，这个其实就是有点类似于整个辅助数组或者说快慢指针之类的，r永远走的比l快，那么非0的数字都赋给nums[l]，l++，最后再让l之后的都变为0 一次遍历class Solution {public:    void moveZeroes(vector<int>& nums) {        int r=0,l=0,size=nums.size();        while (r<size)        {            if(nums[r])            {                nums[l++]=nums[r];            }            r++;        }       for(int i=l;i<size;i++) //注意这里的i=l不是i=l+1，原因是已经加过1了 在nums[l++]里面        nums[i]=0;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串 哈希表</title>
      <link href="/2021/02/23/zi-fu-chuan-ha-xi-biao/"/>
      <url>/2021/02/23/zi-fu-chuan-ha-xi-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h3 id="基本知识点"><a href="#基本知识点" class="headerlink" title="基本知识点"></a>基本知识点</h3><p>参考基础</p><p>总结一下，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p><p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">242. 有效的字母异位词</a></h3><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>因为要统计出现的次数，所以使用unordered_map统计key，然后 value,然后再两个map遍历比较，看看是否全部相等。</p><h4 id="两个哈希表-比较"><a href="#两个哈希表-比较" class="headerlink" title="两个哈希表 比较"></a>两个哈希表 比较</h4><pre><code>class Solution {public:    bool isAnagram(string s, string t) {        unordered_map&lt;char,int&gt; maps,mapt;        if(s.size()!=t.size())        return false;        for(int i=0;i&lt;s.size();i++)        {            maps[s[i]]++;            mapt[t[i]]++;//统计出现的次数        }        //遍历        for(auto p:maps)        {            if(p.second!=mapt[p.first])            return false;        }        return true;    }};</code></pre><h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">349. 两个数组的交集</a></h3><p> 给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的交集</em> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。 </p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251510795.png" alt="1643458699610"></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>哈希表</p><h4 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h4><pre><code>class Solution {public:    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        vector&lt;int&gt; res,num;        unordered_set&lt;int&gt; set1,set2;        for(auto p:nums1)        set1.insert(p);        for(auto p:nums2)        set2.insert(p); //用两个set实现去重        for(auto p:set1)        {            if(set2.find(p)!=set2.end())//没找到会返回end，找到了会返回对应的迭代器,不等于说明找到了            res.push_back(p);        }        return res;//这里也可以直接定义一个哈希表    }};</code></pre><h4 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h4><p>这里注意一下好像是直接把res转换为了vector<int>,这个技巧可以学一学，没必要再建一个容器了</int></p><pre><code>class Solution {public:    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        unordered_set&lt;int&gt; result_set; // 存放结果        unordered_set&lt;int&gt; nums_set(nums1.begin(), nums1.end());        for (int num : nums2) {            // 发现nums2的元素 在nums_set里又出现过            if (nums_set.find(num) != nums_set.end()) {                result_set.insert(num);            }        }        return vector&lt;int&gt;(result_set.begin(), result_set.end());//这一步挺不错的    }};</code></pre><h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a href="https://leetcode-cn.com/problems/happy-number/" target="_blank" rel="noopener">202. 快乐数</a></h3><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」 定义为：</p><p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。<br>如果这个过程 结果为 1，那么这个数就是快乐数。<br>如果 n 是 快乐数 就返回 true ；不是，则返回 false </p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251510796.png" alt="1643459096125"></p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>这道题目看上去貌似一道数学问题，其实并不是！</p><p>题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现，这对解题很重要！</strong></p><p>正如：<a href="https://programmercarl.com/哈希表理论基础.html" target="_blank" rel="noopener">关于哈希表，你该了解这些！ (opens new window)</a>中所说，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。</strong></p><p>所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</p><p>判断sum是否重复出现就可以使用unordered_set。</p><p><strong>还有一个难点就是求和的过程，如果对取数值各个位上的单数操作不熟悉的话，做这道题也会比较艰难。</strong></p><p> 所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。 </p><h4 id="哈希表-2"><a href="#哈希表-2" class="headerlink" title="哈希表"></a>哈希表</h4><pre><code>class Solution {public:    int getsum(int n)    {        int sum=0;        while(n)        {            sum += (n % 10) * (n % 10);            n /= 10;        }        return sum;    }    bool isHappy(int n) {        unordered_set&lt;int&gt; set;        while(1){            int sum=getsum(n);            if(sum==1)            return true;//这个要先运行            if(set.find(sum)!=set.end())//说明sum重复出现了，陷入了死循环            return false;            else  set.insert(sum);            n=sum;        }    }};</code></pre><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></h3><p>梦开始的地方</p><pre><code>class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        unordered_map&lt;int,int&gt; map;        int size=nums.size();        for(int i=0;i&lt;size;i++)        {            if(map.find(target-nums[i])==map.end())//9-2=7 如果7没有找到的话            map[nums[i]]=i;//key是对应的值，value是对应的下标            else             return {i,map[target-nums[i]]};        }        return{};    }};</code></pre><h3 id="454-四数相加-II-mid"><a href="#454-四数相加-II-mid" class="headerlink" title="454. 四数相加 II(mid)"></a><a href="https://leetcode-cn.com/problems/4sum-ii/" target="_blank" rel="noopener">454. 四数相加 II</a>(mid)</h3><p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p><p>0 &lt;= i, j, k, l &lt; n<br>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>暴力破解</p><p>哈希表：其实有点像是两数之和，只不过是把target变成了0，把四数之和变成了两个（两数）之和</p><ol><li>首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。</li><li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。</li><li>定义int变量count，用来统计 a+b+c+d = 0 出现的次数。</li><li>在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</li><li>最后返回统计值 count 就可以了</li></ol><h4 id="哈希表-3"><a href="#哈希表-3" class="headerlink" title="哈希表"></a>哈希表</h4><pre><code>class Solution {public:    int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) {        unordered_map&lt;int,int&gt;map;        for(auto i:nums1)            for(auto j:nums2)            map[i+j]++;//i+j的key代表ab两数之和 value 代表        int count=0;        for(auto i:nums3)            for(auto j:nums4)            if(map.find(0-(i+j))!=map.end())//说明找到了            count+=map[0-(i+j)];        return count;     }};</code></pre><h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a><a href="https://leetcode-cn.com/problems/ransom-note/" target="_blank" rel="noopener">383. 赎金信</a></h3><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p><p>如果可以，返回 true ；否则返回 false 。</p><p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>构造哈希表，找得到且value&gt;0的时候就return true 否则return false</p><h4 id="哈希表-4"><a href="#哈希表-4" class="headerlink" title="哈希表"></a>哈希表</h4><p>不难</p><pre><code>class Solution {public:    bool canConstruct(string ransomNote, string magazine) {        unordered_map&lt;char,int&gt;map;        for(auto c:magazine)        {            map[c]++;        }        for(auto c:ransomNote)        {            if(map.find(c)==map.end()||map[c]==0)            return false;            else            map[c]--;        }        return true;    }};</code></pre><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>涉及到单个数字或者单个字母的时候用数组的时间空间复杂度都会更好一点， <strong>因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！</strong> ，但如果是涉及到<strong>字符串，或者多个数字</strong>比如说92,322，这种的话那还是建议使用哈希表</p><pre><code>// 时间复杂度: O(n)// 空间复杂度：O(1)class Solution {public:    bool canConstruct(string ransomNote, string magazine) {        int record[26] = {0};        for (int i = 0; i &lt; magazine.length(); i++) {            // 通过recode数据记录 magazine里各个字符出现次数            record[magazine[i]-&#39;a&#39;] ++;        }        for (int j = 0; j &lt; ransomNote.length(); j++) {            // 遍历ransomNote，在record里对应的字符个数做--操作            record[ransomNote[j]-&#39;a&#39;]--;            // 如果小于零说明ransomNote里出现的字符，magazine没有            if(record[ransomNote[j]-&#39;a&#39;] &lt; 0) {                return false;            }        }        return true;    }};</code></pre><pre><code>class Solution {public:    bool canConstruct(string ransomNote, string magazine) {        int num[26]={0};        for(auto c:magazine)        {            num[c-&#39;a&#39;]++;        }        for(auto c:ransomNote)        {            num[c-&#39;a&#39;]--;            if(num[c-&#39;a&#39;]&lt;0)            return false;        }        return true;    }};//auto 还是快啊</code></pre><h3 id="15-三数之和-mid"><a href="#15-三数之和-mid" class="headerlink" title="15. 三数之和(mid)"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a>(mid)</h3><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p><p>0 &lt;= a, b, c, d &lt; n<br>a、b、c 和 d 互不相同<br>nums[a] + nums[b] + nums[c] + nums[d] == target<br>你可以按 任意顺序 返回答案 </p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><h4 id="哈希表法"><a href="#哈希表法" class="headerlink" title="哈希表法"></a>哈希表法</h4><p>这道题目如果是用哈希表的话里面注意的细节会比较多所以其实更加建议使用双指针法去做。</p><pre><code>class Solution {public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {        vector&lt;vector&lt;int&gt;&gt; result;        sort(nums.begin(), nums.end());        // 找出a + b + c = 0        // a = nums[i], b = nums[j], c = -(a + b)        for (int i = 0; i &lt; nums.size(); i++) {            // 排序之后如果第一个元素已经大于零，那么不可能凑成三元组            if (nums[i] &gt; 0) {                break;            }            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) { //三元组元素a去重                continue;            }            unordered_set&lt;int&gt; set;            for (int j = i + 1; j &lt; nums.size(); j++) {                if (j &gt; i + 2                        &amp;&amp; nums[j] == nums[j-1]                        &amp;&amp; nums[j-1] == nums[j-2]) { // 三元组元素b去重                    continue;                }                int c = 0 - (nums[i] + nums[j]);                if (set.find(c) != set.end()) {                    result.push_back({nums[i], nums[j], c});                    set.erase(c);// 三元组元素c去重                } else {                    set.insert(nums[j]);                }            }        }        return result;    }};</code></pre><p> <strong>双指针法将时间复杂度：$O(n^2)$的解法优化为 $O(n)$的解法。也就是降一个数量级，题目如下：</strong> </p><ul><li><a href="https://programmercarl.com/0027.移除元素.html" target="_blank" rel="noopener">27.移除元素(opens new window)</a></li><li><a href="https://programmercarl.com/0015.三数之和.html" target="_blank" rel="noopener">15.三数之和(opens new window)</a></li><li><a href="https://programmercarl.com/0018.四数之和.html" target="_blank" rel="noopener">18.四数之和(opens new window)</a></li></ul><p>操作链表：</p><ul><li><a href="https://programmercarl.com/0206.翻转链表.html" target="_blank" rel="noopener">206.反转链表(opens new window)</a></li><li><a href="https://programmercarl.com/0019.删除链表的倒数第N个节点.html" target="_blank" rel="noopener">19.删除链表的倒数第N个节点(opens new window)</a></li><li><a href="https://programmercarl.com/面试题02.07.链表相交.html" target="_blank" rel="noopener">面试题 02.07. 链表相交(opens new window)</a></li><li><a href="https://programmercarl.com/0142.环形链表II.html" target="_blank" rel="noopener">142题.环形链表II</a></li></ul><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">344. 反转字符串</a></h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>class Solution {public:    void reverseString(vector&lt;char&gt;&amp; s) {        for(int i=0;i&lt;s.size()/2;i++)        {            swap(s[i],s[s.size()-i-1]);        }    }};</code></pre><h3 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a><a href="https://leetcode-cn.com/problems/reverse-string-ii/" target="_blank" rel="noopener">541. 反转字符串 II</a></h3><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>s<strong>wap部分没有处理好 导致花了很多不必要的时间</strong>，这里其实是没有整清楚里面到底是谁和谁换 其实是s[left+i]和s[left+k-1-i]去进行替换</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code>class Solution {public:    string reverse(string &amp;s,int k,int left)    {        int right=s.length();//右边界        if(right&lt;left) return nullptr;        //剩余字符大于2k个        while(right-left&gt;=2*k)        {            for(int i=0;i&lt;k/2;i++)            {                swap(s[left+i],s[left+k-1-i]);            }            left=left+2*k;        }        if(right-left&lt;2*k&amp;&amp;right-left&gt;=k) //剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。                {                     for(int i=0;i&lt;k/2;i++)                    {                        swap(s[left+i],s[left+k-1-i]);                    }                    return s;                }        //剩余字符小于k个全部翻转        if(right-left&lt;k)        {            for(int i=left;i&lt;(right+left)/2;i++)            swap(s[i],s[right+left-i-1]);            return s;        }        return s;    }    string reverseStr(string s, int k) {        return reverse(s,k,0);    }};</code></pre><pre><code>// 反转字符串s中左闭又闭的区间[start, end]void reverse(string&amp; s, int start, int end) {    for (int i = start, j = end; i &lt; j; i++, j--) {        swap(s[i], s[j]);    }}//这一部分的代码真的很惊艳，太妙了</code></pre><h4 id="代码随想录-1"><a href="#代码随想录-1" class="headerlink" title="代码随想录"></a>代码随想录</h4><pre><code>class Solution {public:    void reverse(string&amp; s, int start, int end) {        for (int i = start, j = end; i &lt; j; i++, j--) {            swap(s[i], s[j]);        }    }    string reverseStr(string s, int k) {        for (int i = 0; i &lt; s.size(); i += (2 * k)) {            // 1. 每隔 2k 个字符的前 k 个字符进行反转            // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符            if (i + k &lt;= s.size()) {                reverse(s, i, i + k - 1);                continue;            }            // 3. 剩余字符少于 k 个，则将剩余字符全部反转。            reverse(s, i, s.size() - 1);        }        return s;    }};</code></pre><h3 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">剑指 Offer 05. 替换空格</a></h3><p> 请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。 </p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre><code>class Solution {public:    string replaceSpace(string s) {        //先计算有多少个空格        int length=s.length();        int num=0;        string res;        for(int i=0;i&lt;length;i++)        {            if(s[i]==&#39; &#39;)            {                 res.push_back(&#39;%&#39;);                res.push_back(&#39;2&#39;);                 res.push_back(&#39;0&#39;);            }            else             res.push_back(s[i]);        }        return res;    }};</code></pre><h4 id="双指针法-之后自己写一下"><a href="#双指针法-之后自己写一下" class="headerlink" title="双指针法(之后自己写一下)"></a><strong>双指针法</strong>(之后自己写一下)</h4><p>从后往前 代码随想录</p><pre><code>class Solution {public:    string replaceSpace(string s) {        int count = 0; // 统计空格的个数        int sOldSize = s.size();        for (int i = 0; i &lt; s.size(); i++) {            if (s[i] == &#39; &#39;) {                count++;            }        }        // 扩充字符串s的大小，也就是每个空格替换成&quot;%20&quot;之后的大小        s.resize(s.size() + count * 2);        int sNewSize = s.size();        // 从后先前将空格替换为&quot;%20&quot;        for (int i = sNewSize - 1, j = sOldSize - 1; j &lt; i; i--, j--) {            if (s[j] != &#39; &#39;) {                s[i] = s[j];            } else {                s[i] = &#39;0&#39;;                s[i - 1] = &#39;2&#39;;                s[i - 2] = &#39;%&#39;;                i -= 2;            }        }        return s;    }};</code></pre><h3 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151. 翻转字符串里的单词"></a><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">151. 翻转字符串里的单词</a></h3><p>给你一个字符串 s ，逐个翻转字符串中的所有 单词 。</p><p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p><p>请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。</p><p>说明：</p><p>输入字符串 s 可以在前面、后面或者单词间包含多余的空格。<br>翻转后单词间应当仅用一个空格分隔。<br>翻转后的字符串中不应包含额外的空格。</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251510798.png" alt="1643517247673"></p><h4 id="低效思路"><a href="#低效思路" class="headerlink" title="低效思路"></a>低效思路</h4><p>开容器：建立一个vector<string> strl;先存储单词进去，然后再逆序输出并增加’ ‘(空格)，不时间复杂度O（2n） 空间复杂度O（n），其实还是比较高了，方法比较简陋。</string></p><p>感觉应该可以用双指针去做，这样的话应该<strong>空间复杂度只要O（1）</strong></p><pre><code>class Solution {public:    string reverseWords(string s) {        vector&lt;string&gt; str;        string res;        int num=0;        s=&#39; &#39;+s; //第一个做特殊处理，直接前面加个空格        //将单词都存储到vector中        for(int i=1;i&lt;s.size();i++)        {            if(s[i]==&#39; &#39;)            continue;            if(s[i-1]==&#39; &#39;)//前面一个有空格,且自己不是空格，说明这是一个新单词                    {                        str.push_back(&quot;&quot;);                        num++;                    }            str[num-1]+=s[i];        }        //翻转        for(int i=str.size()-1;i&gt;0;i--)        {            res=res+str[i]+&#39; &#39;;        }                    res=res+str[0];        return res;    }};</code></pre><h4 id="高效翻转"><a href="#高效翻转" class="headerlink" title="高效翻转"></a>高效翻转</h4><p> 1，消除多余空格（前面的空格、中间多余的空格、后面的空格）。 </p><p>2，将整个字符串翻转，reverse</p><p>3，<strong>依次将单词翻转，这个是最关键的</strong></p><blockquote><p>前面很多大佬都总结了，无非只有三步：</p><p>消除多余空格（前面的空格、中间多余的空格、后面的空格）。<br>本题解使用快慢指针，也可以使用erase，快慢指针的思路是参@carlsun-2<br>快慢指针的具体解释：fast用于向前遍历字符串，slow用于记录我们最终想要的字符串。依次去除前面的空格、中间多余的空格、后面的空格。去除中间多余空格的代码让最后只有两种情况：最后一个字符是空格（倒数第二个字符不是空格）和最后一个字符也不是空格。据此写出消除末尾空格的代码。<br>将整个字符串翻转。本题解写了一个翻转函数，也可以用reverse<br>利用首尾指针<br>依次将每个单词翻转。<br>用i去遍历字符串，当遇到空格时，说明前面是一个单词，将前面的单词翻转。<br>i到末尾时没有空格，但是最后一个单词还没有被翻转，所以翻转一下最后一个单词</p></blockquote><pre><code>class Solution {public:    //反转字符串    void reverse(string&amp; s,int start,int end){        while(start&lt;end){            swap(s[start++],s[end--]);        }    }    //移除多余空格，利用快慢指针    void removeExtraSpaces(string&amp;s){        int slow=0,fast=0;        //移除开始位置的空格        while(s[fast]==&#39; &#39;){            fast++;        }        //移除中间位置多余的空格        while(fast&lt;s.size()){            if(fast&gt;0 &amp;&amp; s[fast]==&#39; &#39; &amp;&amp;s[fast-1]==&#39; &#39;){                fast++;            }            else{                s[slow]=s[fast];                slow++;                fast++;            }        }        //如果末尾仅有一个空格，则上述无法将该空格移除；如果末尾有很多空格，则上述将保留一个空格，也不符合要求；所以最终可能的情况有二：末尾有一个空格/末尾无空格         if(slow-1&gt;0 &amp;&amp; s[slow-1]==&#39; &#39;){            slow--;        }        s.resize(slow);    }    string reverseWords(string s) {        //step1.移除多余空格        removeExtraSpaces(s);        //step2.反转整个字符串        reverse(s,0,s.size()-1);        //step3.依次反转每个单词        int start=0;        for(int i=0;i&lt;s.size();i++){            if(s[i]==&#39; &#39;){                reverse(s,start,i-1);                start=i+1;            }            //最后一个单词后面不是空格，所以需要单独考虑            if(i==s.size()-1){                reverse(s,start,i);            }        }        return s;    }};作者：xiao-bo-bian-huan链接：https://leetcode-cn.com/problems/reverse-words-in-a-string/solution/kong-jian-fu-za-du-o1-c-zhu-shi-xiang-xi-biaw/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre><h3 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 58 - II. 左旋转字符串</a></h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><ol><li>反转区间为前n的子串</li><li>反转区间为n到末尾的子串</li><li>反转整个字符串</li></ol><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><pre><code>class Solution {public:    string reverseLeftWords(string s, int n) {        reverse(s.begin(),s.begin()+n);//如果n=2，那么表示的是前面两个 而不是前面三个        reverse(s.begin()+n,s.end());//这个表示的是第三个开始，要注意一下        reverse(s.begin(),s.end());        return s;    }};</code></pre><h3 id="28-实现-strStr-KMP"><a href="#28-实现-strStr-KMP" class="headerlink" title="28. 实现 strStr() KMP"></a><strong><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">28. 实现 strStr()</a> KMP</strong></h3><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p><p><strong>现在还掌握不是很好，之后有时间再好好学学</strong></p><p>主要用于字符串匹配的相关问题</p><h4 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h4><pre><code>class Solution {public:    void getNext(int* next, const string&amp; s) {        int j = -1;        next[0] = j;        for(int i = 1; i &lt; s.size(); i++) { // 注意i从1开始            while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) { // 前后缀不相同了                j = next[j]; // 向前回退            }            if (s[i] == s[j + 1]) { // 找到相同的前后缀                j++;            }            next[i] = j; // 将j（前缀的长度）赋给next[i]        }    }    int strStr(string haystack, string needle) {        if (needle.size() == 0) {            return 0;        }        int next[needle.size()];        getNext(next, needle);        int j = -1; // // 因为next数组里记录的起始位置为-1        for (int i = 0; i &lt; haystack.size(); i++) { // 注意i就从0开始            while(j &gt;= 0 &amp;&amp; haystack[i] != needle[j + 1]) { // 不匹配                j = next[j]; // j 寻找之前匹配的位置            }            if (haystack[i] == needle[j + 1]) { // 匹配，j和i同时向后移动                j++; // i的增加在for循环里            }            if (j == (needle.size() - 1) ) { // 文本串s里出现了模式串t                return (i - needle.size() + 1);            }        }        return -1;    }};</code></pre><h3 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/" target="_blank" rel="noopener">459. 重复的子字符串</a></h3><p> 给定一个非空的字符串 <code>s</code> ，检查是否可以通过由它的一个子串重复多次构成。 </p><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p><strong>数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</strong></p><p><strong>强烈建议大家把next数组打印出来，看看next数组里的规律，有助于理解KMP算法</strong></p><h4 id="KMP-1"><a href="#KMP-1" class="headerlink" title="KMP"></a>KMP</h4><pre><code>class Solution {public:    void getNext (int* next, const string&amp; s){        next[0] = -1;        int j = -1;        for(int i = 1;i &lt; s.size(); i++){            while(j &gt;= 0 &amp;&amp; s[i] != s[j+1]) {                j = next[j];            }            if(s[i] == s[j+1]) {                j++;            }            next[i] = j;        }    }    bool repeatedSubstringPattern (string s) {        if (s.size() == 0) {            return false;        }        int next[s.size()];        getNext(next, s);        int len = s.size();        if (next[len - 1] != -1 &amp;&amp; len % (len - (next[len - 1] + 1)) == 0) {            return true;        }        return false;    }};</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网公式总结</title>
      <link href="/2020/01/14/2021-11-29-ji-wang-gong-shi-zong-jie-144013/"/>
      <url>/2020/01/14/2021-11-29-ji-wang-gong-shi-zong-jie-144013/</url>
      
        <content type="html"><![CDATA[<h3 id="奈奎斯特定理"><a href="#奈奎斯特定理" class="headerlink" title="奈奎斯特定理"></a>奈奎斯特定理</h3><p>$$<br>理想低通道下的极限数据传输率=2W\log_2V<br>$$</p><h3 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h3><p>$$<br>信道的极限数据传输率=Wlog_2(1+S/N) (单位为b/s)<br>$$</p><p>W：信道的带宽。 S：信道所传输信号的平均功率。 S/N：信噪比 </p><p>信噪比=10log10(S/N) 当S/N=1000时，信噪比为30dB</p><h3 id="比特率和波特率的转换关系"><a href="#比特率和波特率的转换关系" class="headerlink" title="比特率和波特率的转换关系"></a>比特率和波特率的转换关系</h3><p>$$<br>比特率=波特率*log_2n<br>$$</p><p>一个码元含有n个比特的信息量。</p><p>P43 采用8种相位，每种相位各有两种幅度的QAM调制方法，在1200Baud的信号传输速率能为 4800b/s。</p><blockquote><p>$log_216=4<br>$ </p><p>$数据传输率=1200*4=4800b/s$</p></blockquote><h2 id="计网的基本指标："><a href="#计网的基本指标：" class="headerlink" title="计网的基本指标："></a>计网的基本指标：</h2><ul><li><p>带宽：单位是b/s</p></li><li><p>时延</p><p>$整个传输过程的总时延=发送时延+传播时延+（处理时延+传播时延 （后面两个一般忽略不计））$</p><p>$发送时延=分组帧长/信道宽度$</p><p>$传播时延=信道长度/传播速率$</p><p><strong>ps:信号的传播速率是信号在信道上传播的速率，与信道的发送速率无关。</strong><br><strong>信道表示为端对端的距离，一般单位为km。传播速率单位一般为km/s</strong></p><p><strong>信道的数据发送/数据传输速率一般为Mb/s</strong></p></li><li><p>往返时延RTT<br>这个地方经常有坑，会说单向的传播时间为，需要注意。</p><p>$RTT=2*端与端的距离/传播速度$ </p></li><li><p>吞吐量。指单位的时间内通过某个网络的数据量.<br>$$<br>吞吐量=\frac{有效数据}{发送周期}<br>$$</p></li><li><p>信道利用率：指在整个过程中有多少数据是通过的。即</p><p>$信道利用率=(L/C)/T $ </p><p>L:表示T内发送L比特的数据    C：表示发送方数据传输率<br>T：发送周期，指从开始发送数据，到收到第一个确认帧数为止</p></li></ul><ul><li>最小帧长度=数据传输速率*RTT，这里还需要注意一点最小帧长度一般是用B(字节)表示，而数据传输速率往往是用b（比特来表示），转换时别忘记$\times$8</li></ul><h2 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h2><p>​    $发送窗口+接收窗口\leq2^n$</p><ol><li>停等协议：发送窗口=1，接受窗口=1</li><li>后退N帧协议：发送窗口&gt;1,接收窗口=1</li><li>选择重传协议：发送窗口&gt;1,接收窗口&gt;1。一般取发送窗口=接收窗口=$2^{n-1}$ </li></ol><h3 id="停等协议例题："><a href="#停等协议例题：" class="headerlink" title="停等协议例题："></a><strong>停等协议例题：</strong></h3><p>​    一个信道的传播速率为4kb/s，单向传播时延为30ms，如果使停等协议的信道利用率达到80%，要求的数据帧长至少为（）</p><blockquote><p>解析：<br>$$<br>80%=\frac{L/4}{L/4+RTT}=\frac{L/4}{L/4+2*30ms}<br>$$<br>解得 L=960bit</p></blockquote><h3 id="GBN例题"><a href="#GBN例题" class="headerlink" title="GBN例题"></a><strong>GBN例题</strong></h3><p><img src="C:%5CUsers%5C%E6%9D%8E%E7%AB%A0%E6%9D%B0%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211128192022881.png" alt="image-20211128192022881"></p><blockquote><p>解析：</p><p>捎带确认：不需要考虑传输时延，只需要考虑传播时延</p><p>最大传输率需要考虑信道带宽和GBN协议，</p><p>最大传输率=min{信道带宽，根据GBN协议算得的传输率}</p><p>信道带宽=100Mb/s</p><p>GBN：</p><p>甲的发送窗口尺寸为1000，即最多可发1000*1000B=1MB</p><p>$$<br>最大传输率=\frac{1MB}{1000B/100MB+50ms+50ms}=80Mb/s<br>$$<br>则选取最小的为80Mb/s</p></blockquote><p><strong>ch3 3.4.5</strong><br><img src="C:%5CUsers%5C%E6%9D%8E%E7%AB%A0%E6%9D%B0%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211128192940513.png" alt="image-20211128192940513"></p><blockquote><p>解析：</p><p><strong>停等协议</strong><br>    发一帧，都要应答。需要考虑接收端的传输时延<br>$$<br>最大利用率=\frac{传播长度/数据传输率}{2<em>单向传播时延+2</em>传播长度/数据传输率}<br>\=\frac{1k/50k}{2<em>270+2</em>1k/50k}\=\frac{0.02}{0.58}=3.4%<br>$$<br><strong>GBN</strong></p><p>发送窗口满足$1&lt;W\leq2^n-1$  则有发送窗口为7，则有在第一帧的数据传输周几内，总共发送了7帧数<br>$$<br>最大利用率=\frac{7<em>传播长度/数据传输率}{2</em>单向传播时延+2<em>传播长度/数据传输率}\=7</em>3.4%<br>$$</p><h3 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a><strong>选择重传</strong></h3><p>发送窗口=接收窗口=$2^{n-1}=4$<br>$$<br>最大利用率=4*3.4%=13.8%<br>$$</p></blockquote><p>[2017真题]<img src="C:%5CUsers%5C%E6%9D%8E%E7%AB%A0%E6%9D%B0%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211128195043044.png" alt="image-20211128195043044"></p><p><img src="C:%5CUsers%5C%E6%9D%8E%E7%AB%A0%E6%9D%B0%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211128195058752.png" alt="image-20211128195058752"></p><blockquote><p>解析：</p><p>确认序号和发送序号均为3bit，捎带确认，由GBN协议得，发送窗口为$2^{n}-1=7$<br>$$<br>最大信道利用率=\frac{7<em>单帧发送时延}{单帧发送时延+传播时延}\=\frac{7</em>8<em>1000b/100Mb/s}{0.96</em>10^{-3}+2<em>8</em>1000b/100Mb}\=50%<br>$$<br><strong>很经典的题目</strong></p></blockquote><p><strong>距离变化</strong></p><p><img src="C:%5CUsers%5C%E6%9D%8E%E7%AB%A0%E6%9D%B0%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211128200615636.png" alt="image-20211128200615636"></p><blockquote><p>$$<br>最小帧长度=数据传输速率<em>RTT =数据传输速度</em>2*端与端的距离/传播速度<br>$$</p><p>$$<br>\Delta l=数据传输速度<em>2</em>\Delta s/传播速度=80m<br>$$</p><p>最小帧长度和距离是成正比的关系，只要把公式写清楚就很容易得到答案为D选项。</p><p>补充：<strong>以太网最小数据帧为64B，数据长度为46-1500B，即IP数据报小于46B时需要填充</strong></p><p>详见【2012年真题】<img src="C:%5CUsers%5C%E6%9D%8E%E7%AB%A0%E6%9D%B0%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211129140255618.png" alt="image-20211129140255618"><br>最后是3,5号分组总长度为40（28H)字节小于46字节，说明需要填充</p></blockquote><h3 id="吞吐率-吞吐量"><a href="#吞吐率-吞吐量" class="headerlink" title="吞吐率/吞吐量"></a>吞吐率/吞吐量</h3><p>P82 <img src="C:%5CUsers%5C%E6%9D%8E%E7%AB%A0%E6%9D%B0%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211129142220989.png" alt="image-20211129142220989"></p><blockquote><p>一个发送周期的时间为$512B<em>8/(64kb/s)+2</em>270ms=0.604s$ </p><p>吞吐量/吞吐率&lt;=数据发送速率</p><ul><li>发送窗口尺寸为1时，吞吐率为1x512Bx8/0.604s=6.8kb/s </li><li>发送窗口尺寸为7时，吞吐率为7x512Bx8/0.604s=47.56kb/s</li><li>发送窗口尺寸为17时，<strong>注意</strong>当发送窗口大于0.604/0.064即$\geq$10,发送窗口能保证连续发送，此时吞吐率=64kb/s</li></ul></blockquote><p>P234</p><p><img src="C:%5CUsers%5C%E6%9D%8E%E7%AB%A0%E6%9D%B0%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211129143809736.png" alt="image-20211129143809736"></p><blockquote><p>这里提到了带宽，需要注意吞吐量$\leq$带宽。</p><p>RTT=40ms 则<br>$$<br>吞吐率=<br>$$</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my first blog</title>
      <link href="/2019/11/02/my-first-blog/"/>
      <url>/2019/11/02/my-first-blog/</url>
      
        <content type="html"><![CDATA[<p>关于自己的第一个blog 有点简单 希望从此之后能够好好地经营能够写点东西</p><h3 id="felling"><a href="#felling" class="headerlink" title="felling"></a>felling</h3><p>  难但是挺有用的，以后应该能从中做点东西</p><h3 id="gaining"><a href="#gaining" class="headerlink" title="gaining"></a>gaining</h3><p>  比我想象中要难一点，不过也还行，学会了用B站建blog</p>]]></content>
      
      
      
        <tags>
            
            <tag> feelings </tag>
            
            <tag> gaining </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公式总结</title>
      <link href="/2019/11/02/gong-shi-zong-jie/"/>
      <url>/2019/11/02/gong-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h3 id="奈奎斯特定理"><a href="#奈奎斯特定理" class="headerlink" title="奈奎斯特定理"></a>奈奎斯特定理</h3><p>$$<br>理想低通道下的极限数据传输率=2W\log_2V<br>$$</p><h3 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h3><p>$$<br>信道的极限数据传输率=Wlog_2(1+S/N) (单位为b/s)<br>$$</p><p>W：信道的带宽。 S：信道所传输信号的平均功率。 S/N：信噪比 </p><p>信噪比=10log10(S/N) 当S/N=1000时，信噪比为30dB</p><h3 id="比特率和波特率的转换关系"><a href="#比特率和波特率的转换关系" class="headerlink" title="比特率和波特率的转换关系"></a>比特率和波特率的转换关系</h3><p>$$<br>比特率=波特率*log_2n<br>$$</p><p>一个码元含有n个比特的信息量。</p><p>P43 采用8种相位，每种相位各有两种幅度的QAM调制方法，在1200Baud的信号传输速率能为 4800b/s。</p><blockquote><p>$log_216=4<br>$ </p><p>$数据传输率=1200*4=4800b/s$</p></blockquote><h3 id="计网的基本指标："><a href="#计网的基本指标：" class="headerlink" title="计网的基本指标："></a>计网的基本指标：</h3><ul><li><p>带宽：单位是b/s<br>带宽=数据传输速率*宽带。（宽带：n位）</p></li><li><p>时延</p><p>$整个传输过程的总时延=发送时延+传播时延+（处理时延+传播时延 （后面两个一般忽略不计））$</p><p>$发送时延=分组帧长/信道宽度$</p><p>$传播时延=信道长度/传播速率$</p><p><strong>ps:信号的传播速率是信号在信道上传播的速率，与信道的发送速率无关。</strong><br><strong>信道表示为端对端的距离，一般单位为km。传播速率单位一般为km/s</strong></p><p><strong>信道的数据发送/数据传输速率一般为Mb/s</strong></p></li><li><p>往返时延RTT<br>这个地方经常有坑，会说单向的传播时间为，需要注意。</p><p>$RTT=2*端与端的距离/传播速度$ </p></li><li><p>吞吐量。指单位的时间内通过某个网络的数据量.<br>$$<br>吞吐量=\frac{有效数据}{发送周期}<br>$$</p></li><li><p>信道利用率：指在整个过程中有多少数据是通过的。即</p><p>$信道利用率=(L/C)/T $ </p><p>L:表示T内发送L比特的数据    C：表示发送方数据传输率<br>T：发送周期，指从开始发送数据，到收到第一个确认帧数为止</p></li></ul><ul><li>最小帧长度=数据传输速率*RTT，这里还需要注意一点最小帧长度一般是用B(字节)表示，而数据传输速率往往是用b（比特来表示），转换时别忘记$\times$8</li><li>直通交换方式只检查帧的目的地址 6B</li></ul><h3 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h3><p>​    $发送窗口+接收窗口\leq2^n$ 滑动窗口的作用是进行流量控制</p><ol><li>停等协议：发送窗口=1，接受窗口=1</li><li>后退N帧协议：发送窗口&gt;1,接收窗口=1</li><li>选择重传协议：发送窗口&gt;1,接收窗口&gt;1。一般取发送窗口=接收窗口=$2^{n-1}$ </li></ol><h3 id="停等协议例题："><a href="#停等协议例题：" class="headerlink" title="停等协议例题："></a><strong>停等协议例题：</strong></h3><p>​    一个信道的传播速率为4kb/s，单向传播时延为30ms，如果使停等协议的信道利用率达到80%，要求的数据帧长至少为（）</p><blockquote><p>解析：<br>$$<br>80%=\frac{L/4}{L/4+RTT}=\frac{L/4}{L/4+2*30ms}<br>$$<br>解得 L=960bit</p></blockquote><h3 id="GBN例题"><a href="#GBN例题" class="headerlink" title="GBN例题"></a><strong>GBN例题</strong></h3><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512296.png" alt="image-20211128192022881"></p><blockquote><p>解析：</p><p>捎带确认：不需要考虑传输时延，只需要考虑传播时延</p><p>最大传输率需要考虑信道带宽和GBN协议，</p><p>最大传输率=min{信道带宽，根据GBN协议算得的传输率}</p><p>信道带宽=100Mb/s</p><p>GBN：</p><p>甲的发送窗口尺寸为1000，即最多可发1000*1000B=1MB</p><p>$$<br>最大传输率=\frac{1MB}{1000B/100MB+50ms+50ms}=80Mb/s<br>$$<br>则选取最小的为80Mb/s</p></blockquote><p><strong>ch3 3.4.5</strong><br><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512297.png" alt="image-20211128192940513"></p><blockquote><p>解析：</p><p><strong>停等协议</strong><br>    发一帧，都要应答。需要考虑接收端的传输时延<br>$$<br>最大利用率=\frac{传播长度/数据传输率}{2<em>单向传播时延+2</em>传播长度/数据传输率}<br>\=\frac{1k/50k}{2<em>270+2</em>1k/50k}\=\frac{0.02}{0.58}=3.4%<br>$$<br><strong>GBN</strong></p><p>发送窗口满足$1&lt;W\leq2^n-1$  则有发送窗口为7，则有在第一帧的数据传输周几内，总共发送了7帧数<br>$$<br>最大利用率=\frac{7<em>传播长度/数据传输率}{2</em>单向传播时延+2<em>传播长度/数据传输率}\=7</em>3.4%<br>$$</p></blockquote><h3 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a><strong>选择重传</strong></h3><p>发送窗口=接收窗口=$2^{n-1}=4$<br>$$<br>最大利用率=4*3.4%=13.8%<br>$$</p><p>[2017真题]<img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512298.png" alt="image-20211128195043044"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512299.png" alt="image-20211128195058752"></p><blockquote><p>解析：</p><p>确认序号和发送序号均为3bit，捎带确认，由GBN协议得，发送窗口为$2^{n}-1=7$<br>$$<br>最大信道利用率=\frac{7<em>单帧发送时延}{单帧发送时延+传播时延}\=\frac{7</em>8<em>1000b/100Mb/s}{0.96</em>10^{-3}+2<em>8</em>1000b/100Mb}\=50%<br>$$<br><strong>很经典的题目</strong></p></blockquote><h3 id="距离变化"><a href="#距离变化" class="headerlink" title="距离变化"></a><strong>距离变化</strong></h3><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512300.png" alt="image-20211128200615636"></p><blockquote><p>$$<br>最小帧长度=数据传输速率<em>RTT =数据传输速度</em>2*端与端的距离/传播速度<br>$$</p><p>$$<br>\Delta l=数据传输速度<em>2</em>\Delta s/传播速度=80m<br>$$</p><p>最小帧长度和距离是成正比的关系，只要把公式写清楚就很容易得到答案为D选项。</p><blockquote><p>补充：<strong>以太网最小数据帧为64B，数据长度为46-1500B，即IP数据报小于46B时需要填充</strong>详见【2012年真题】<img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512302.png" alt="image-20211129140255618"><br>最后是3,5号分组总长度为40（28H)字节小于46字节，说明需要填充</p></blockquote></blockquote><h3 id="吞吐率-吞吐量"><a href="#吞吐率-吞吐量" class="headerlink" title="吞吐率/吞吐量"></a>吞吐率/吞吐量</h3><p>吞吐量表示IP数据报总的大小，而有效数据传输速度只考虑数据的传输。</p><p>但如果除去首部则吞吐量和有效数据传输意思一样。</p><p>P82 <img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512303.png" alt="image-20211129142220989"></p><blockquote><p>一个发送周期的时间为$512B<em>8/(64kb/s)+2</em>270ms=0.604s$ </p><p>吞吐量/吞吐率&lt;=数据发送速率</p><ul><li>发送窗口尺寸为1时，吞吐率为1x512Bx8/0.604s=6.8kb/s </li><li>发送窗口尺寸为7时，吞吐率为7x512Bx8/0.604s=47.56kb/s</li><li>发送窗口尺寸为17时，<strong>注意</strong>当发送窗口大于0.604/0.064即$\geq$10,发送窗口能保证连续发送，此时吞吐率=64kb/s</li></ul></blockquote><p>P234</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512304.png" alt="image-20211129143809736"></p><blockquote><p>这里提到了带宽，需要注意吞吐量$\leq$带宽。</p><p>RTT=40ms 则<br>$$<br>吞吐率=\frac{65535*8b}{40ms}=13.107Mb/s<br>$$<br>$线道效率=吞吐率/信道带宽=\frac{13.107Mb/s}{1000Mb/s}$  </p><p><font color="red">注意单位</font></p></blockquote><h3 id="分片问题"><a href="#分片问题" class="headerlink" title="分片问题"></a>分片问题</h3><p>一种8片首4</p><p>重点还是知道片偏移的基本单位是8B，MTU=800B，总长度为1580B的IP数据报分片，数据部分只能分为776（内部只能是8的倍数）+20， 776+20，8+20. </p><p>之前计网也出过类似的大题 （忘记哪一年了，最后是画个图）<strong>去年考过了 感觉今年考的概率不大。</strong></p><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>​    基本概念：</p><p>​    MSS：一个最大的报文长度,一般为1KB左右</p><p>​    <strong>发送窗口的上限值=min{拥塞窗口（cwnd），接收窗口（rwnd）}</strong></p><p>​    拥塞窗口</p><ol><li>慢开始+拥塞避免：先指数规律增长，之后达到门限值后加法增长，达到拥塞窗口后发送网络拥塞，经过一个RTT后变为1.</li><li>快重传快恢复：先指数规律增长，之后达到门限值后加法增长，达到拥塞窗口后收到三个冗余ACK，经过一个RTT后<strong>变为拥塞窗口的1/2</strong>.再线性增大<br>特征：发三个冗余的ACK报文，新的rwnd=1/2rwnd，开始线性增长。门限值也变为原来的一半</li></ol><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512305.png" alt="image-20211129164125266"></p><blockquote><p><strong>收到3个ACK后</strong>，拥塞窗口和门限值都变成了17KB，之后线性增大。经过4个RTT后变为了21KB</p></blockquote><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512306.png" alt="image-20211129164326088"></p><blockquote><p>这个其实就是问发送窗口是多少，发送窗口的上限值=min{cwnd，rwnd}，一定要注意发送窗口大小 </p><p>cwnd=4&gt;ss,说明是线性增长，经过一个RTT后，cmwd=5，接收窗口字段从确认报文中得到，rwnd=2，则取2KB</p></blockquote><p>TCP三次握手的第一次握手的第一个握手不携带数据，但是要消耗一个序号，之前好像有道真题涉及过这个内容。使得好像是从501-1500，总共1000B</p><h2 id="协议问题"><a href="#协议问题" class="headerlink" title="协议问题"></a>协议问题</h2><p>PPP 数据链路层 不可靠传输，具有错误检测能力，但不具备纠错能力</p><h1 id="计组"><a href="#计组" class="headerlink" title="计组"></a>计组</h1><h2 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章 计算机系统概述"></a>第一章 计算机系统概述</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>CPU时钟周期，主频，CPI,CPU执行时间，MIPS,MFLOPS</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512307.png" alt="image-20211129181056384"></p><p>常用的CPU主频有1.8GHz,2.4GHz,2.8GHz.</p><p>CPU的执行一段程序时间与CPI，和该程序段所含指令数目成正比和主频成反比，想象一下，主频越大，运行速度越快，执行一条指令所花的时间就越短。</p><p>指令字长是机器字长的整数倍。</p><p>机器字长是指的用于CPU内部用于证书运算的数据通路的宽度，因此CPU内部进行数据运算，存储传送的不见，宽度需要一直，机器字长等于CPOU内部用于整数运算的位数和通用寄存器宽度（通用寄存器可以存储数据）</p><h3 id="主频和时钟周期数的对应关系"><a href="#主频和时钟周期数的对应关系" class="headerlink" title="主频和时钟周期数的对应关系"></a>主频和时钟周期数的对应关系</h3><p>$$<br>1s=10^3ms=10^6μs=10^9ns<br>$$</p><p>主频往往都是几十MHz，则选取几个比较常见的作为记忆。</p><p>8MHz=125ns    50MHz=20ns    500MHz=2ns  （ns*M=1000）</p><h3 id="CPU-执行时间的基本计算"><a href="#CPU-执行时间的基本计算" class="headerlink" title="CPU 执行时间的基本计算"></a>CPU 执行时间的基本计算</h3><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512308.png" alt="image-20211129182738286"></p><blockquote><p>18，CPU速度提高50%，是变成了原来的1.5倍，则所需时间变为16s，总共花70s</p><p>19，0.7x1.2x20=16.8</p><p>20,   2/1.5:1/1.2=1.6</p></blockquote><h3 id="MIPS相关"><a href="#MIPS相关" class="headerlink" title="MIPS相关"></a>MIPS相关</h3><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512309.png" alt="image-20211129183256640"><br>$$<br>MIPS=\frac{主频}{CPI*10^6}<br>$$<br>若含有多种指令，那么CPI则为这多种指令的数学期望。CPI=3，则经过计算得                $MIPS=1200MHz/3M=400$</p><h2 id="第二章-数据计算"><a href="#第二章-数据计算" class="headerlink" title="第二章 数据计算"></a>第二章 数据计算</h2><h3 id="数据基本概念"><a href="#数据基本概念" class="headerlink" title="数据基本概念"></a>数据基本概念</h3><p>混个脸熟，2的次方</p><table><thead><tr><th align="center">2^14</th><th align="center">2^16</th><th align="center">2^18</th><th align="center">2^20</th></tr></thead><tbody><tr><td align="center">16384</td><td align="center">65536</td><td align="center">262144</td><td align="center">1048576</td></tr></tbody></table><p>PEZ</p><h3 id="补码运算"><a href="#补码运算" class="headerlink" title="补码运算"></a>补码运算</h3><p>负数补码转十进制技巧：找和它相加为2^n的最小整数再取反</p><p>例子int型 FFFF FFFFH为-1 FFFF FFFE为-2。</p><p>【2018】</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512310.png" alt="image-20211129185842186"></p><blockquote><p>x=FFFF FFDFH，只需要看前两位DF，对应的为-(256-13*16+15)或者这么想DF+21刚好进位，则x=-21H=-33</p><p>y=0000 0041H,y=65（<font color="red"><strong>这里注意41H对应的是4*16+1=65</strong></font>）,x-y=-98，98转为16进制为62H，则对应的机器数为FFFF FF9EH,因为9EH+62H=2^8. 选C</p></blockquote><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512311.png" alt="image-20211129190819237"></p><blockquote><p>注意一下补码的范围为<br>$$<br>-2^{n-1}&lt;=x&lt;=2^{n-1}-1<br>$$<br>这道题刚好没有溢出，因为左边符号位和进位是一样的，取到了-128</p></blockquote><h3 id="小端方式存储"><a href="#小端方式存储" class="headerlink" title="小端方式存储"></a>小端方式存储</h3><p>低位数据存储在低位地址，高位数据存储在高位地址，<strong>和我们正常的思考是不一样的</strong>，但是<strong>内部是正常顺序</strong></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512312.png" alt="image-20211129191253260"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512313.png" alt="image-20211129191323812"></p><p>计算机是用的小端存储</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512314.png" alt="image-20211129191736216"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512315.png" alt="image-20211129191625700"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512316.png" alt="image-20211129191633140"></p><p>算数右移：负数高位补1，正数高位补0</p><p>逻辑右移：都补0</p><h3 id="浮点数的计算"><a href="#浮点数的计算" class="headerlink" title="浮点数的计算"></a>浮点数的计算</h3><p><strong>IEE754符1阶8尾23</strong></p><p>尾数的范围为1~2-2^-23(1.0-1.111…1(后面23个1))</p><p>阶数的范围为-127-126    偏置值为127</p><p>表示范围为<br>$$<br>2^{-126}-2^{127}*(2-2^{-23})<br>$$</p><p>左规相当于x2，右规相当于/2</p><p>【2015】</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512317.png" alt="image-20211129192857365"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512318.png" alt="image-20211129193419319"></p><p><strong>补充：</strong></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512319.png" alt="image-20211129193504155"></p><p><strong>具体题目可以再去研究一下【2017年】的真题大题</strong></p><h3 id="算数逻辑单元"><a href="#算数逻辑单元" class="headerlink" title="算数逻辑单元"></a>算数逻辑单元</h3><p>无符号数看CF：$最高位进位\oplus sub$  1:为溢出 0为不溢出</p><p>有符号数看OF:$最高位进位\oplus 次高位进位$ 1:为溢出 0为不溢出</p><p>SF：符号标志位，只看最高位</p><p>零标志位：ZF=1，说明结果为0，否则为1；</p><h2 id="第三章-存储系统"><a href="#第三章-存储系统" class="headerlink" title="第三章 存储系统"></a>第三章 存储系统</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p>存储速度：数据传输率=数据的宽度/存储周期</p><blockquote><ol><li>存储时间（Ta）指启动一次存储器的操作到完成该操作所经历的时间，分为<strong>读出和写入时间</strong></li><li>存储周期：一次完整的读写操作所需要的时间</li><li>主存带宽：数据传输率，单位B/s或者b/s</li></ol></blockquote></li></ul><p>存取周期表示从开始存取到下一次存取一整个时间，存取周期=存取时间+恢复时间</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512320.png" alt="image-20211129200116246"></p><p>地址线的宽度和MAR相同，数据线总线的宽度和MDR相同</p><h3 id="Cache命中率问题："><a href="#Cache命中率问题：" class="headerlink" title="Cache命中率问题："></a>Cache命中率问题：</h3><p>(剩余见笔记)</p><p>Cache的总命中次数为Nc，访问主存的总次数为Nm，则命中率H为<br>$$<br>H=N_c/(N_c+N_m)<br>$$<br>为跳过</p><ol><li><p>主存和Cache不同时访问：</p><p>设命中率为x，Cache的存取时间为$t_1$,主存的存取时间为$t_2,那么总时间t为<br>$$<br>t=t_1+(1-x)*t_2<br>$$</p></li><li><p>主存和Cache同时访问</p><p>设命中率为x，Cache的存取时间为$t_1$,主存的存取时间为$t_2,那么总时间t为<br>$$<br>t=x<em>t_1+(1-x)</em>t_2<br>$$</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512321.png" alt></p></li></ol><blockquote><p>将上式代入得<br>$$<br>115=x<em>100+（1-x）</em>1000<br>$$<br>解得x=98.33%</p></blockquote><h3 id="DRAM-SRAM"><a href="#DRAM-SRAM" class="headerlink" title="DRAM,SRAM"></a>DRAM,SRAM</h3><p>​    基本概念：</p><p>​    DRAM采用地址复用技术需要考虑两根行列片选线，按行优先</p><h3 id="存储芯片的问题"><a href="#存储芯片的问题" class="headerlink" title="存储芯片的问题"></a>存储芯片的问题</h3><p>​    8KB*8位，位扩展，后面的位数变化。字拓展KB前面的数字变化。</p><p>​    <strong>MAR的位数决定主存地址空间的大小</strong>【2011真题】</p><p>​    <strong>存储芯片片选问题</strong></p><p>​    线选法：有点：不需要地址译码器，线路简单。每一片都需要一条地址线。缺点：容易造成资源的浪费</p><h4 id="译码片选法：（难点）"><a href="#译码片选法：（难点）" class="headerlink" title="译码片选法：（难点）"></a><strong>译码片选法：（难点）</strong></h4><p>假设需要n个片选信号，则需要$log_2n$位来产生片选信号。低地址位是作为各芯片接入的地址端，而高地址位作为译码器的输入端。</p><p>注意点：</p><p>1，看低地址端是$A_0还是A_{15}$ 有的题目还不一样。</p><p>2，<strong>求最小地址时，只看<font color="red">组成芯片</font>的地址线即可，不用看数据线</strong>，例子，芯片为A:8Kx4位和B：8Kx8位的地址线都是13位，但是如果组成64Kx8位的存储器，那么需要A芯片的片选线为4位。B芯片的片选线为5位。</p><p>【2010】</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512322.png" alt="image-20211130141117161"></p><blockquote><p>总共需要8个片选信号，那么高$long_28=3$位为作为片选信号</p><p>0B1FH=0000 1011 0001 1111 看2k，对应的为低11位，即0000 1<font color="red">011 0001 1111 </font>取高三位为片选信号，则该所在芯片为1（从0开始）号芯片，地址范围为 00 001 <font color="red">000 0000 0000</font>-00 001 <font color="red">111 1111 1111</font></p><p>即地址范围为0800H-08FFH。</p></blockquote><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512323.png" alt="image-20211130141830176"></p><blockquote><p>同样的，不需要看位数，只需要看前面的地址线，地址线为15位，前面三位为片选地址，总共18位，所在为7号芯片，地址为0011 1000 0000 0000 0000（后面15个0）-0011 1111 1111 1111 1111 即38000H-3FFFFH</p></blockquote><h3 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h3><h4 id="高位交叉编址"><a href="#高位交叉编址" class="headerlink" title="高位交叉编址"></a>高位交叉编址</h4><p>​    总是先在一个模块内访问，然后再去范围下一个模块，不能做到并行访问，不能提高存储器的吞吐率。</p><h4 id="低位交叉编址"><a href="#低位交叉编址" class="headerlink" title="低位交叉编址"></a><strong>低位交叉编址</strong></h4><p>​    4年没考了….</p><p>​    四体并行交叉编址：在一个周期内能访问4个模块。</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512324.png" alt="image-20211201163514971"></p><p>​    2013年考过8体交叉</p><p>​    P115 低位地址为体号，高位地址为体内地址，采用低位交叉编址后，在不改变每个模块存取周期的前提下，采用流水线方式<strong>并行存取</strong>，提高存储器的带框</p><p>设模块字长等于数据总线宽度，模块存取一个字的存取周期为T，总线传送周期为R，流水线方式存起，存储器模块数应大于等于<br>$$<br>m=T/r<br>$$<br>m交叉存取度，四体并行交叉，则m=4，经过r时间延迟后启动下一个模块，交叉存储器要求其模块数必须大于等于m，以保证经过mxr的时间后再次启动时，上次存取已经完成了。那么连续存取m个字所需要的时间为<br>$$<br>t_1=T+(m-1)*r<br>$$<br><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512325.png" alt="image-20211130144847261"></p><p>例题：</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512326.png" alt="image-20211130144907109"></p><p>并行存储，带宽能大很多。</p><p>【2015】</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512327.png" alt="image-20211130145325267"></p><blockquote><p>如果给定的访存地址在相邻的4次访问中出现在同一个模块里，那么就会出现访存冲突，这道题目中出现访存冲突的为8000和8004</p></blockquote><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512328.png" alt="image-20211130145600645"></p><blockquote><p>double型为8B，这道题主要是考察画图，四体交叉，每次最多读写32位，那么r=1/4T，那么读取x所需要的总时间为t=T+(m-1)r=T+7/4T=11/4T,需要3个存储周期。或者画图也可得到答案。</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512329.png" alt="image-20211130145855772"></p></blockquote><p> <img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512330.png" alt="image-20211130145914308"></p><blockquote><p>1)32*4=128位</p><p>2）错误，意思是100ns内每个个体可以向CPU提供32位二进制信息，但实际上上在一个存储周期内400ns内每个个体才能向CPU提供32位信息，在100ns内整个存储器可以提供32位的信息</p></blockquote><blockquote><p>一个存储体在一个周期内能传输一个字，那么主机最快200/4=50ns读出一个字</p><p>带宽=数据量/存储周期=16B/200ns=80MB/s</p><p>不能，换成高位交叉后通常起不到存储器读写的速度，不符合局部性原理，通常只有一个存储器在不停地忙碌，其他的都是空闲的。 </p></blockquote><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512331.png" alt="image-20211130153813260"></p><h3 id="Cache块的计算"><a href="#Cache块的计算" class="headerlink" title="Cache块的计算"></a><strong>Cache块的计算</strong></h3><p>Cache每行：有效位+脏位+替换控制位（LRU,FIFO之类的）+tag+数据</p><p>tag位通过计算主存地址空间大小来计算</p><p>总线的时钟周期和CPU的时钟周期是不一样的。</p><h3 id="Cache传输的综合题-【2013】"><a href="#Cache传输的综合题-【2013】" class="headerlink" title="Cache传输的综合题 【2013】"></a>Cache传输的综合题 【2013】</h3><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512332.png" alt="image-20211130161700960"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512333.png" alt="image-20211130161733047" style="zoom:50%;"><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512334.png" alt="image-20211130161808189" style="zoom:50%;"></p><blockquote><p>r一般是等于一个总线时钟周期</p><p>(3) 突发传送：通过系统总线将首地址和命令传给存储器，存储器把数据传入CPU，CPU再把数据传入到Cache</p><p>总共有3步，传送首地址和命令    存储器准备数据（8体交叉） 传送数据</p><p>传送首地址和命令：5ns（题目中给了）<br>存储器准备数据（8体交叉，其实这里可以看出来是8体交叉，总线的周期为5ns，40ns/5ns=8）根据公式<br>$$<br>t=T+(m-1)<em>r=40ns+(8-1)</em>5=75ns<br>$$<br>传送32字节数据：5ns</p><p>总共花费5+75+5=85ns</p></blockquote><blockquote><p>解法2：<img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512335.png" alt="image-20211130162743300"></p><p>把数据准备好之后就传送数据</p></blockquote><blockquote><p>第四问：</p><p>总时间分为Cache缺失和Cache不缺失两种情况。</p><p>Cache命中时平均每条指令需要4个CPU时钟周期，4*1.25ns=5ns。</p><p>Cache不命中时需要通过一个度突发传送总线事物来完成读取，则为1.2<em>85ns+5ns=107ns（前面是处理缺失，后面是处理完缺失之后还得再读一次，，*</em>不是说主存和Cache同时读**）</p><p>总共时间为：100x0.95x5ns+100x0.05x107ns</p><p>解法2</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512336.png" alt="image-20211130163550106"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512337.png" alt="image-20211130163433530"></p></blockquote><h3 id="第四章-指令系统"><a href="#第四章-指令系统" class="headerlink" title="第四章 指令系统"></a>第四章 指令系统</h3><h3 id="扩展操作码的指令格式"><a href="#扩展操作码的指令格式" class="headerlink" title="扩展操作码的指令格式"></a>扩展操作码的指令格式</h3><p>​    注意两点：</p><p>1，不允许短码是长码的前缀，符合哈夫曼编码</p><p>2，各个指令的操作码一定不能重复。</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512338.png" alt="image-20211130180028193"></p><blockquote><p>二地址指令，地址总共占了24位，还剩下8位，其中250条作为二地址指令，剩余256-250=6条，那么总共的单地址条数为6*2^12条，即24K，此时没有一条零地址指令。</p></blockquote><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512339.png" alt="image-20211130180408558"></p><blockquote><p>地址字段6位，三地址指令地址位占18位，指令为29条，说明op≥5，但op=5时，还剩余3条，则可以表示3*2^6=192条，那么最多能表示192条，因此指令最少为23位</p><p><strong>又因为指令是按照字节编址，那么最少为24位</strong></p></blockquote><h3 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h3><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512340.png" alt="image-20211130183618848"></p><p>操作码 寻址特征位（用来区分是什么类型的寻址）</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512341.png" alt="image-20211130181330125"></p><p>A的范围为2^8</p><p>间接寻址：指向A地址的内容，又因为存储器是按照字编址的，所以间接寻址指向的是16位，即2^16。正常应该是0-2^16-1</p><p>变址寻址：2^16+A</p><p>相对寻址：PC不变，为定值，只能改变A,则为256</p><h2 id="第五章-中央处理器"><a href="#第五章-中央处理器" class="headerlink" title="第五章 中央处理器"></a>第五章 中央处理器</h2><h3 id="微程序控制编码"><a href="#微程序控制编码" class="headerlink" title="微程序控制编码"></a>微程序控制编码</h3><p>​    直接编码：n个微命令要求微指令的操作字段为n位。</p><p>​    字段直接编码，互斥+1</p><p>​        <img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512342.png" alt="image-20211130185159577"></p><blockquote><p>14，分别对应 8 4 13 6 7,那么对应的操作控制字段为3+2+4+3+3=15</p><p>15，2+4*32=130，那么需要$log_2{130}$向上取整为8</p></blockquote><h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><p>流水线的基本公式<br>$$<br>TP=\frac{n}{T_k}<br>$$<br>n为任务数，$T_k$为处理完n个任务所用的时间。</p><p>实际吞吐率为<br>$$<br>TP=\frac{n}{（k+n-1）\Delta t}<br>$$<br>k表示流水线的段数, $\Delta t$为时钟周期。</p><p>流水线加速比：<br>$$<br>S=\frac{kn}{k+n-1}<br>$$<br>当n-&gt;∞时，Smax=k</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512343.png" alt="image-20211130190828865"></p><blockquote><p>流水线的段数k=3，n=8 则代入公式得<br>$$<br>S=\frac{3*8}{3+8-1}=2.4<br>$$</p></blockquote><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512344.png" alt="image-20211130191203004"></p><blockquote><p>四段流水线，k=4<br>$$<br>吞吐率=\frac{100}{100+3-1<em>\Delta t}=\frac{100}{103</em>1/(1.03<em>10^9)}=1</em>10^9<br>$$</p></blockquote><h2 id="第六章-总线"><a href="#第六章-总线" class="headerlink" title="第六章 总线"></a>第六章 总线</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512345.png" alt="image-20211130192241964"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512346.png" alt="image-20211130192254687"></p><p>带宽：传输率。宽度：16位，32位这些</p><p>n通道的存储器总线，那么对应的总带宽要相应地*n。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512347.png" alt="image-20211130192554050"></p><blockquote><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512348.png" alt="image-20211130192615733"></p></blockquote><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512349.png" alt="image-20211130192347893"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512350.png" alt="image-20211130192634482"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512351.png" alt="image-20211130192401804"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512352.png" alt="image-20211130192656315"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512353.png" alt="image-20211130192714236"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512354.png" alt="image-20211130192722536"></p><h2 id="第七章-输入输出系统"><a href="#第七章-输入输出系统" class="headerlink" title="第七章 输入输出系统"></a>第七章 输入输出系统</h2><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><p>​    用OS里面一段印象比较深的一段话来概括：</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512355.png" alt="image-20211201140718571"></p><h3 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h3><p>​    CPU和I/O串行工作。</p><h3 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h3><h4 id="程序中断流程图："><a href="#程序中断流程图：" class="headerlink" title="程序中断流程图："></a>程序中断流程图：</h4><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512356.png" alt></p><p>​    异常：发生在CPU内部</p><p>​    1，故障： 不能回到断点，比如非法操作码，除数为0</p><p>​    2，自陷：主动陷入，返回自陷的下一条指令否则会陷入循环</p><p>​    3，终止：硬件故障。</p><p>外部中断：</p><p>​    I/O中断：键盘输入，esc等，时钟中断</p><p><strong>不同点</strong>：缺页或者溢出是由特定指令在执行过程中产生的。        异常的检测由CPU自己完成，而中断必须通过总线获取中断源的表示信息</p><p>中断隐指令：是由硬件实现的</p><p><strong>硬件完成</strong>：关中断，保存断电，中断服务程序寻址</p><p><strong>软件完成</strong>：保存现场和屏蔽字，开中断，执行中断服务，关中断，恢复现场和屏蔽字，开中断 中断返回。<strong>（保存和恢复现场和屏蔽字需要一气呵成）</strong>需要关中断</p><h4 id="多重中断"><a href="#多重中断" class="headerlink" title="多重中断"></a>多重中断</h4><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512357.png" alt="image-20211201140412711"></p><blockquote><p>主要是数一：1越多优先级越高，表示把所有人包括自己的中断源都屏蔽了。</p><p>选C</p></blockquote><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512358.png" alt="image-20211201143517710"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512359.png" alt="image-20211201143523994"></p><blockquote><p>要满足题意，L1只屏蔽自己和L3，为01010，选C</p></blockquote><h4 id="中断方式的计算"><a href="#中断方式的计算" class="headerlink" title="中断方式的计算"></a>中断方式的计算</h4><p>【2011】【2014】</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512360.png" alt="image-20211201143638109"></p><blockquote><p>4,50Mhz,时钟周期为20ns，查询200次，一次500个时钟周期，则总共时长为<br>$$<br>百分比为=20<em>200</em>500*10^{-9}=0.2%<br>$$</p></blockquote><blockquote><p>5,每400ns就要处理一次中断，在400ns里有100ns是用于中断请求的处理和响应的。那么 占比为100/400=25%，中断响应的延迟时间意思是最迟可以过50ns再响应，相当于从0-100-&gt;50-150,但<strong>是占比还是没有变化。</strong></p></blockquote><p>【2019】</p><p>​    <img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512362.png" alt="image-20211201140819008"></p><blockquote><p>A</p></blockquote><h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h3><p><font color="red">把22CO的课后题目做好就行，感觉基本上涵盖和IO输入输出的所有计算了。</font></p><h4 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h4><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512363.png" alt="image-20211201163405330"></p><p><strong>周期挪用考的比较多类似于2016年的真题</strong></p><p>每个<strong>机器周期</strong>结束后，CPU可以响应DMA请求。DMA与主存交互数据时，通过周期窃取方式，窃取的是<strong>存取周期</strong>。</p><p>DMA（靠硬件电路实现）只用于数据传输，不具备对异常事件的处理能力。中断程序可以对处理异常事件，跳转，或者终止程序之类的</p><p>DMA适用于磁盘机，磁带机等高速设备大批量数据传送。</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512364.png" alt="image-20211201150317918"></p><p>注意传送前需要通过程序预处理，结束后需要中断方式处理，（不管怎么样，最后CPU还是要管一下）</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512365.png" alt="image-20211201150430139"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512366.png" alt="image-20211201150442643"></p><h4 id="DMA的传送方式："><a href="#DMA的传送方式：" class="headerlink" title="DMA的传送方式："></a>DMA的传送方式：</h4><p>​    1）停止CPU访存。DMA控制器发个信号给CPU，让DMA接管总线，之后数据传输完之后，DMA控制器再发个信号给CPU说你可以过来接管了，把总线控制给CPU</p><p>​    2）周期挪用（是对应的存取周期）</p><p>​        I/O设备有请求后分为三种：</p><ol><li><p>CPU不在访存，那没啥事。</p></li><li><p>CPU在访存，必须等存取周期结束后，CPU再放弃总线的占有权，（<strong>相当于是非抢占式</strong>）</p></li><li><p>I/O和CPU同时访存，I/O先访存，I/O如果不访存的话可能数据就被新的数据覆盖掉了。</p><p>3）DMA和CPU交替访存，用于CPU的工作周期比主存存取周期长，部分用于DMA访存,部分用于CPU访存。分时控制</p></li></ol><h4 id="DMA的传送过程"><a href="#DMA的传送过程" class="headerlink" title="DMA的传送过程"></a>DMA的传送过程</h4><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512367.png" alt="image-20211201151622332"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512368.png" alt="image-20211201151629700"></p><h4 id="DMA和中断的区别-（考的较多）"><a href="#DMA和中断的区别-（考的较多）" class="headerlink" title="DMA和中断的区别 （考的较多）"></a>DMA和中断的区别 （考的较多）</h4><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512369.png" alt="image-20211201151656349"></p><h4 id="DMA的综合计算"><a href="#DMA的综合计算" class="headerlink" title="DMA的综合计算"></a><font color="red"><strong>DMA的综合计算</strong></font></h4><p>这里大题出的比较多，感觉DMA属于比较好的I/O控制方式了。</p><p><font color="red">【2012DMA】<strong>考的不难，但是很综合</strong></font></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512370.png" alt="image-20211201151950794"></p><blockquote><p>1）问的是最少，那么是看主存和Cache的交换</p><p>2）300k</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512371.png" alt="image-20211201161731790"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512372.png" alt="image-20211201161741984"></p><p>#### </p></blockquote><h4 id="补充知识点："><a href="#补充知识点：" class="headerlink" title="补充知识点："></a><strong>补充知识点：</strong></h4><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512373.png" alt="image-20211201163653554"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512374.png" alt="image-20211201163740248"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512375.png" alt="image-20211201163952266"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512376.png" alt="image-20211201164008647"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512377.png" alt="image-20211201164035202"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512378.png" alt="image-20211201164053026"> </p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512379.png" alt="image-20211201164118891"></p><blockquote><p>（1）总共需要传输10位。<strong>（题目里给的信息基本上是有用的，不要忽略）</strong> <strong><font color="red">1位起始位</font></strong>1位奇校验，一位停止位。</p><p>传送一个字符需要花0.5ms，那么1s内能传送1s/0.5ms=2000个</p><p>（2）其实这道题在最后时可能会有一定的偏差，但问的是大约，不要钻牛角尖。</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512380.png" alt="image-20211201160749556"></p><p>时钟周期：20ns。</p><p>0.5ms对应的是25000个时钟周期</p><p>读取一个字符的时间=传送时间+响应时间+15条指令的时间=25000+10+15*4=25070</p><p>那么总共需要25070*1000个时钟周期</p><p>CPU需要做的事情是中断响应和服务程序。就是下面的部分。<strong>中间有个交叠的部分</strong></p><p>那么时间为1000*（10+20x4）=9x10^4</p><p>CPU操作：关中断 保存断点，引出中断服务程序</p><p><font color="red"><strong>补充</strong></font></p><p>同步通信：一次通信只传送一帧信息，但这一帧里带有若干数据字符，通过同步字符作为开始</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512381.png" alt="image-20211201161131126"></p><p>1，起始位默认都有，校验位可能没有，需要看题目。停止位可能有多位</p><p>2，有效数据传输率只考虑<strong>数据位</strong>，需要乘一个比例，计网考过一个类似的大题</p></blockquote><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512382.png" alt="image-20211201161358091"></p><p>【2010年真题】，这里面的有效数据传输率就只有1500B，前面的首部占了18位，<strong>注意</strong></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512383.png" alt="image-20211201163117543"></p><blockquote><p>这道题目比较简单，直接发答案了，但比较综合。考察了程序查询，程序中断，DMA三种方式，适合用来复习。</p></blockquote><p><img src="C:%5CUsers%5C%E6%9D%8E%E7%AB%A0%E6%9D%B0%5CDesktop%5Cimage-20211201163055386.png" alt="image-20211201163055386"></p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="第二章进程管理"><a href="#第二章进程管理" class="headerlink" title="第二章进程管理"></a>第二章进程管理</h2><h3 id="进程的调度算法"><a href="#进程的调度算法" class="headerlink" title="进程的调度算法"></a>进程的调度算法</h3><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512384.png" alt="image-20211201175736026"></p><p>I/O的优先级要高于CPU。</p><p>有味道的例子</p><p>（1）CPU利用率–<font color="orange">厕所有人拉屎的时间/总时间</font></p><p>（2）系统吞吐量，这里的系统吞吐量是表示的CPU所能完成的作业数量。其实概念大同小异</p><p>—<font color="orange">某厕所一秒可以让多少人拉完屎</font></p><p>（3）周转时间：作业提交到作业完成所经历的时间–<font color="orange">-开始排队到拉完</font><br>$$<br>周转时间=作业完成时间-作业提交时间<br>$$<br>（4）平均周转时间：多个作业周转时间与作业实际运行时间的比值<br>$$<br>平均周转时间=（作业1+作业2+…）/n<br>$$<br>（5）带权周转时间，带权周转时间≥1，越小越好。—-<font color="orange">开始排队到拉完/实际拉屎时间</font><br>（等了多久/拉了多久）<br>$$<br>带权周转时间=\frac{作业周转时间}{作业实际运行时间}<br>$$<br>平均带权时间=（作业1带+作业2带+…）</p><p>（6）等待时间—进程/作业等待被服务时间的总和<br>    对于作业而言还要加上在外存预备队列中等待的时间</p><p>（7）响应时间–从提交到首次被响应的时间</p><p>（8）响应比<br>$$<br>响应比=\frac{等待时间+要求服务时间}{要求服务时间}<br>$$</p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a><strong>例题</strong></h4><p>1，主要方法是画甘特图，然后细致一点，一步步地画，没有什么技巧性</p><p>2，注意看是抢占性还是非抢占性的</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512385.png" alt="image-20211201175522312"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512386.png" alt="image-20211201175340798"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512387.png" alt="image-20211201175450095"><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512388.png" alt="image-20211201175350848"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512390.png" alt="image-20211201175712959"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512391.png" alt="image-20211201175824388"></p><p>死锁定理：检查死锁</p><h3 id="银行家算法（死锁避免）"><a href="#银行家算法（死锁避免）" class="headerlink" title="银行家算法（死锁避免）"></a>银行家算法（死锁避免）</h3><p>通过模拟来判断是否会死锁，并建立一个安全序列<strong>（可能不唯一）</strong>。</p><p>安全状态，系统一定无死锁进程。</p><p>不安全状态，系统不一定有死锁进程。</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512392.png" alt="image-20211201180625956"></p><p><strong>答案很复杂，但手动模拟比较快</strong></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512393.png" alt="image-20211201180756520"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512394.png" alt="image-20211201180647373"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512395.png" alt="image-20211201180807820"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512396.png" alt="image-20211201180655604"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512397.png" alt="image-20211201180814165"></p><h2 id="第三章内存管理"><a href="#第三章内存管理" class="headerlink" title="第三章内存管理"></a>第三章内存管理</h2><h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3><table><thead><tr><th align="center">单一连续分配</th><th>固定分区分配</th><th>动态分区分配</th></tr></thead><tbody><tr><td align="center">单用户，可以采用覆盖技术，无外部碎片，有内部碎片</td><td>无外部碎片，但是有内部碎片（当程序小于固定分区时）</td><td>有外部碎片（最佳适应算法最容易产生内存碎片）</td></tr></tbody></table><p>1，连续分配</p><p>2，固定分配</p><p><strong>3，动态分配</strong>（忘了）</p><ul><li>首次适应算法。空闲分区以<strong>地址递增</strong>的次序链接，找到第一个满足的（<strong>最优</strong>）</li><li>最佳适应算法。空闲分区以<strong>容量递增</strong>的方式形成分区连，找到第一个满足要求的空闲分区，先找小的再找大的。<strong>（最容易产生内存碎片）</strong></li><li>最坏适应算法。空闲分区以<strong>容量递减</strong>的方式形成分区连，先找最大的分区，再接着找</li><li>邻近适应算法。分配内存从上次结束位置开始继续查找</li></ul><h3 id="非连续分配管理方式（重点）"><a href="#非连续分配管理方式（重点）" class="headerlink" title="非连续分配管理方式（重点）"></a>非连续分配管理方式（重点）</h3><h3 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h3><p>分页可能会造成内部碎片，因为分页是固定大小的</p><h4 id="分页存储管理"><a href="#分页存储管理" class="headerlink" title="分页存储管理"></a>分页存储管理</h4><p>​    主要考察二级页表</p><table><thead><tr><th>一级页号</th><th>二级页号</th><th>页内偏移</th></tr></thead></table><h4 id="分段存储管理"><a href="#分段存储管理" class="headerlink" title="分段存储管理"></a>分段存储管理</h4><table><thead><tr><th>段号</th><th>段长</th><th>本段在内存中的地址</th></tr></thead></table><h4 id="段页存储管理"><a href="#段页存储管理" class="headerlink" title="段页存储管理"></a>段页存储管理</h4><p>段表只有一个，页表可以有多个</p><table><thead><tr><th>段号S</th><th>页号P</th><th>页内偏移量</th></tr></thead></table><p>访问段表时可能会出现越界异常</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512398.png" alt="image-20211214140642576"></p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟存储器的最大容量由计算机的地址结构所决定</p><h4 id="请求分页管理"><a href="#请求分页管理" class="headerlink" title="请求分页管理"></a>请求分页管理</h4><p>1，<strong>页表机制</strong></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512399.png" alt="image-20211214140911253"></p><p>2，<strong>缺页中断机制</strong></p><p>​    1，属于内部中断。</p><p>​    2，一条指令在执行期间可能会产生多次缺页中断</p><p>3，<strong>地址变换机构</strong></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512400.png" alt="image-20211214140838269"></p><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p>OPT：最优但是无法实现</p><p>FIFO：</p><p>注意：只有FIFO会产生Belady异常。物理块数增大但是页故障数目不减反增的异常现象。</p><p>LRU：最近最久未使用：堆栈类算法。选择最近最长未访问的页面予以淘汰。</p><p>CLOCK置换算法</p><p>与页表机制有关。有使用和修改位。 先看使用再看修改位。优先替换未使用过的。</p><h4 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h4><p>固定分配 局部置换（每次调用都是调用一整页，物理块数目不变，一次全换）</p><p>可变分配 全局置换（最容易实现）</p><p>缺页时，从空闲物理块中取一个给该进程，一块块地取</p><p>可变分配 局部置换</p><p>缺页时，选一页调出。</p><h4 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h4><p>驻留级大小一般不能小于工作集大小</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512401.png" alt="image-20211214142225081"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512402.png" alt="image-20211214142524459"></p><p>这里注意一下是问的置换总次数而不是缺页数目。页的置换总次数为5次。缺页数目为9次。</p><p>这种题目一个个好好算就行。没有太多技巧。53 276需要置换。</p><h3 id="内存管理大题"><a href="#内存管理大题" class="headerlink" title="内存管理大题"></a><strong>内存管理大题</strong></h3><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512403.png" alt="image-20211214150001912"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512404.png" alt="image-20211214150019301"></p><p>P201</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512405.png" alt="image-20211214143519308"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512406.png" alt="image-20211214143555185"></p><p>（3）处理缺页之后还需要返回缺页前的指令再重新执行一次，这个时候所查到的页表项已经在关联寄存器里面了。<strong>所以还需要一次访问1次关联寄存器</strong></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512407.png" alt="image-20211214144339123"></p><p><strong>第一小问很经典，感觉可以出成小题，</strong></p><blockquote><p>整个过程：通过访问虚拟地址最终得到物理地址。这里的页框号就是指的<strong>物理页框号</strong></p><p>先访问TLB，TLB未命中的话再访问内存里的页表，</p><p>内存里的页表命中的话合成物理地址后访问物理地址，得到数据。</p><p><font color="red">未命中的话发生缺页。处理完缺页之后，将所需要的页框放入对应的TLB和页表中（更新TLB和页表）再重新进行访问TLB。</font></p><p>1）</p><p>1，0010 TLB为空 10ns，访问内存 100ns。内存页表命中，合成对应物理地址，之后再访问内存。</p><p>2,   0001 TLB不命中 10ns，访问内存100ns。内存页表不命中，产生缺页。耗时$10^8ns$，之后更新TLB和页表。返回缺页发生前的状态，再次进行访问TLB 10ns，此时TLB命中，合成物理地址，在进行访问内存100ns，总共耗时10^8+220ms</p><p>2）合法驻留级为2，根据LRU算法，淘汰0号页面，所以1565H对应的页框号位101H，即物理地址为101565H</p></blockquote><p>2010</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512408.png" alt="image-20211214145706380"></p><blockquote><p>1）0001 01   11 1100 1010H 页内偏移量10bit 页号5</p><p>2）对应的物理地址 应该是   0111  11 1100 1010  1FCAH 是中置换算法 对应的是2号    0010 11 1100 1010 B=   0BCAH 注意审题</p></blockquote><p><strong><font color="red">2013 做了差不多三遍了，还是掌握不是那么透彻</font></strong></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512409.png" alt="image-20211214151301739"></p><blockquote><p>1)4KB  已级页表最大为2^20*4B=4MB</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512410.png" alt="image-20211214154029439"></p><p>逻辑地址为0008 000H，说明页号为8，那么对应页表中的第八个表项。每一个表项长度为4B，八个表项为32B，转换为<strong>16进制</strong>为20H，那么最后的答案为0020 0020H和0020 0024H，因为8KB对应了两页 即两个页表项。 </p><p>物理地址：<strong>（页框号：页内地址）</strong> 通过观察我们可以发现页框号1为00900H，那么页框号2应该为00901H，<strong>因为页号和页框号也是一一对应的</strong></p></blockquote><p>2018</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512411.png" alt="image-20211214154446418"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512412.png" alt="image-20211214154521404"></p><p>这道题目好好看看就行，<strong>然后注意一下PDBR</strong></p><p>同一进程下的线程共享地址空间</p><h2 id="第四章-文件管理"><a href="#第四章-文件管理" class="headerlink" title="第四章 文件管理"></a>第四章 文件管理</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><h4 id="位图法："><a href="#位图法：" class="headerlink" title="位图法："></a>位图法：</h4><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512413.png" alt="image-20211214173416780"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512414.png" alt="image-20211214175855572"></p><p> 因为位图法是1位代表一个磁盘的状态，409612/（1024x8）=50，第50号块，实际上是49号，32号对应的是0号，那么32+49=81号。余12，从0开始编号，那么12/8=1，在1号字节里面。</p><p>22：</p><p><strong>文件系统管理空闲磁盘的方法有</strong> 位图法，空闲链表法，空闲表法，成组链接法</p><p>索引结点：文件目录管理部分。每个文件对应一个索引节点。除了文件名意外的所有信息都放到索引节点中。目录项只包含文件名，索引结点指针。文件有对应的索引表</p><h3 id="文件管理大题"><a href="#文件管理大题" class="headerlink" title="文件管理大题"></a>文件管理大题</h3><h4 id="连续链式索引的区别"><a href="#连续链式索引的区别" class="headerlink" title="连续链式索引的区别"></a>连续链式索引的区别</h4><p>当做知识点去记忆。</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512415.png" alt="image-20211214184459968"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512416.png" alt="image-20211214184441241"></p><p><strong>关于启动磁盘多少次的问题</strong></p><p>链接分配</p><p>P263 T7</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512417.png" alt="image-20211214181808267"></p><blockquote><p>1）10+256（一级索引块）+256*256（二级索引）+256x256x256（）</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512418.png" alt="image-20211214182302359"></p><p>2）</p></blockquote><p><strong><font color="red">通过看图好好理解</font></strong></p><blockquote><p>先找到目录项，再把FCB从外存读入内存，再去寻找文件信息</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512419.png" alt="image-20211214182832872"></p><p>4B拉链</p><p>普通文件变为了索引分配的文件 ，目录文件变成了链接分配的形式。不设置专门的FCB</p><p>根目录常驻内存。  第一次：从外存中读入A的目录文件 第二次：读取D的目录文件的数据块， 第三次读取J的FCB </p><p> J读取数据块最多需要4次，最少需要一次。</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512420.png" alt="image-20211214183308617"></p><p>3）读W 最少需要5次把W的FCB读入，之后通过FCB，直接索引把外存的数据块读入内存 1次。 6次</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512421.png" alt="image-20211214183534051"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512422.png" alt="image-20211214183642412"></p><p>读入W的FCB  1次，之后再读入4次<img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512423.png" alt="image-20211214183722669" style="zoom:67%;"></p></blockquote><p>P263T8</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512424.png" alt="image-20211214210919103"></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512425.png" alt="image-20211214210906336"></p><h3 id="磁盘组织和管理"><a href="#磁盘组织和管理" class="headerlink" title="磁盘组织和管理"></a>磁盘组织和管理</h3><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512426.png" alt="image-20211214163430151"></p><h4 id="磁盘调度公式："><a href="#磁盘调度公式：" class="headerlink" title="磁盘调度公式："></a>磁盘调度公式：</h4><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512427.png" alt="image-20211214162818200"><br>$$<br>T_a=T_s+\frac{1}{2r}+\frac{b}{rN}<br>$$<br>1）寻找时间 Ts：将磁头移动到指定磁道所需要的时间还包括启动磁臂的时间</p><p>2）延迟时间 Tr：磁头定位到某一磁道扇区所需要的时间，旋转速度为r。相当于是转了半圈<br>$$<br>T_r=\frac{1}{2r}<br>$$<br>3）传输时间Tt，从磁盘读出或者向磁盘写入数据所经历的时间。取决于每次读写字节数和旋转速度。</p><p>r：每秒的转速。N为一个磁道上的字节数目。</p><h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><p>2010年磁道：</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512428.png" alt="image-20211214163501891"></p><blockquote><p>1）</p><p>用位图法来表示磁盘空闲状态。说了16384（刚好每位表示一个磁盘的空闲状态。一共需要2KB。如果熟悉2进制的话知道2^14=16384刚好对应的是2KB。</p><p>2）<strong>沿着磁道号增大的方向移动</strong></p><p>这里的CSCAN默认为CLOOK 那么总共为20+90+20+40=170ms</p><p>ps：如果是换成LOOK算法的话那就是20+30+40+20=110ms</p><p><strong>计算部分</strong></p><p>T=寻到时间+旋转时间+传输时间</p><p>寻道时间=170ms。</p><p>旋转时间 1/2r  100r/s 1r-》10ms，那么旋转时间为5ms。总共旋转时间为5*4=20ms</p><p>传输时间：读取一个扇区所花时间为1r 100个磁道。0.01r=0.01*10=0.1ms，总是0.4ms</p><p>T=190.4ms</p><p>3） 有，FIFO先来先服务。因为不需要考虑寻道时间和旋转的延迟，直接按照I/O请求的先后顺序服务</p></blockquote><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512429.png" alt="image-20211214163517237"></p><blockquote><p>1,300x10x200x0.5kB=300MB</p><p>2,·85号柱面 85x10x200/2=85000号簇，先访问100260 101660 110560 60005</p><p>考察对簇号的计算。</p><p>3）<strong>这里的物理地址指的是磁盘地址</strong></p><p><font color="red">磁盘地址用：柱面号 盘面号 扇区号 来表示</font></p><p>100530/(10x200/2)=100号簇</p><p>530/100=5 5号磁道 扇区号 60号扇区</p><p>由磁盘驱动程序来完成磁盘到物理地址的转换</p></blockquote><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512430.png" alt="image-20211214173537037"></p><p>3000r/min=50r/s  20ms/r。读一个扇区需要2.5ms</p><p>读取时间=mxn+s    =2.5msx3=7.5ms，读取+传送时间</p><p>一整个扇区：<font color="red">包括了启动磁臂的时间</font>  总共为20/2+8*7.5=0.07s，因为总共有8块。</p><p>每个磁道的数据量为4KB</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512431.png" alt="image-20211214173550905"></p><h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><p>FCFS:先来先服务</p><p>SSTF：最短寻找时间优先。寻找与当前磁头最近的磁道</p><p>磁盘调度算法中，如果没有提到C-LOOK和LOOK算法。默认CSCAN和SCAN当做LOOK和CLOOK。</p><p>CLOOK：达到最远端后立即返回到最小的那个点<font color="red">（中间不停顿）</font>。然后再从最小的地方出发。</p><p>LOOK:相当于坐电梯，一步步地退回来。</p><p><strong>都不需要达到磁盘的端点</strong></p><p>CSCAN和SCAN需要达到磁盘的端点。</p><h2 id="第五章-I-O管理"><a href="#第五章-I-O管理" class="headerlink" title="第五章 I/O管理"></a>第五章 I/O管理</h2><h4 id="缓冲的计算问题"><a href="#缓冲的计算问题" class="headerlink" title="缓冲的计算问题"></a>缓冲的计算问题</h4><p>单缓冲： max（C（CPU处理时间）,T（从磁盘传入缓冲区时间））+M(从磁盘传入用户时间)</p><p>假设里面是满的，那么处理一块数据所需要的最短时间为1，C&gt;T,要等CPU处理完才能传送给用户，2，T&gt;C，要把缓冲区充满才能算一次数据块的处理。</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512432.png" alt="image-20211214185337470"><br><strong>看图会更好记忆一点</strong></p><p>双缓冲：max（C+M,T）</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512433.png" alt="image-20211214185704782"></p><p><strong>看图记忆法</strong></p><h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h3><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512434.png" alt="image-20211214190325709"></p><blockquote><p>11,    max(C,T)+M=120</p><p>12,max(C+M,T) D选项。</p></blockquote><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512435.png" alt="image-20211214190822218"></p><p><font color="red">14，出现多余的数字，50 100之类的，一定要注意，因为可能是自己忽略了某些东西</font></p><p>14：max(C,T)+M=150，则总共需要1500.然后再加上处理最后的数据</p><p>​        max（C+M,T）=100,10块需要1000ms，<strong>之后最后从缓冲区送到用户区的时间100ms再分析</strong></p><p>15题：最短：单缓冲 100（外设到缓冲）+100（一个外设到缓冲 一个再缓冲+工作）+100（M+C）=300.就是正常计算，</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora202202251512436.png" alt="image-20211214190832263"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 408 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2019/11/02/shu/"/>
      <url>/2019/11/02/shu/</url>
      
        <content type="html"><![CDATA[<h1 id="树-图"><a href="#树-图" class="headerlink" title="树 图"></a>树 图</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树的基本定义"><a href="#树的基本定义" class="headerlink" title="树的基本定义"></a>树的基本定义</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//二叉树的基本定义</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> TreeNode<span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    <span class="token keyword">struct</span> TreeNode <span class="token operator">*</span>rchild<span class="token punctuation">,</span><span class="token operator">*</span>lchild<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h4><p><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html" target="_blank" rel="noopener">https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html</a></p><p>参考的代码随想录</p><p>这里帮助大家确定下来递归算法的三个要素。</p><p><strong>每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</strong></p><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><p>这个引⽤符号 &amp; 要和C语⾔⾥⾯的取地址运算符 &amp; 区分开来，他们没有什么关系，cpp⾥⾯的引⽤是 </p><p><strong>指在变量名之前加⼀个 &amp; 符号，⽐如在函数传⼊的参数中 int &amp;a ，那么对这个引⽤变量 a 做的所有</strong> </p><p>操作都是直接对传⼊的原变量进⾏的操作，并没有像原来 int a ⼀样只是拷⻉⼀个副本（传值），</p><p>（具体参考柳诺）</p><p>树是通过递归顶一顶，构造一棵树基本上都是通过递归来构造，找到相似的递归结构才能构造</p><h3 id="94-树的中序遍历"><a href="#94-树的中序遍历" class="headerlink" title="94,树的中序遍历"></a>94,树的中序遍历</h3><p> 给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。 </p><p>中序遍历：左根右</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//  注意递归函数都要放在前面</span>    <span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>root<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>res<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//注意这里要＋&amp; 表示是对res的引用，不加的话返回不了正确的</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//如果root为nullpur 那么！root就运行 直接返回</span>        <span class="token comment" spellcheck="true">//递归 左中右 </span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>         res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//容器的基本操作，比数组方便得多 </span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义一个res的容器</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="101，对称二叉树"><a href="#101，对称二叉树" class="headerlink" title="101，对称二叉树"></a>101，对称二叉树</h3><p> 给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。 </p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>树的题目感觉很多都需要用到<strong>递归</strong>，递归往往是比较好的办法，要灵活掌握</p><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//树的本质是什么 递归 嘿嘿</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">panduan</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>l<span class="token punctuation">,</span>TreeNode <span class="token operator">*</span>r<span class="token punctuation">,</span><span class="token keyword">bool</span> <span class="token operator">&amp;</span>res<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>l<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>r<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>l<span class="token operator">&amp;&amp;</span>r<span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>l<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            res<span class="token operator">=</span><span class="token boolean">false</span> <span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">-</span><span class="token operator">></span>val<span class="token operator">!=</span>r<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span> res<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token function">panduan</span><span class="token punctuation">(</span>l<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>r<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">panduan</span><span class="token punctuation">(</span>l<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>r<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeNode <span class="token operator">*</span>l<span class="token operator">=</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span><span class="token operator">*</span>r<span class="token operator">=</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>        <span class="token keyword">bool</span> res<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token function">panduan</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>r<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="102-层序遍历"><a href="#102-层序遍历" class="headerlink" title="102 层序遍历"></a>102 层序遍历</h3><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。 </p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>正常用队列做</p><blockquote><p>注意：这里不是返回一个数组，而是返回一个数组的数组，<strong>思路没有问题，只是一些细节的地方需要改改</strong>，需要学习这种写法</p><pre class="line-numbers language-cpp"><code class="language-cpp"> error<span class="token operator">:</span> no viable conversion from returned value of type <span class="token string">'vector&lt;int>'</span> to function <span class="token keyword">return</span> type <span class="token string">'vector&lt;vector&lt;int>>'</span>从答案这里可以看出来还是有区别的输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h4 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//先写边界条件</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//根节点入队</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//它是里面还得再生成一个数组</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> size<span class="token operator">=</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>vector <span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//每次都新插入一个vector 然后再在里面写入数据 </span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                TreeNode <span class="token operator">*</span>top<span class="token operator">=</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                res<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>top<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//注意这种vector&lt;vector&lt;int>>的写法  [[3],[9,20],[15,7]]</span>            <span class="token comment" spellcheck="true">//  ret.back().push_back(node->val);</span>                q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>top<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span>                 q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>top<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>top<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//细节啊 </span>                q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>top<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//    lorder(root,res,q);</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//这个感觉写的更好一点，不用像答案那样 res.back().push_back()</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> result<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> size <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>vec<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103,二叉树的锯齿形层序遍历"></a>103,二叉树的锯齿形层序遍历</h3><p> 给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 </p><pre class="line-numbers language-cpp"><code class="language-cpp">输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>加个deep判断深度就行了。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">zigzagLevelOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        <span class="token keyword">int</span> deep<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> result<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            deep<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> size <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>deep<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>   <span class="token function">reverse</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>vec<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度</a></h3><p>给定一个二叉树，找出其最大深度。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509059.png" alt="1642668469603" style="zoom:50%;"><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p> 深度优先遍历,当前结点的最大深度等于左右子树最大深度的最大值加一  返回的结果是3 </p><h4 id="递归-DFS"><a href="#递归-DFS" class="headerlink" title="递归 DFS"></a><strong>递归</strong> DFS</h4><p>之后找个专题好好学学递归</p><p>秒，真的是太妙了，感觉就是能看懂，但是要自己写肯定就写不出来了</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 节点为空返回</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 左/右子树最大深度+1</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> Max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>r<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 节点为空返回</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        Max <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>Max<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 更新最大深度</span>        <span class="token function">DFS</span><span class="token punctuation">(</span>r<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> d<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 深搜左子树，深度+1</span>        <span class="token function">DFS</span><span class="token punctuation">(</span>r<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> d<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// // 深搜右子树，深度+1</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 树为空，最大深度为0</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">DFS</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从根节点深搜，初始深度为1</span>        <span class="token keyword">return</span> Max<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="层次遍历-BFS"><a href="#层次遍历-BFS" class="headerlink" title="层次遍历/BFS"></a>层次遍历/BFS</h4><p>和上一题一样 就改一点点地方</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span> queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        <span class="token keyword">int</span> deep<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> result<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            deep<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> size <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>deep<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>   <span class="token function">reverse</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>vec<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> deep<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. 二叉树的最小深度</a></h3><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509060.png" alt="1642918487443"></p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>和最大深度一样，不过有个需要注意的地方</p><p>另外这道题的关键是搞清楚递归结束条件</p><p>叶子节点的定义是左孩子和右孩子都为 null 时叫做叶子节点<br><strong>当 root 节点左右孩子都为空时，返回 1</strong><br><strong>当 root 节点左右孩子有一个为空时，返回不为空的孩子节点的深度</strong><br><strong>当 root 节点左右孩子都不为空时，返回左右孩子较小深度的节点值</strong></p><p> <strong>求二叉树的最小深度和求二叉树的最大深度的差别主要在于处理左右孩子不为空的逻辑。</strong> </p><p> 左右孩子都为空的节点才是叶子节点！ 一开始错了是因为只要有一个孩子为空就返回了，但实际需要两个都为空才返回</p><h4 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token operator">&amp;&amp;</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">&amp;&amp;</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//求最小深度时将Math.max换成Math.min即可，但要注意如果根节点的左或右子树为空的话是构不成子树的。而最小深度是要求从根节点到子树的。当左或右子树为空时，不符合要求。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自己模拟一下就能出来了。</p><h4 id="迭代（队列）"><a href="#迭代（队列）" class="headerlink" title="迭代（队列）"></a>迭代（队列）</h4><p>代码随想录</p><p> <strong>需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点</strong> </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> depth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> size <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            depth<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 记录最小深度</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 当左右孩子都为空的时候，说明是最低点的一层了，退出 这一句话</span>                    <span class="token keyword">return</span> depth<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> depth<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></h3><p> 给定一棵树的前序遍历 <code>preorder</code> 与中序遍历 <code>inorder</code>。请构造二叉树并返回其根节点。 </p><p>Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<br>Output: [3,9,20,null,null,15,7]</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>手算比较简单 关键是代码的实现，这种题目感觉还是得用递归，一个个找，直到pre和in相同</p><p>思路</p><p>对于任意一颗树而言，前序遍历的形式总是</p><p>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]<br>即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是</p><p>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]<br>只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。</p><p>这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。</p><p>细节</p><p>在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。<strong>我们可以考虑使用哈希表来帮助我们快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值）</strong>，（注意这里没有重复元素）值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 O(1)O(1) 的时间对根节点进行定位了。</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509061.png" alt="1642817908346"></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> index<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">myBuildTree</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> preorder<span class="token punctuation">,</span> <span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inorder<span class="token punctuation">,</span> <span class="token keyword">int</span> preorder_left<span class="token punctuation">,</span> <span class="token keyword">int</span> preorder_right<span class="token punctuation">,</span> <span class="token keyword">int</span> inorder_left<span class="token punctuation">,</span> <span class="token keyword">int</span> inorder_right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>preorder_left <span class="token operator">></span> preorder_right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 前序遍历中的第一个节点就是根节点</span>        <span class="token keyword">int</span> preorder_root <span class="token operator">=</span> preorder_left<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 在中序遍历中定位根节点</span>        <span class="token keyword">int</span> inorder_root <span class="token operator">=</span> index<span class="token punctuation">[</span>preorder<span class="token punctuation">[</span>preorder_root<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//在中序遍历中找到根节点，那么根节点左边就是左子树，右边就是右子树</span>        <span class="token comment" spellcheck="true">// 先把根节点建立出来</span>        TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>preorder_root<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 得到左子树中的节点数目</span>        <span class="token keyword">int</span> size_left_subtree <span class="token operator">=</span> inorder_root <span class="token operator">-</span> inorder_left<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 递归地构造左子树，并连接到根节点</span>        <span class="token comment" spellcheck="true">//下面的一部分看上面的图就能看出来了</span>        <span class="token comment" spellcheck="true">// 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span>        root<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> <span class="token function">myBuildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> preorder_left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preorder_left <span class="token operator">+</span> size_left_subtree<span class="token punctuation">,</span> inorder_left<span class="token punctuation">,</span> inorder_root <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 递归地构造右子树，并连接到根节点</span>        <span class="token comment" spellcheck="true">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span>        root<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> <span class="token function">myBuildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> preorder_left <span class="token operator">+</span> size_left_subtree <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preorder_right<span class="token punctuation">,</span> inorder_root <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inorder_right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    TreeNode<span class="token operator">*</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> preorder<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inorder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> preorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 构造哈希映射，帮助我们快速定位根节点</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            index<span class="token punctuation">[</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//key是中序遍历的值 value是对应的下标</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">myBuildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里表示的是左右的边界</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="106，中序和后序遍历"><a href="#106，中序和后序遍历" class="headerlink" title="106，中序和后序遍历"></a>106，中序和后序遍历</h3><p> 跟105题类似的思路，不过是后序遍历中最后一个结点是根节点，通过确定根结点然后将中序遍历中的左右子树划分开。<br>然后再在左右子树中递归地进行构造二叉树 </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//不知道哪里错了，显示内存出错，但别的应该问题不大</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> index<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">myBuildTree</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> postorder<span class="token punctuation">,</span> <span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inorder<span class="token punctuation">,</span> <span class="token keyword">int</span> postorder_left<span class="token punctuation">,</span> <span class="token keyword">int</span> postorder_right<span class="token punctuation">,</span> <span class="token keyword">int</span> inorder_left<span class="token punctuation">,</span> <span class="token keyword">int</span> inorder_right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>postorder_left <span class="token operator">></span> postorder_right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 后序遍历中的最后一个节点就是根节点</span>        <span class="token keyword">int</span> postorder_root <span class="token operator">=</span> postorder_right<span class="token punctuation">;</span>        <span class="token keyword">int</span> inorder_root <span class="token operator">=</span> index<span class="token punctuation">[</span>postorder<span class="token punctuation">[</span>postorder_root<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//找到最后一个节点</span>        TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>postorder_root<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size_left_subtree <span class="token operator">=</span> inorder_root <span class="token operator">-</span> inorder_left<span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> <span class="token function">myBuildTree</span><span class="token punctuation">(</span>postorder<span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> postorder_left<span class="token punctuation">,</span> postorder_left <span class="token operator">+</span> size_left_subtree<span class="token number">-1</span><span class="token punctuation">,</span> inorder_left<span class="token punctuation">,</span> inorder_root <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> <span class="token function">myBuildTree</span><span class="token punctuation">(</span>postorder<span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> postorder_left <span class="token operator">+</span> size_left_subtree <span class="token punctuation">,</span> postorder_right<span class="token number">-1</span><span class="token punctuation">,</span> inorder_root <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inorder_right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    TreeNode<span class="token operator">*</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> postorder<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inorder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> postorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 构造哈希映射，快速定位根节点</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            index<span class="token punctuation">[</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//key是中序遍历的值 value是对应的下标</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">myBuildTree</span><span class="token punctuation">(</span>postorder<span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里表示的是左右的边界</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> HashMap<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> TreeNode <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inorder<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> postorder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> inorder<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将中序遍历放到map中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">myBuildTree</span><span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> postorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> TreeNode <span class="token function">myBuildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inorder<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> postorder<span class="token punctuation">,</span> <span class="token keyword">int</span> inorder_left<span class="token punctuation">,</span> <span class="token keyword">int</span> inorder_right<span class="token punctuation">,</span> <span class="token keyword">int</span> postorder_left<span class="token punctuation">,</span> <span class="token keyword">int</span> postorder_right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>inorder_left <span class="token operator">></span> inorder_right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 根节点在后序遍历中的下标</span>        <span class="token keyword">int</span> postorder_root <span class="token operator">=</span> postorder_right<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 根节点在中序遍历中的根节点</span>        <span class="token keyword">int</span> inorder_root <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>postorder_root<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 左子树的长度</span>        <span class="token keyword">int</span> size_left_subtree <span class="token operator">=</span> inorder_root <span class="token operator">-</span> inorder_left<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 建立根节点</span>        TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>postorder_root<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">myBuildTree</span><span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> postorder<span class="token punctuation">,</span> inorder_left<span class="token punctuation">,</span> inorder_root <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> postorder_left<span class="token punctuation">,</span> postorder_left <span class="token operator">+</span> size_left_subtree <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">myBuildTree</span><span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> postorder<span class="token punctuation">,</span> inorder_root <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inorder_right<span class="token punctuation">,</span> postorder_left <span class="token operator">+</span> size_left_subtree<span class="token punctuation">,</span> postorder_right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. 二叉树展开为链表</a></h3><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p><p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>基本上树相关的题目就是迭代和递归了</p><h4 id="递归-4"><a href="#递归-4" class="headerlink" title="递归"></a>递归</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">flatten</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> l<span class="token punctuation">;</span>        <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> l<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            TreeNode <span class="token operator">*</span>prev <span class="token operator">=</span> l<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span>curr <span class="token operator">=</span> l<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            prev<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>            prev<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> curr<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> <span class="token operator">&amp;</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            l<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>观察可以发现将二叉树前序展开为链表，<strong>相当于把一A结点的左孩子L整个完整的树替换到此结点的右孩子R上(同时把此结点原来的右孩子R接到此节点左孩子L的最右结点的右孩子上)</strong>，然后将当前结点替换为此结点的右孩子(也就是原来的L)进行迭代(注意每次要将结点的左孩子设置为nullptr)。</p><p>前两种方法都借助前序遍历，前序遍历过程中需要使用栈存储节点。有没有空间复杂度是 O(1)O(1) 的做法呢？</p><p>注意到前序遍历访问各节点的顺序是根节点、左子树、右子树。如果一个节点的左子节点为空，则该节点不需要进行展开操作。如果一个节点的左子节点不为空，则该节点的左子树中的最后一个节点被访问之后，该节点的右子节点被访问。该节点的左子树中最后一个被访问的节点是左子树中的最右边的节点，也是该节点的前驱节点。因此，问题转化成寻找当前节点的前驱节点。</p><p>具体做法是，对于当前节点，如果其左子节点不为空，则在其左子树中找到最右边的节点，作为前驱节点，将当前节点的右子节点赋给前驱节点的右子节点，然后将当前节点的左子节点赋给当前节点的右子节点，并将当前节点的左子节点设为空。对当前节点处理结束后，继续处理链表中的下一个节点，直到所有节点都处理结束。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">flatten</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            TreeNode <span class="token operator">*</span>l<span class="token operator">=</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token operator">&amp;&amp;</span>l<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span>                l<span class="token operator">=</span>l<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//需要让root的right接到左子树的最右的子树这</span>                 l<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">=</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>                root<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">=</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>                root<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>           root<span class="token operator">=</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//其实自己去花几个图就能看出来了 它的好处在于空间复杂度为O（1）</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">543. 二叉树的直径</a></h3><p> 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 </p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509062.png" alt="1642854960270"></p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>采用DFS，最大的深度应该是左子树的最大深度+右子树的最大深度 然后+1 -1这种最好是到时候试试看最后的结果。</p><blockquote><p>  直径 = 左子树高度 + 右子树高度； 我理解应该是 (左树高度 - 1) + (右子树高度 - 1) ， 因为直径是边的个数，而非节点的个数。 </p></blockquote><p>把104结合起来，先是求得左右子树的最大深度，然后再加起来，与max相比较。</p><h4 id="递归（之后照着官方解答写一下）"><a href="#递归（之后照着官方解答写一下）" class="headerlink" title="递归（之后照着官方解答写一下）"></a>递归（<strong>之后照着官方解答写一下</strong>）</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//感觉还是不够简约 需要继续改进  </span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 节点为空返回</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 左/右子树最大深度+1</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">finddeep</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span>root<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>maxd<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxl<span class="token operator">=</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxr<span class="token operator">=</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">finddeep</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>maxd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">finddeep</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>maxd<span class="token punctuation">)</span><span class="token punctuation">;</span>        maxd<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>maxd<span class="token punctuation">,</span>maxr<span class="token operator">+</span>maxl<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span>  maxd<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">diameterOfBinaryTree</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxd<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">finddeep</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>maxd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//java版本</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> maxd<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">diameterOfBinaryTree</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> maxd<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">depth</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> Left <span class="token operator">=</span> <span class="token function">depth</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> Right <span class="token operator">=</span> <span class="token function">depth</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        maxd<span class="token operator">=</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>Left<span class="token operator">+</span>Right<span class="token punctuation">,</span>maxd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将每个节点最大直径(左子树深度+右子树深度)当前最大值比较并取大者</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>Left<span class="token punctuation">,</span>Right<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回节点深度</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">226. 翻转二叉树</a></h3><p>就正常翻转即可，换个位置</p><p>这里如果用中序遍历的话可能就会出错了，因为可能会翻转两次。这道题目感觉是能遍历基本上就能翻转（除了中序） </p><h4 id="递归-5"><a href="#递归-5" class="headerlink" title="递归"></a>递归</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>       <span class="token keyword">return</span> root<span class="token punctuation">;</span>            TreeNode<span class="token operator">*</span> i<span class="token operator">=</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>            root<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">=</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>            root<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//直接用swap(root->left,root->right)更快一点</span>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 右</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 左</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">// 中</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                node <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 节点处理逻辑</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">222. 完全二叉树的节点个数</a></h3><p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>直接按照普通二叉树来判断，全部遍历</p><p>1，<strong>确定递归函数的参数和返回值</strong></p><p>​    参数应该是root 和res 返回值是res 因为最后是返回节点个数</p><p>2，<strong>确定终止条件</strong></p><p>​    终止条件应该是！root，但遍历到的节点为空的时候就返回</p><p>3，<strong>确定单层递归逻辑</strong></p><p>相当于是中左右 因为之前已经判断了root不为0，那么就res++，之后再继续遍历左右子树</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>root<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>res<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        res<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">count</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">count</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">count</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="完全二叉树做法"><a href="#完全二叉树做法" class="headerlink" title="完全二叉树做法"></a>完全二叉树做法</h4><p>参考代码随想录</p><p>完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。</p><p>对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。</p><p>对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> left <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> right <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>        <span class="token keyword">int</span> leftHeight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> rightHeight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里初始为0是有目的的，为了下面求指数方便</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 求左子树深度</span>            left <span class="token operator">=</span> left<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>            leftHeight<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 求右子树深度</span>            right <span class="token operator">=</span> right<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>            rightHeight<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>leftHeight <span class="token operator">==</span> rightHeight<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">&lt;&lt;</span> leftHeight<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意(2&lt;&lt;1) 相当于2^2，所以leftHeight初始为0</span>        <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//当遍历到是满二叉树的时候那么可以直接2^x-1 然后再相加</span>        <span class="token keyword">return</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//左子树节点个数+右子树节点个数+1</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. 平衡二叉树</a></h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 </p></blockquote><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>计算左孩子的<strong>最大深度</strong>以及计算右孩子的<strong>最大深度</strong>，如果高度差大于1，那么就返回false 否则就返回true。</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509063.png" alt="1642922579488"></p><p>这里高度和深度的概念其实是不一样的，<strong>具体情况还是得依照它所给的例子去分析</strong></p><p>思路三步走</p><p>1，明确递归参数和返回值</p><p>递归的参数只有root 返回值为false或者true</p><p>2，确定终止条件 </p><p>终止条件就是全部都遍历完，然后有一个返回值</p><p>3，确定单层逻辑</p><p>对于每一个root，如果abs(左-右)&lt;=1，那么继续遍历它下面的子树，得到下面子树的返回值，否则&gt;1的话就直接返回false；</p><h4 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">Maxdepth</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">Maxdepth</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Maxdepth</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里加一不加一都一样的，因为是同时+1，但实际上</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">Maxdepth</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">Maxdepth</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token function">isBalanced</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="257-二叉树的所有路径好题啊"><a href="#257-二叉树的所有路径好题啊" class="headerlink" title="257. 二叉树的所有路径好题啊"></a><strong><a href="https://leetcode-cn.com/problems/binary-tree-paths/" target="_blank" rel="noopener">257. 二叉树的所有路径</a></strong>好题啊</h3><blockquote><p>以为只用了递归，其实还用了回溯 </p></blockquote><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509064.png" alt="1642923293931"></p><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p><strong>好好看看代码随想录的部分</strong></p><p>首先这里出现了[“1-&gt;2-&gt;5”,”1-&gt;3”]这个东西，那么应该是返回的字符串，如果说是[[132,12],[35,84]]那么应该是vector&lt;vector<int>&gt; ,这个之前做过类似的题目</int></p><p>所以这里应该要定义vector<string> ，然后是说从根节点到叶子节点的路径，显然就是dfs了，然后这里还需要用到回溯，因为需要不断地返回上一个节点。</string></p><p>感觉最后应该是return(root-&gt;string),这样不断地返回上一层。</p><p>方法一：深度优先搜索<br>思路与算法</p><p>最直观的方法是使用深度优先搜索。在深度优先搜索遍历二叉树时，我们需要考虑当前的节点以及它的孩子节点。</p><p>如果当前节点不是<strong>叶子节点</strong>，则在当前的路径末尾添加该节点，并继续递归遍历该节点的每一个孩子节点。<br>如果当前节点是<strong>叶子节点</strong>，则在当前路径末尾添加该节点后我们就得到了一条从根节点到叶子节点的路径，将该路径加入到答案即可</p><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">construct_paths</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span>root<span class="token punctuation">,</span>string path<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token operator">&amp;</span>allpath<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//path用来存储这条路径所有的节点</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>        path<span class="token operator">+</span><span class="token operator">=</span><span class="token function">to_string</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//int转string</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果两个都不是空节点的话,不能这样，这样是错的，有一个是不空也需要+ ->,应该要改成如果是叶子节点的话</span>            allpath<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 把路径加入到答案中</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>                path<span class="token operator">+</span><span class="token operator">=</span><span class="token string">"->"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当前节点不是叶子节点，继续递归遍历</span>                <span class="token function">construct_paths</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>path<span class="token punctuation">,</span>allpath<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">construct_paths</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>path<span class="token punctuation">,</span>allpath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">binaryTreePaths</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> allpath<span class="token punctuation">;</span>        <span class="token function">construct_paths</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span>allpath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> allpath<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="代码随想录-递归-回溯"><a href="#代码随想录-递归-回溯" class="headerlink" title="代码随想录 递归+回溯"></a>代码随想录 递归+回溯</h4><p><a href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html#%E9%80%92%E5%BD%92" target="_blank" rel="noopener">https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html#%E9%80%92%E5%BD%92</a></p><ol start="257"><li><p><strong>二叉树的所有路径</strong></p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509065.png" alt="1642925930485"></p></li></ol><p><strong>那么为什么使用了vector 结构来记录路径呢？</strong> 因为在下面处理单层递归逻辑的时候，要做回溯，使用vector方便来做回溯。</p><p>可能有的同学问了，我看有些人的代码也没有回溯啊。</p><p><strong>其实是有回溯的，只不过隐藏在函数调用时的参数赋值里</strong>，下文我还会提到。</p><p>这里我们先使用vector结构的path容器来记录路径</p><p>回溯：返回之前的地方再重新进行计算</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">traversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> cur<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> path<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//这里注意是对原来的path的引用，只有这样才能够实现回溯</span>        path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这才到了叶子节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> cur<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            string sPath<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                sPath <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                sPath <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">"->"</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            sPath <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>path<span class="token punctuation">[</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>sPath<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> path<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>            path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 回溯</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">traversal</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> path<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>            path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 回溯 把</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">binaryTreePaths</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> result<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> path<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token function">traversal</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> path<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">112. 路径总和</a></h3><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p><p>叶子节点 是指没有子节点的节点</p><blockquote><p>相似的一道题</p></blockquote><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509066.png" alt="1642928630284"></p><h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">allpath</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root <span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span>path<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span>res<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//说明是叶子节点</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>                sum<span class="token operator">+</span><span class="token operator">=</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">allpath</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>path<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>            path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">allpath</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>path<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>            path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> targetSum<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> path<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//path用来保存路径 res用来保存所有路径的值</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token function">allpath</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>path<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>targetSum<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. 路径总和 II</a></h3><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509067.png" alt="1643179897001"></p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>和上一题的区别就是在于它要把所有的路径都写出来，并且放到pathsum函数中，这个与之前做过的某一道题相似，可以写成path.push_back(res)这么写感觉更加形象一点。</p><h4 id="深度遍历DFS"><a href="#深度遍历DFS" class="headerlink" title="深度遍历DFS"></a>深度遍历DFS</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">findall</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>path<span class="token punctuation">,</span><span class="token keyword">int</span> targetSum<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token operator">&amp;</span>res<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>        path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果是叶子节点的话</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> size<span class="token operator">=</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            sum<span class="token operator">+</span><span class="token operator">=</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token operator">==</span>targetSum<span class="token punctuation">)</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>             <span class="token function">findall</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>path<span class="token punctuation">,</span>targetSum<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">findall</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>path<span class="token punctuation">,</span>targetSum<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">pathSum</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> targetSum<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> path<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token function">findall</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>path<span class="token punctuation">,</span>targetSum<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">404. 左叶子之和</a></h3><p> 计算给定二叉树的所有左叶子之和。 </p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509068.png" alt="1642928761136"></p><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>1，确定递归参数和返回值</p><p>递归参数，左右子树，返回值和相加</p><p>2，确定终止条件</p><p>！root 还是得到叶节点才知道需不需要加，如果只有右节点还是得继续遍历</p><p>3，确定单层逻辑。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> lv<span class="token operator">=</span><span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//左子树的左叶子之和</span>        <span class="token keyword">int</span> rv<span class="token operator">=</span><span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//右子树左叶子之和</span>        <span class="token keyword">int</span> mv<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//说明是左节点</span>            mv<span class="token operator">=</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">;</span>        <span class="token keyword">int</span> sum<span class="token operator">=</span>mv<span class="token operator">+</span>lv<span class="token operator">+</span>rv<span class="token punctuation">;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//更加简洁 </span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token operator">&amp;&amp;</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">==</span><span class="token constant">NULL</span><span class="token operator">&amp;&amp;</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>             <span class="token keyword">return</span> <span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token operator">+</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">sumOfLeftLeaves</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a href="https://leetcode-cn.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">654. 最大二叉树</a></h3><p>给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:</p><p>创建一个根节点，其值为 nums 中的最大值。<br>递归地在最大值 左边 的 子数组前缀上 构建左子树。<br>递归地在最大值 右边 的 子数组后缀上 构建右子树。<br>返回 nums 构建的 最大二叉树 。</p><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><p>这个其实就是<strong>先序遍历</strong>，先构建根节点再构建左子树和右子树。</p><p>有点类似于中序遍历和后序遍历构造二叉树，这道题目不难，主要就找到一些边界条件,这里<strong>注意一下</strong>带入的是0和n-1，然后如果left&gt;right那么就会返回，就直接代入下标了，不然可能会出现数组越界的现象</p><p>分治法构建二叉树，左边一个右边一个。</p><h4 id="递归构建二叉树"><a href="#递归构建二叉树" class="headerlink" title="递归构建二叉树"></a>递归构建二叉树</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">createtree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">></span>right<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//这个条件要注意一下</span>        <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max<span class="token operator">=</span>INT_MIN<span class="token punctuation">;</span>        <span class="token keyword">int</span> loc<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>left<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>right<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>max<span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                max<span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                loc<span class="token operator">=</span>i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//找到最大值</span>        TreeNode <span class="token operator">*</span>root<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//TreeNode* node = new TreeNode(0);如果不知道可以初始化为0，如果初始化为-1说明还得再加一个</span>        root<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">=</span><span class="token function">createtree</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>left<span class="token punctuation">,</span>loc<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">=</span><span class="token function">createtree</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>loc<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    TreeNode<span class="token operator">*</span> <span class="token function">constructMaximumBinaryTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> size<span class="token operator">=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">createtree</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>size<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树</a></h3><p> 给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。 </p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509069.png" alt="1642858943926"></p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>这道题目还是好好看官方答案解析吧，其实看懂了就会了,G(n)</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509071.png" alt="1642860127985"></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">G</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        G<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        G<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> i<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                G<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> G<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> G<span class="token punctuation">[</span>i <span class="token operator">-</span> j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> G<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h4><p>卡特兰数<br>$$<br>C_0=1 \qquad C_n=\frac{2(2n+1)}{n+2}<br>$$</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numTrees</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> C <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            C <span class="token operator">=</span> C <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>C<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></h3><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><p>构建一个vector容器，按照中序遍历依次输入到vector中，然后再来一个for循环，如果对于任意 满足res[i]&lt;res[i+1] return true 否则 return false。</p><h4 id="递归-6"><a href="#递归-6" class="headerlink" title="递归"></a>递归</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span>root<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>res<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//这里是引用</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size<span class="token operator">=</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>size<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token number">-1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span>res<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//这里注意一下是等于 222 就不满足 需要严格大于</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>还有一种思路是直接用一个指针代替前面的val然后再比较，这样的话会快很多，而且空间复杂度不要那么高,这里不能用int，只能用long，因为太大 了</p><p>先看左子树，然后赋值，再看右子树</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">long</span> pre <span class="token operator">=</span> LONG_MIN<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 前一节点设为最小值</span>    <span class="token keyword">bool</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 验证左子树        </span>            <span class="token keyword">if</span><span class="token punctuation">(</span>pre <span class="token operator">&lt;</span> root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 前一节点(当前节点左子树最大值)小于当前节点</span>                pre <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 前一节点变为当前节点</span>                <span class="token keyword">return</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 验证右子树</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>LONG_MAX LONG_MIN </p><p>INT_MAX INT_MIN  这种还是挺方便的 </p></blockquote><h3 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">700. 二叉搜索树中的搜索</a></h3><p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。</p><p>你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509072.png" alt="1643183984991"></p><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><p>1，参数，root val 返回值 root</p><p>2，终止条件 读到树底了或者说是读到了root-&gt;val==val</p><p>3，<strong>单层逻辑</strong> 等于的时候就返回root，大于往右读 小于往左读 然后要返回nullpur 不然不能返回所有的值</p><h4 id="递归-7"><a href="#递归-7" class="headerlink" title="递归"></a>递归</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//读到底还没命中就返回错误了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>val<span class="token operator">==</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>val<span class="token operator">></span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>val<span class="token operator">&lt;</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener">530. 二叉搜索树的最小绝对差</a></h3><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><p>说的任意两个不同节点值，由于是二叉搜索树，是按照顺序来的，所以其实只要按照左中右的中序遍历就可以了</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">findmin</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>root<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>pre<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>minroot<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token function">findmin</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>pre<span class="token punctuation">,</span>minroot<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//左</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>pre<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            pre<span class="token operator">=</span>root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//先找到最后面的值 </span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            minroot<span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>minroot<span class="token punctuation">,</span>root<span class="token operator">-</span><span class="token operator">></span>val<span class="token operator">-</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//pre表示的是前一个节点  中间一部分是对根节点的操作</span>            pre <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">findmin</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>pre<span class="token punctuation">,</span>minroot<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//右</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">getMinimumDifference</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> minroot<span class="token operator">=</span>INT_MAX<span class="token punctuation">;</span>        <span class="token keyword">int</span> pre<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">findmin</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>pre<span class="token punctuation">,</span>minroot<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> minroot<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a><a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/" target="_blank" rel="noopener">501. 二叉搜索树中的众数</a></h3><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 任意顺序 返回。</p><p>假定 BST 满足如下定义：</p><p>结点左子树中所含节点的值 小于等于 当前节点的值<br>结点右子树中所含节点的值 大于等于 当前节点的值<br>左子树和右子树都是二叉搜索树</p><h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><p>1，建立一个哈希表，construct_map,之后遍历哈希表，找到那个众数max_value，再遍历一遍，把value值等于众数的key push进res中，res就是对应的需要返回的数组</p><h4 id="非二叉搜索树解法"><a href="#非二叉搜索树解法" class="headerlink" title="非二叉搜索树解法"></a>非二叉搜索树解法</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">constructmap</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>root<span class="token punctuation">,</span>unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span>map<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>        map<span class="token punctuation">[</span>root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">constructmap</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">constructmap</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">findMode</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> map<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token function">constructmap</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//构造哈希表</span>        <span class="token keyword">int</span> size<span class="token operator">=</span>map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxvalue<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>key<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span>p<span class="token operator">:</span>map<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//遍历哈希表,找到那个最大值</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>second<span class="token operator">></span>maxvalue<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                maxvalue<span class="token operator">=</span>p<span class="token punctuation">.</span>second<span class="token punctuation">;</span>                key<span class="token operator">=</span>p<span class="token punctuation">.</span>first<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span>p<span class="token operator">:</span>map<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//遍历哈希表</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>second<span class="token operator">==</span>maxvalue<span class="token punctuation">)</span>            <span class="token punctuation">{</span>               res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把key放进去</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//补充一个更快速的解法，参照了代码随想录</span><span class="token comment" spellcheck="true">/*主要是遍历的部分变快了 可以少一步循环        for(auto&amp;p:map)//遍历哈希表,找到那个最大值        {            if(p.second==maxvalue)             res.push_back(p.first);//把key放进去            if(p.second>maxvalue)            {                res.clear();  //这一步是关键 如果发现不是那么就清空                maxvalue=p.second;                key=p.first;                res.push_back(p.first);//把key放进去            }     */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="代码随想录-1"><a href="#代码随想录-1" class="headerlink" title="代码随想录"></a>代码随想录</h4><p>2，搜索树解法：直接建立，左中右，如果相同就count++</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> maxCount<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 最大频率</span>    <span class="token keyword">int</span> count<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 统计频率</span>    TreeNode<span class="token operator">*</span> pre<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> result<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span>        <span class="token function">searchBST</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 左</span>                                    <span class="token comment" spellcheck="true">// 中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 第一个节点</span>            count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pre<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">==</span> cur<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 与前一个节点数值相同</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 与前一个节点数值不同</span>            count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        pre <span class="token operator">=</span> cur<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 更新上一个节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> maxCount<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果和最大值相同，放进result中</span>            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> maxCount<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果计数大于最大值频率</span>            maxCount <span class="token operator">=</span> count<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 更新最大频率</span>            result<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 很关键的一步，不要忘记清空result，之前result里的元素都失效了</span>            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">searchBST</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 右</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">findMode</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        maxCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> pre <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 记录前一个节点</span>        result<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">searchBST</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a></h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509073.png" alt="1643269918208"></p><h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h4><p>首先我们要找到p，q节点的路径，返回一个vector<int> path ,然后再构造哈希表，或者数组，之后再一个个地去比较，找到深度最深的那个公共祖先。<strong>这道题目的正经做法应该是回溯的</strong>。</int></p><p>错误示范//不写了 太丢脸了 好好学学人家</p><h4 id="参考的"><a href="#参考的" class="headerlink" title="参考的"></a>参考的</h4><p> 因为是递归，<strong>使用函数后可认为左右子树已经算出结果</strong>，这句话要记住，道出了递归的精髓 </p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509074.png" alt="1643274571181"></p><p>代码简洁明了</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> p<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> p <span class="token operator">||</span> root <span class="token operator">==</span> q<span class="token punctuation">)</span>             <span class="token keyword">return</span> root<span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> left <span class="token operator">=</span>  <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//说明不在左边</span>            <span class="token keyword">return</span> right<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//说明不在右边</span>            <span class="token keyword">return</span> left<span class="token punctuation">;</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&amp;&amp;</span> right<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// p和q在两侧</span>            <span class="token keyword">return</span> root<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 必须有返回值 不然会报错，很多题目都会出现这种不能全部打出来的情况</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>作者：Wilson79链接：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>leetcode<span class="token operator">-</span>cn<span class="token punctuation">.</span>com<span class="token operator">/</span>problems<span class="token operator">/</span>lowest<span class="token operator">-</span>common<span class="token operator">-</span>ancestor<span class="token operator">-</span>of<span class="token operator">-</span>a<span class="token operator">-</span>binary<span class="token operator">-</span>tree<span class="token operator">/</span>solution<span class="token operator">/</span>c<span class="token operator">-</span>jing<span class="token operator">-</span>dian<span class="token operator">-</span>di<span class="token operator">-</span>gui<span class="token operator">-</span>si<span class="token operator">-</span>lu<span class="token operator">-</span>fei<span class="token operator">-</span>chang<span class="token operator">-</span>hao<span class="token operator">-</span>li<span class="token operator">-</span>jie<span class="token operator">-</span>shi<span class="token operator">-</span><span class="token operator">/</span>来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">235. 二叉搜索树的最近公共祖先</a></h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h4><p>由于树是二叉搜索树，那么可以利用二叉搜索树的性质，即左子树的结点的值都小于根结点，右子树的结点都大于根结点。可以分为3种情况。</p><p>1.若p的值小于root的值，q的值大于根的值，那么root就是最近公共祖先。<br>2.若p的值和q的值都小于root的值，那么代表最近祖先一定在root的左子树中<br>3.若p的值和q的值都大于root的值，那么代表最近祖先一定在root的右子树中<br>2.3情况发生的话，只需要继续递归即可，而 1则是递归出口。</p><h4 id="递归-8"><a href="#递归-8" class="headerlink" title="递归"></a>递归</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> p<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span>q<span class="token operator">||</span>root<span class="token operator">==</span>p<span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>val<span class="token operator">>=</span>p<span class="token operator">-</span><span class="token operator">></span>val<span class="token operator">&amp;&amp;</span>root<span class="token operator">-</span><span class="token operator">></span>val<span class="token operator">>=</span>q<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>val<span class="token operator">&lt;=</span>p<span class="token operator">-</span><span class="token operator">></span>val<span class="token operator">&amp;&amp;</span>root<span class="token operator">-</span><span class="token operator">></span>val<span class="token operator">&lt;=</span>q<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//它这个是返回来一个最近的值 就是两边都满足了 不断地返回最接近的root</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">701. 二叉搜索树中的插入操作</a></h3><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p><h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h4><p>只需要在叶子节点这里删除就可以了</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">insertIntoBST</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">></span> val<span class="token punctuation">)</span> root<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> <span class="token function">insertIntoBST</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">&lt;</span> val<span class="token punctuation">)</span> root<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> <span class="token function">insertIntoBST</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里返回的root其实就是原来的root->right,和root->left 这里有点难理解，模拟一下就出来了。</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="迭代-3"><a href="#迭代-3" class="headerlink" title="迭代"></a>迭代</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">insertIntoBST</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            TreeNode <span class="token operator">*</span>node<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        TreeNode <span class="token operator">*</span>cur<span class="token operator">=</span>root<span class="token punctuation">;</span>        TreeNode <span class="token operator">*</span>parent<span class="token operator">=</span>root<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            parent<span class="token operator">=</span>cur<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//保存父节点</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>val<span class="token operator">></span>val<span class="token punctuation">)</span> cur<span class="token operator">=</span>cur<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>            <span class="token keyword">else</span> cur<span class="token operator">=</span>cur<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        TreeNode <span class="token operator">*</span>node<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>parent<span class="token operator">-</span><span class="token operator">></span>val<span class="token operator">></span>val<span class="token punctuation">)</span>        parent<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">=</span>node<span class="token punctuation">;</span>        <span class="token keyword">else</span> parent<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">=</span>node<span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">450. 删除二叉搜索树中的节点</a></h3><h4 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h4><p>根据二叉搜索树的性质</p><p>如果目标节点大于当前节点值，则去右子树中删除；<br>如果目标节点小于当前节点值，则去左子树中删除；<br>如果目标节点就是当前节点，分为以下三种情况：<br>其无左子：其右子顶替其位置，删除了该节点；<br>其无右子：其左子顶替其位置，删除了该节点；<br>其左右子节点都有：其左子树转移到其右子树的最左节点的左子树上，然后右子树顶替其位置，由此删除了该节点。</p><p>之前也有链表删除的题目</p><p><strong>删除的本质是返回root节点的左节点或者右节点</strong>，就像是链表的题，返回的是假设进入的是p，那么返回的是p-&gt;next，那么p就被删除了，当然正常还应该加个free（），但好像lc都没加</p><h4 id="参考的递归"><a href="#参考的递归" class="headerlink" title="参考的递归"></a>参考的递归</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">></span> root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span>    root<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 去右子树删除</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span>    root<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 去左子树删除</span>        <span class="token keyword">else</span>    <span class="token comment" spellcheck="true">// 当前节点就是要删除的节点</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span>   <span class="token keyword">return</span> root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 情况1，欲删除节点无左子</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span>  <span class="token keyword">return</span> root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 情况2，欲删除节点无右子</span>            TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 情况3，欲删除节点左右子都有 </span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">// 寻找欲删除节点右子树的最左节点</span>                node <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>            node<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将欲删除节点的左子树成为其右子树的最左节点的左子树</span>            root <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 欲删除节点的右子顶替其位置，节点被删除</span>            <span class="token comment" spellcheck="true">//这里也可以直接返回root->right 不返回root 也相当于被删除了 return root->right;  </span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/" target="_blank" rel="noopener">669. 修剪二叉搜索树</a></h3><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509075.png" alt="1643355350843"></p><h4 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h4><p>这道题目其实就是删除二叉树中的节点的加强版，只不过不是删除一个节点，而是删除一些节点。就还是返照上面的去做就好了。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">=</span><span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">=</span><span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>val<span class="token operator">&lt;</span>low<span class="token operator">||</span>root<span class="token operator">-</span><span class="token operator">></span>val<span class="token operator">></span>high<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//确定是要删除的节点</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span>   <span class="token keyword">return</span> root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 情况1，欲删除节点无左子</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span>  <span class="token keyword">return</span> root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 情况2，欲删除节点无右子</span>            TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 情况3，欲删除节点左右子都有 </span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">// 寻找欲删除节点右子树的最左节点</span>                node <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>            node<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将欲删除节点的左子树成为其右子树的最左节点的左子树</span>            <span class="token keyword">return</span> root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 欲删除节点的右子顶替其位置，节点被删除</span>            <span class="token comment" spellcheck="true">//这里也可以直接返回root->right 不返回root 也相当于被删除了 return root->right;  </span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="代码随想录-2"><a href="#代码随想录-2" class="headerlink" title="代码随想录"></a>代码随想录</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">&lt;</span> low<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">></span> high<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">108. 将有序数组转换为二叉搜索树</a></h3><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p><p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509076.png" alt="1643356655425"></p><h4 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h4><p>每次都找中间节点，中间节点的左边构造左子树，中间节点的右边构造右子树,具体可以参照654，先序遍历构造二叉树，先根节点再左右子树</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//构造树基本上就是</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">=</span><span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">=</span><span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="递归-9"><a href="#递归-9" class="headerlink" title="递归"></a>递归</h4><p>这里可以发现，传入数据里面是没有root的，因为如果有root的话需要重新去定义，</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">cnostruct_tree</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果是这样的话会报错的，因为root->left并不存在，所以我们不需要传入root->left，直接传入(nums,low,mid-1)，然后再在函数里面去建立Treenode就可以了，654里面中也没有传入root，说明构建</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>构建二叉树的题目不需要传入root-&gt;left或者root-&gt;right,直接在里面进行创建就行了</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode <span class="token operator">*</span><span class="token function">construct_tree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>nums<span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">></span>high<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid<span class="token operator">=</span><span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        TreeNode <span class="token operator">*</span>root<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>val<span class="token operator">=</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">=</span><span class="token function">construct_tree</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>low<span class="token punctuation">,</span>mid<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">=</span><span class="token function">construct_tree</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里需要注意一下需要排除掉mid，即变成mid+1和mid-1</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    TreeNode<span class="token operator">*</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> size<span class="token operator">=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode <span class="token operator">*</span>root<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token operator">=</span><span class="token function">construct_tree</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>size<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">538. 把二叉搜索树转换为累加树</a></h3><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><p>节点的左子树仅包含键 小于 节点键的节点。<br>节点的右子树仅包含键 大于 节点键的节点。<br>左右子树也必须是二叉搜索树。</p><p><img src="https://lzjtypora.oss-cn-beijing.aliyuncs.com/imgtypora/202202251509077.png" alt="1643358490718"></p><h4 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h4><p>首先先确定是中序遍历，左&gt;中&gt;右。但似乎这道题目是要累加，可以定义一个数组，先访问右子树，然后压进去，再根 再左子树，然后每次再累加，依次类推。</p><p>感觉这道题目也可以利用栈来做，直接记录栈的值就行，或者直接累加试试，记录sum的值。</p><p><strong>反中序</strong> 其实看一眼就发现了</p><h4 id="递归，数组"><a href="#递归，数组" class="headerlink" title="递归，数组"></a>递归，数组</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">transTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>nums<span class="token punctuation">,</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//这里注意 &amp;nums 这里是引用，而不是单纯地取值，因为如果单纯地取值的话返回时是返回前一个num，即空数组 那么就不变了</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">=</span><span class="token function">transTree</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//右</span>        nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//中  把之前记录的数据全部累加</span>        <span class="token keyword">int</span> size<span class="token operator">=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token number">-1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            root<span class="token operator">-</span><span class="token operator">></span>val<span class="token operator">+</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        root<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">=</span><span class="token function">transTree</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//左</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    TreeNode<span class="token operator">*</span> <span class="token function">convertBST</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">transTree</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="递归，sum求和"><a href="#递归，sum求和" class="headerlink" title="递归，sum求和"></a>递归，sum求和</h4><p>递归三部曲：</p><p>1，返回值：root，调用参数：root和sum</p><p>2，终止条件： 读到空节点 ！root return nullptr</p><p>3,中间逻辑，root-&gt;left =;//<strong>因为返回的是节点 所以肯定是root的叶子节点等于巴拉巴拉之类的</strong> 然后这里发现最好是先遍历右子树，然后从后往前依次累加即可</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">transTree</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>sum<span class="token punctuation">,</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">=</span><span class="token function">transTree</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        sum<span class="token operator">+</span><span class="token operator">=</span>root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>val<span class="token operator">=</span>sum<span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">=</span><span class="token function">transTree</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    TreeNode<span class="token operator">*</span> <span class="token function">convertBST</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">transTree</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行时间 击败80%  内存消耗 击败 90% 因为这里不需要定义数组了  时间空间复杂度都是O（n）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="栈，递归"><a href="#栈，递归" class="headerlink" title="栈，递归"></a>栈，递归</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//栈反中序</span><span class="token keyword">struct</span> TreeNode<span class="token operator">*</span> <span class="token function">convertBST</span><span class="token punctuation">(</span><span class="token keyword">struct</span> TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> TreeNode<span class="token operator">*</span><span class="token operator">*</span> stack <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> TreeNode<span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> TreeNode<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> num<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> TreeNode<span class="token operator">*</span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">||</span> top<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>            stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        p <span class="token operator">=</span> stack<span class="token punctuation">[</span>top<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        num <span class="token operator">+</span><span class="token operator">=</span> p<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">;</span>        p<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">=</span> num<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
