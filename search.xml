<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++基础</title>
      <link href="/2022/02/23/C-%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/02/23/C-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;hello world&quot;</span> &lt;&lt;n+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cin表示输入；cout表示输出 ；endl表示换行</p><h3 id="基本头文件"><a href="#基本头文件" class="headerlink" title="基本头文件"></a>基本头文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostraem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="comment">//相当于是把.h改为了前面＋c</span></span><br></pre></td></tr></table></figure><h3 id="数组的相关表示"><a href="#数组的相关表示" class="headerlink" title="数组的相关表示"></a>数组的相关表示</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num.<span class="built_in">size</span>() <span class="comment">//表示数组的长度</span></span><br></pre></td></tr></table></figure><h3 id="string类的基本操作"><a href="#string类的基本操作" class="headerlink" title="string类的基本操作"></a>string类的基本操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string s1=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">string s2;</span><br><span class="line">cin &gt;&gt; s1;  <span class="comment">//注意用cin读入字符串的时候是以空格为分隔符</span></span><br><span class="line">cout &lt;&lt;s1; <span class="comment">//基本输入输出</span></span><br><span class="line"><span class="built_in">getline</span>(cin,s)<span class="comment">//读一行的字符串包括空格</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">length</span>() <span class="comment">//输出字符串的长度</span></span><br></pre></td></tr></table></figure><p>s.length用来表述字符的长度。</p><p>string 中还有个很常⽤的函数叫做 substr ，作⽤是截取某个字符串中的⼦串，⽤法有两种形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s2 = s.<span class="built_in">substr</span>(<span class="number">4</span>); <span class="comment">// 表示从下标4开始⼀直到结束</span></span><br><span class="line">string s3 = s.<span class="built_in">substr</span>(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 表示从下标5开始，3个字符</span></span><br></pre></td></tr></table></figure><p>C++的引⽤&amp;和传值的区别<br>这个引⽤符号 &amp; 要和C语⾔⾥⾯的取地址运算符 &amp; 区分开来，他们没有什么关系，C++⾥⾯的引⽤是指在变量名之前加⼀个 &amp; 符号，⽐如在函数传⼊的参数中 int &amp;a ，那么对这个引⽤变量 a 做的所有操作都是直接对传⼊的原变量进⾏的操作，并没有像原来 int a ⼀样只是拷⻉⼀个副本（传值），举两个例⼦：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> &amp;a)</span> <span class="comment">//都会传给之前的n</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a=<span class="number">99</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fun</span>(n);</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl; <span class="comment">//输出结果为99</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a=<span class="number">99</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fun</span>(n);</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl; <span class="comment">//输出结果为0 还是不变，只是拷贝了一个对应的值</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="string类的clear-x2F-erase-x2F-back-x2F-pop-back之类的"><a href="#string类的clear-x2F-erase-x2F-back-x2F-pop-back之类的" class="headerlink" title="string类的clear&#x2F;erase&#x2F;back&#x2F;pop_back之类的"></a>string类的clear&#x2F;erase&#x2F;back&#x2F;pop_back之类的</h4><p><a href="https://blog.csdn.net/cainv89/article/details/48102991">https://blog.csdn.net/cainv89/article/details/48102991</a></p><h3 id="struct结构体的应用"><a href="#struct结构体的应用" class="headerlink" title="struct结构体的应用"></a>struct结构体的应用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BiNode</span>()&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiNode</span> *rchild,*lchild;</span><br><span class="line">&#125;BiNode;</span><br><span class="line">BiNode root,root[<span class="number">10</span>]; <span class="comment">//不需要加别的</span></span><br></pre></td></tr></table></figure><h3 id="STL相关"><a href="#STL相关" class="headerlink" title="STL相关"></a>STL相关</h3><p>​    这个属于是重难点了。自己做的话估计会比较难，还是从题目中取慢慢地领会其中的做法吧。加油加油。</p><h4 id="sort的使用："><a href="#sort的使用：" class="headerlink" title="sort的使用："></a>sort的使用：</h4><p><img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1640680089552.png" alt="1640680089552"></p><p><img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1640680117931.png" alt="1640680117931"></p><p>简单概括就是排序</p><p> vertor用sort (v.begin()，v.end（))</p><p>数组使用sort（a，a+n） <u>默认从小到大</u></p><p>如果是要从大到小则需要加一个bool型的cmp函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">4</span>]=&#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="built_in">sort</span>(a,a+<span class="number">4</span>,cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        cout &lt;&lt; a[i] ;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>empty函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; nums = &#123; <span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">empty</span>()) <span class="comment">//判断是不是空，如果是空的话就运行，不是空的话就不运行</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ture&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt;<span class="string">&quot;false&quot;</span>;  <span class="comment">//这个不是空，所以运行false</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>auto的用法：</p><p>补充： 意思是将t容器中的每一个元素从前往后枚举出来，并用 count 来表示，类似于Java中的 for each 语句 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123; <span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> count:nums)</span><br><span class="line">    cout &lt;&lt; count &lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">//注意这里是count不是nums</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);<span class="comment">//输出为 0 2 1 1 0 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="unordered-map-unordered-set-map和set的用法和区别"><a href="#unordered-map-unordered-set-map和set的用法和区别" class="headerlink" title="unordered_map,unordered_set,map和set的用法和区别"></a>unordered_map,unordered_set,map和set的用法和区别</h3><p><a href="http://www.javashuo.com/article/p-zzwukzrv-hz.html">http://www.javashuo.com/article/p-zzwukzrv-hz.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/296360525">https://zhuanlan.zhihu.com/p/296360525</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;key&gt; map&lt;key,value&gt;</span><br><span class="line"><span class="comment">//unordered指无序</span></span><br></pre></td></tr></table></figure><p>set一般用于去重（），map一般用于快速查询，find</p><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>在 C++ 中，每一个对象都能通过 <strong>this</strong> 指针来访问自己的地址。<strong>this</strong> 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。</p><p>友元函数没有 <strong>this</strong> 指针，因为友元不是类的成员。只有成员函数才有 <strong>this</strong> 指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setname</span><span class="params">(<span class="type">char</span> *name)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setage</span><span class="params">(<span class="type">int</span> age)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setscore</span><span class="params">(<span class="type">float</span> score)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::setname</span><span class="params">(<span class="type">char</span> *name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::setage</span><span class="params">(<span class="type">int</span> age)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::setscore</span><span class="params">(<span class="type">float</span> score)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="keyword">this</span>-&gt;name&lt;&lt;<span class="string">&quot;名字是&quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;age&lt;&lt;<span class="string">&quot;年龄是&quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;score&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student *pstu = <span class="keyword">new</span> Student;</span><br><span class="line">    pstu -&gt; <span class="built_in">setname</span>(<span class="string">&quot;lihua&quot;</span>);</span><br><span class="line">    pstu -&gt; <span class="built_in">setage</span>(<span class="number">16</span>);</span><br><span class="line">    pstu -&gt; <span class="built_in">setscore</span>(<span class="number">96.5</span>);</span><br><span class="line">    pstu -&gt; <span class="built_in">show</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以this是被调用对象访问调用他的对象的工</p><p>具，可以理解为this指向调用他的对象。默认情况下，this的类型是指向类类型非常量的常量指针，所以默认情况下，初始化时，我们不能把this绑定到</p><p>一个常量对象上去，因此，在参数列表的后面加上 const 修改this的属性，让其可以指向一个常量对象，可以增加函数的灵活性，这个成员函数也叫常</p><p>量成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res=<span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();<span class="comment">//表示调用了pop这个函数，指向了调用他的结果</span></span><br></pre></td></tr></table></figure><h3 id="stl之队列和栈"><a href="#stl之队列和栈" class="headerlink" title="stl之队列和栈"></a>stl之队列和栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span><span class="comment">// 队列 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span><span class="comment">//栈</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义方式</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt;  s;<span class="comment">//参数也是数据类型，这是栈的定义方式</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt;  q; <span class="comment">//参数是数据类型，这是队列的定义方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈</span></span><br><span class="line">s.<span class="built_in">empty</span>()<span class="comment">//如果栈为空返回true，否则返回false  </span></span><br><span class="line">s.<span class="built_in">size</span>()<span class="comment">//返回栈中元素的个数  </span></span><br><span class="line">s.<span class="built_in">pop</span>()<span class="comment">//删除栈顶元素但不返回其值  </span></span><br><span class="line">s.<span class="built_in">top</span>()<span class="comment">//返回栈顶的元素，但不删除该元素  </span></span><br><span class="line">s.<span class="built_in">push</span>(X)<span class="comment">//在栈顶压入新元素 ，参数X为要压入的元素</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">//队列</span></span><br><span class="line">q.<span class="built_in">empty</span>()<span class="comment">// 如果队列为空返回true，否则返回false  </span></span><br><span class="line">q.<span class="built_in">size</span>() <span class="comment">// 返回队列中元素的个数  </span></span><br><span class="line">q.<span class="built_in">pop</span>()  <span class="comment">//删除队列首元素但不返回其值  </span></span><br><span class="line">q.<span class="built_in">front</span>()  <span class="comment">// 返回队首元素的值，但不删除该元素  </span></span><br><span class="line">q.<span class="built_in">push</span>(X) <span class="comment">//在队尾压入新元素 ，X为要压入的元素</span></span><br><span class="line">q.<span class="built_in">back</span>() <span class="comment">//返回队列尾元素的值，但不删除该元素</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; q.<span class="built_in">enpty</span>() &lt;&lt; endl;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; q.<span class="built_in">empty</span>() &lt;&lt;endl;</span><br><span class="line">    s.<span class="built_in">push</span>(a);</span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt;endl;</span><br><span class="line">    s.<span class="built_in">push</span>(b);</span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">top</span>();</span><br><span class="line">    s,<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pair的用法"><a href="#pair的用法" class="headerlink" title="pair的用法"></a>pair的用法</h3><p><a href="https://blog.csdn.net/wqw1672/article/details/105501165/">https://blog.csdn.net/wqw1672/article/details/105501165/</a></p><p><a href="https://zhuanlan.zhihu.com/p/99796723">https://zhuanlan.zhihu.com/p/99796723</a></p><p> pair是将2个数据组合成一组数据， pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <strong>创建pair</strong><br>在创建pair对象时，必须提供两个类型名，两个对应的类型名的类型不必相同 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, string&gt; anon;        <span class="comment">// 创建一个空对象anon，两个元素类型都是string</span></span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; word_count;     <span class="comment">// 创建一个空对象 word_count, 两个元素类型分别是string和int类型</span></span><br><span class="line">pair&lt;string, vector&lt;<span class="type">int</span>&gt; &gt; line;  <span class="comment">// 创建一个空对象line，两个元素类型分别是string和vector类型</span></span><br><span class="line"></span><br><span class="line">st.<span class="built_in">push</span>(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;); <span class="comment">//这里都是成对插入的 与pair相对应</span></span><br><span class="line">stack&lt;pair&lt;<span class="type">int</span>, string&gt;&gt; sta;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="C-中public、private"><a href="#C-中public、private" class="headerlink" title="C ++中public、private"></a>C ++中public、private</h3><p>1.public</p><p>定义的变量和常数都可以被其他类型变量（该类的孩子，兄弟等，其他类）使用， 类似公共用品。以public继承基类，基类的所有的属性和方法都保持原样不变。</p><p>2.private<br>只能在类里面调用，但是private修饰的变量也不是不能被其他类改变，可以通过该类中的public方法调用private变量<br>private继承基类，所有的方法和变量都变为private，类似于集合的关系</p><p>第一: private,public,protected的访问范围:</p><p>private: 只能由该类中的函数、其友元函数访问,不能被任何其他访问，该类的对象也不能访问.<br>protected: 可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问<br>public: 可以被该类中的函数、子类的函数、其友元函数访问,也可以由该类的对象访问<br>注：友元函数包括两种：设为友元的全局函数，设为友元类中的成员函数</p><p>第二:类的继承后方法属性变化:</p><p>使用private继承,父类的所有方法在子类中变为private; 使用protected继承,父类的protected和public方法在子类中变为protected,private方法不变; 使用public继承,父类中的方法属性不发生改变;</p><p>public:可以被任意实体访问</p><p>protected:只允许子类及本类的成员函数访问</p><p>private:只允许本类的成员函数访问</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><a href="https://www.cnblogs.com/averyfork/p/14420238.html">https://www.cnblogs.com/averyfork/p/14420238.html</a></p><p><strong>2.auto遍历</strong></p><p>auto是声明自动变量格式为<strong>for(元素类型</strong> <strong>遍历值：数组&#x2F;容器)，</strong></p><p>之所以用auto是可以根据赋值自动推导出变量类型。</p><p>加&amp;是引用，如果没有&amp;，每次遍历都会给重新开辟空间存放遍历的值，空间复杂度是O（n），而<strong>使用引用的话，即使用同一块空间</strong>。</p><p>同时，<strong>引用的情况下可以修改原来的值</strong>。</p><p>此外还有 for(auto&amp;&amp; count: counts)，其与for(auto&amp; count: counts)的区别在于auto的推导是否受初始化值的影响。</p><p><strong><code>auto&amp;&amp;</code> 的推导收到初始化值的 value category 的影响。用左值初始化，推导得结果是一个左值引用；否则是一个右值引用。</strong></p><p><strong><code>auto&amp;</code> 的推导与初始化值的 value category 无关。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组入门</title>
      <link href="/2021/02/23/%E6%95%B0%E7%BB%84%E5%85%A5%E9%97%A8/"/>
      <url>/2021/02/23/%E6%95%B0%E7%BB%84%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><h3 id="写在前面的一些话："><a href="#写在前面的一些话：" class="headerlink" title="写在前面的一些话："></a>写在前面的一些话：</h3><p>把自己当做是一个什么都不懂的小孩，然后从零开始学起。每天保持一定的代码量，并且及时地去总结和复盘。这才是或者说这就是自己应该要做的事情。</p><span id="more"></span><h3 id="基本刷题思路"><a href="#基本刷题思路" class="headerlink" title="基本刷题思路"></a>基本刷题思路</h3><p>刷题顺序： 推荐刷题顺序： 数组 -&gt;字符串 -&gt;链表-&gt;二分查找-&gt;排序-&gt;哈希表-&gt; 栈-&gt;队列 -&gt;树 、递归、回溯 -&gt; 堆 -&gt;动态规划。</p><p>一开始如果五分钟没有思路的话可以去看答案了。前期因为可能对做这种题目还不够擅长不够熟练，但是每隔一个礼拜要重新回过头来看看。</p><p>注意特殊情况，边界条件。这种细节如果不是自己重新写一遍代码的话是发现不了问题的。每道题的思考不要超过一个小时。</p><p> LeetCode刷题顺序<br>\1. 跟着教程的章节来刷题；剑指offer和程序员面试经典<br>\2. 按LeetCode分类中的频率从高到低刷，例如字符串、数组、二分查找、哈希表、链表、双指针、栈、树、深度优先搜索、广度优先搜索、回溯法、排序<br>\3. 拓展一道题的相似题目<br>\4. Top100或者精选200<br>\5. 参加LeetCode周赛或者双周赛，基本做出前三道，有时能做出第四道，以中等难度为主，简单难度热身，弄懂Top100或者精选200中困难难度<br>\6. 定期复习，面试前冲刺热题</p><p>往返重复，拿出对待高考的态度和方法：先做例题，再做课后题，最后再做各种模拟套题</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1640661811942.png" alt="1640661811942"></p><p><a href="https://bbs.csdn.net/skill/algorithm/algorithm-cbdd961fd6b9430c9d3750a9d9659cdb?category=202">https://bbs.csdn.net/skill/algorithm/algorithm-cbdd961fd6b9430c9d3750a9d9659cdb?category=202</a></p><h3 id="1，两数之和（梦开始的地方）easy"><a href="#1，两数之和（梦开始的地方）easy" class="headerlink" title="1，两数之和（梦开始的地方）easy"></a>1，两数之和（梦开始的地方）easy</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><blockquote><p>初始思路：暴力解，然后开数组，以及哈希表。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无脑暴力解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)</span><br><span class="line">                <span class="keyword">return</span> &#123;i,j&#125;;  </span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>几个注意点：</p><ul><li>return之后要加分号以及 是大括号而不是小括号</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hashtable.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (it != hashtable.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>知识点：哈希表的时间复杂度为O（1），感觉很多题目的哈希映射都是用的大数组来表示。具体的还是有点看不懂，<strong>先占个坑之后来补。</strong></p><p>ps：本来是想用数组来做的，试一了一下，发现不行，感觉数组也算是哈希表的一种，但是因为数组设置的时候会出现负数，下标会有负数，不能成立。所以只能用哈希表。</p><p>nums&#x3D;{2 11 7 3}  taget&#x3D;9。<br>9-11为-2 a[-2]不成立。</p></blockquote><h3 id="4，寻找两个正序数组的中位数-hard"><a href="#4，寻找两个正序数组的中位数-hard" class="headerlink" title="4，寻找两个正序数组的中位数 hard"></a>4，寻找两个正序数组的中位数 hard</h3><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p><p>算法的时间复杂度应该为 O(log (m+n)) 。</p><blockquote><p>思路其实比较简单，因为这里提到了是O（log（m+n））已经知道的和log相关的算法只有归并，快排，二分其他的什么堆排序 桶排序之类的我就都不会了。。。 思路简单 实现起来其实还挺难的</p><p><img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1641459223451.png" alt="1641459223451"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//别人的就看看吧</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n = nums1.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> m = nums2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n &gt; m)  <span class="comment">//保证数组1一定最短 //为了加快速度 对长度短的进行二分</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">findMedianSortedArrays</span>(nums2, nums1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> LMax1 = <span class="number">0</span>, LMax2 = <span class="number">0</span>, RMin1 = <span class="number">0</span>, RMin2 = <span class="number">0</span>, c1, c2, lo = <span class="number">0</span>, hi = n;</span><br><span class="line"><span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">c1 = (hi + lo + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">c2 = (m + n) / <span class="number">2</span> - c1;</span><br><span class="line"></span><br><span class="line">LMax1 = (c1 == <span class="number">0</span>) ? INT_MIN : nums1[c1 - <span class="number">1</span>];</span><br><span class="line">RMin1 = (c1 == n) ? INT_MAX : nums1[c1];</span><br><span class="line">LMax2 = (c2 == <span class="number">0</span>) ? INT_MIN : nums2[c2 - <span class="number">1</span>];</span><br><span class="line">RMin2 = (c2 == m) ? INT_MAX : nums2[c2];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (LMax1 &gt; RMin2)</span><br><span class="line">hi = c1 - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (LMax2 &gt; RMin1)</span><br><span class="line">lo = c1 + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((m + n) % <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">min</span>(RMin1, RMin2);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">return</span> ((<span class="type">int64_t</span>)<span class="built_in">max</span>(LMax1, LMax2) + (<span class="type">int64_t</span>)<span class="built_in">min</span>(RMin1, RMin2)) / <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="11，盛最多水的容器-mid"><a href="#11，盛最多水的容器-mid" class="headerlink" title="11，盛最多水的容器 mid"></a>11，盛最多水的容器 mid</h3><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器。</p><p><img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1640673548636.png" alt=""></p><blockquote><p>第一眼真的就暴力解，发现很多数组类的题目都可以暴力解，就是时间复杂度太高了。。。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无脑暴力解 是我不配了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> area=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;height.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=height.<span class="built_in">size</span>()<span class="number">-1</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> now=(j-i)*<span class="built_in">min</span>(height[i],height[j]);</span><br><span class="line">                area=<span class="built_in">max</span>(area,now);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>&#123;m&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> area=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="type">int</span> now=(j-i)*<span class="built_in">min</span>(height[i],height[j]);</span><br><span class="line">            <span class="comment">//每次移动一小格，底都会-1，要满足题意，那高必须增加，要使得高增加那么就需要让更矮的一方向对方移动。</span></span><br><span class="line">            area=<span class="built_in">max</span>(now,area);</span><br><span class="line">            <span class="keyword">if</span>(height[i]&lt;height[j]) <span class="comment">//右边的更高一点,让左边的移动 </span></span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>&#123;area&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>正常解法：动态规划，双指针题目。从两边向中间靠拢. 背后的<strong>缩减搜索空间</strong>的思想去考虑题解。感觉有点点类似于快排，都是通过两者比较，一个移动一个不移动。</p><p>思想：从外到内，要使得area最大，又因为每次移动一小格，底都会-1，要满足题意，那高必须增加，要使得高增加那么就需要让更矮的一方向对方移动。</p><p><img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1640674504454.png" alt="1640674504454"><br><img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1640674519223.png" alt="1640674519223"><br>为什么只需要移动最小的一边呢。因为如果移动大的一边的话，里面水的面积的最大值会小于初始值。<br>$$<br>min(x,y)*t_初始&gt;min(x,y_现在)*t_{现在}<br>$$<br> 因为t初始一定是要大于t现在的，所以x不能作为边界条件，需要继续向右移动。所以x不是边界条件</p></blockquote><h3 id="15，三数之和-mid"><a href="#15，三数之和-mid" class="headerlink" title="15，三数之和 mid"></a>15，三数之和 mid</h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><blockquote><p>思路：第一感觉是用暴力。有点类似于408的某年真题，直接排序然后三重for循环暴力求解。</p><p>第二的感觉：三个指针，或者固定一个用双指针,但具体怎么做也还是不知道</p><p>第三种感觉：哈希表，具体怎么实现不知道..</p></blockquote><blockquote><p>题目中要求找到所有「不重复」且和为 00 的三元组，<strong>这个「不重复」的要求使得我们无法简单地使用三重循环枚举所有的三元组</strong>。这是因为在最坏的情况下，数组中的元素全部为 00，即</p><p> [0, 0, 0, 0, 0, …, 0, 0, 0]</p><p><strong>最终的思路：</strong></p><p>排序+双指针 。先通过sort函数排序先确定nums[i]为第⼀一个元素，为了了避免重复，如果nums[i]和刚刚的nums[i-1]相同就跳过continue，然后begin指向i+1，end指向n-1，判断此时的sum是否等于0，如果等于0就将结果放⼊入result数组中，且begin++，end – -，为了了避免重复，如果begin++后的元素依旧和刚才的元素相同，继续begin++，end同理理～如果sum&gt;0就将end – -，如果sum&lt;0就将begin++，<br>最后返回result结果集</p></blockquote><p>注意sort的使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力破解法</span></span><br><span class="line">         解法<span class="number">1</span>，通过<span class="number">315</span>个案例，逻辑比较清晰，能够对vector的sort count 以及尝试过的unique（在使用unique之前需要进行排序） 都有比较好的理解</span><br><span class="line">         vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">         <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">3</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> result;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>()<span class="number">-2</span>; i++)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>; j&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>; j++)&#123;</span><br><span class="line">                 <span class="keyword">for</span>(<span class="type">int</span> k=j+<span class="number">1</span>; k&lt;nums.<span class="built_in">size</span>(); k++)&#123;</span><br><span class="line">                     <span class="keyword">if</span>(nums[i] + nums[j] + nums[k] == <span class="number">0</span>)&#123;</span><br><span class="line">                         vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">                         temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                         temp.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">                         temp.<span class="built_in">push_back</span>(nums[k]);</span><br><span class="line">                         <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">                         <span class="keyword">if</span>(<span class="built_in">count</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>(),temp) == <span class="number">0</span>)&#123;</span><br><span class="line">                             result.<span class="built_in">push_back</span>(temp);</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><blockquote><p>这个暴力破解没有写好，并不是说自己不会，而是c++的这种容器的形式还是不那么熟练，vector用的不够熟练，需要进行一些补充，之后把sort再看看。</p></blockquote><h5 id="最佳解法："><a href="#最佳解法：" class="headerlink" title="最佳解法："></a>最佳解法：</h5><p>排序+双指针：暂时没怎么看得懂 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">3</span>)   <span class="keyword">return</span> &#123;&#125;;          <span class="comment">// 特判</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;res;            <span class="comment">// 保存结果（所有不重复的三元组）</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">// 排序（默认递增）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)      <span class="comment">// 固定第一个数，转化为求两数之和</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)    <span class="keyword">return</span> res; <span class="comment">// 第一个数大于 0，后面都是递增正数，不可能相加为零了</span></span><br><span class="line">            <span class="comment">// 去重：如果此数已经选取过，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])  <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 双指针在nums[i]后面的区间中寻找和为0-nums[i]的另外两个数</span></span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = size - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] + nums[right] &gt; -nums[i])</span><br><span class="line">                    right--;    <span class="comment">// 两数之和太大，右指针左移</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; -nums[i])</span><br><span class="line">                    left++;     <span class="comment">// 两数之和太小，左指针右移</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 找到一个和为零的三元组，添加到结果中，左右指针内缩，继续寻找</span></span><br><span class="line">                    res.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="comment">// 去重：第二个数和第三个数也不重复选取</span></span><br><span class="line">                    <span class="comment">// 例如：[-4,1,1,1,2,3,3,3], i=0, left=1, right=5</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left<span class="number">-1</span>])  left++;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right+<span class="number">1</span>])    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自己的版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">3</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;<span class="comment">//定义一个容器vector</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()); <span class="comment">//排序，加了cmp是递减，不加是递增</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">return</span> res;<span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">             <span class="comment">//因为是已经排好序了，所以如果相邻两个相同，说明就不需要选择了。</span></span><br><span class="line">            <span class="type">int</span> left=i+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((nums[left]+nums[right])&gt;-nums[i])</span><br><span class="line">                right--; <span class="comment">//两者相加大于-nums，说明需要变小，则right向左移动</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[left]+nums[right]&lt;-nums[i])</span><br><span class="line">                left++;  <span class="comment">//两者相加小于-nums，说明需要变大 则left向移动</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[left]+nums[right]==-nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                     res.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left<span class="number">-1</span>])  left++;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right+<span class="number">1</span>])    right--;<span class="comment">//左边和右边去除重复项</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>思考补充：既然三数之和可以使用双指针法，我们之前讲过的1.两数之和，可不可以使用双指针法呢？</p><p>如果不能，题意如何更改就可以使用双指针法呢？ 大家留言说出自己的想法吧！</p><p>两数之和 就不能使用双指针法，因为1.两数之和要求返回的是索引下标， 而双指针法一定要排序，一旦排序之后原数组的索引就被改变了。</p><p>如果1.两数之和要求返回的是数值的话，就可以使用双指针法了。</p></blockquote><h3 id="75，颜色分类-mid"><a href="#75，颜色分类-mid" class="headerlink" title="75，颜色分类 mid"></a>75，颜色分类 mid</h3><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><blockquote><p>初步思考：</p><p>1，暴力解快排 O（nlogn）</p><p>2，哈希表映射</p><p>3，数组 这道题目就可以用数组来表示，因为里面只有0,1,2没有负数。</p><p>4,双指针或者单指针</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用数组去求解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> color[<span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">               <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">        color[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: color[<span class="number">0</span>]++;<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: color[<span class="number">1</span>]++;<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: color[<span class="number">2</span>]++;<span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//建立一个辅助数组来记录012的数目。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(color[i]&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[j++]=i;</span><br><span class="line">                color[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//重新赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单指针法求解，进行两趟遍历。第一步是是让0全部都排到前面去，每次都是交换0和头部，然后头部往后面移动一位。 之后再遍历一遍，让1移动</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ptr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[ptr]);</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = ptr; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[ptr]);</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> p0 = <span class="number">0</span>, p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[p1]);</span><br><span class="line">                ++p1;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[p0]);</span><br><span class="line">                <span class="keyword">if</span> (p0 &lt; p1) &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(nums[i], nums[p1]);</span><br><span class="line">                &#125;</span><br><span class="line">                ++p0;</span><br><span class="line">                ++p1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>双指针法可以好好学学，感觉双指针用的还是比较多的</strong>，一次遍历即可排好序。</p><p> 方法一需要进行两次遍历，那么我们是否可以仅使用一次遍历呢？我们可以额外使用一个指针，即使用两个指针分别用来交换 0 和 1。 </p><p><img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1640760359920.png" alt="1640760359920"></p></blockquote><h3 id="76，最小覆盖子串-hard"><a href="#76，最小覆盖子串-hard" class="headerlink" title="76，最小覆盖子串 hard"></a>76，最小覆盖子串 hard</h3><ul><li><p>第一种思路，枚举出所有大于t长度的子串，然后再一个比对。</p></li><li><p>第二种思路：双指针（这道题目的思路和盛水最多的容器思路其实是一样的，先记录s和t每个字母的频数，然后让s不断地缩小</p></li></ul><p>第四种思想：hash map</p><blockquote><p>这里T是可能包含重复字符的，如果可能误解题目的意思，需要和面试官说清楚。可能到时候算法不一样。</p></blockquote><h5 id="新思想：滑动窗口"><a href="#新思想：滑动窗口" class="headerlink" title="新思想：滑动窗口"></a>新思想：滑动窗口</h5><p><img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1641431986077.png" alt="1641431986077"></p><blockquote><p>右边界右移</p><p>winFreq[s[right]]&lt;tFreq[s[right]]严格小于时，distance+1，当distance&#x3D;t的长度时才说明包含所有字符。</p><p>左边界右移，如果出现winFreq[s[right]]&lt;tFreq[s[right]]时，说明不是包含的最小覆盖子串，此时不能移动，所以需要同时移动</p><p>时间复杂度O（1）</p><p><img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1641433272682.png" alt="1641433272682"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s == <span class="string">&quot;&quot;</span> || t == <span class="literal">null</span> || t == <span class="string">&quot;&quot;</span> || s.length() &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//维护两个数组，记录已有字符串指定字符的出现次数，和目标字符串指定字符的出现次数</span></span><br><span class="line">        <span class="comment">//ASCII表总长128</span></span><br><span class="line">        <span class="type">int</span>[] need = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="type">int</span>[] have = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将目标字符串指定字符的出现次数记录</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            need[t.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分别为左指针，右指针，最小长度(初始值为一定不可达到的长度)</span></span><br><span class="line">        <span class="comment">//已有字符串中目标字符串指定字符的出现总频次以及最小覆盖子串在原字符串中的起始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, min = s.length() + <span class="number">1</span>, count = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">r</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            <span class="comment">//说明该字符不被目标字符串需要，此时有两种情况</span></span><br><span class="line">            <span class="comment">// 1.循环刚开始，那么直接移动右指针即可，不需要做多余判断</span></span><br><span class="line">            <span class="comment">// 2.循环已经开始一段时间，此处又有两种情况</span></span><br><span class="line">            <span class="comment">//  2.1 上一次条件不满足，已有字符串指定字符出现次数不满足目标字符串指定字符出现次数，那么此时</span></span><br><span class="line">            <span class="comment">//      如果该字符还不被目标字符串需要，就不需要进行多余判断，右指针移动即可</span></span><br><span class="line">            <span class="comment">//  2.2 左指针已经移动完毕，那么此时就相当于循环刚开始，同理直接移动右指针</span></span><br><span class="line">            <span class="keyword">if</span> (need[r] == <span class="number">0</span>) &#123;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当且仅当已有字符串目标字符出现的次数小于目标字符串字符的出现次数时，count才会+1</span></span><br><span class="line">            <span class="comment">//是为了后续能直接判断已有字符串是否已经包含了目标字符串的所有字符，不需要挨个比对字符出现的次数</span></span><br><span class="line">            <span class="keyword">if</span> (have[r] &lt; need[r]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//已有字符串中目标字符出现的次数+1</span></span><br><span class="line">            have[r]++;</span><br><span class="line">            <span class="comment">//移动右指针</span></span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">//当且仅当已有字符串已经包含了所有目标字符串的字符，且出现频次一定大于或等于指定频次</span></span><br><span class="line">            <span class="keyword">while</span> (count == t.length()) &#123;</span><br><span class="line">                <span class="comment">//挡窗口的长度比已有的最短值小时，更改最小值，并记录起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; min) &#123;</span><br><span class="line">                    min = right - left;</span><br><span class="line">                    start = left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> <span class="variable">l</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">                <span class="comment">//如果左边即将要去掉的字符不被目标字符串需要，那么不需要多余判断，直接可以移动左指针</span></span><br><span class="line">                <span class="keyword">if</span> (need[l] == <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果左边即将要去掉的字符被目标字符串需要，且出现的频次正好等于指定频次，那么如果去掉了这个字符，</span></span><br><span class="line">                <span class="comment">//就不满足覆盖子串的条件，此时要破坏循环条件跳出循环，即控制目标字符串指定字符的出现总频次(count）-1</span></span><br><span class="line">                <span class="keyword">if</span> (have[l] == need[l]) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//已有字符串中目标字符出现的次数-1</span></span><br><span class="line">                have[l]--;</span><br><span class="line">                <span class="comment">//移动左指针</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最小长度还为初始值，说明没有符合条件的子串</span></span><br><span class="line">        <span class="keyword">if</span> (min == s.length() + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回的为以记录的起始位置为起点，记录的最短长度为距离的指定字符串中截取的子串</span></span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>决策单调性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;hs,ht;<span class="comment">//定义两个hash表，一个是hs一个是ht</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> count:t) ht[count]++;<span class="comment">//对应的hash表里的字幕频数++</span></span><br><span class="line">        string res;  <span class="comment">//定义最小字符串</span></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>; <span class="comment">//相当于distance，保证</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;right&lt;s.<span class="built_in">size</span>();right++)&#123;</span><br><span class="line">            hs[s[right]]++; <span class="comment">//这个是对应的hash表的数字加加！！！！</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(hs[s[right]]&lt;=ht[s[right]])</span><br><span class="line">             count++;<span class="comment">//注意这里是先++然后再进行比较，所以可以有&lt;=</span></span><br><span class="line">            </span><br><span class="line">                <span class="comment">//判断左边，让左边往右边移动</span></span><br><span class="line">            <span class="keyword">while</span>(hs[s[left]]&gt;ht[s[left]])</span><br><span class="line">                     &#123;</span><br><span class="line">                         hs[s[left]]--;</span><br><span class="line">                         left++;  <span class="comment">//左边向右移动一位</span></span><br><span class="line">                     &#125;</span><br><span class="line">            <span class="keyword">if</span>(count==t.<span class="built_in">size</span>())<span class="comment">//说明count此时已经包含了所有t里面的字母</span></span><br><span class="line">                     &#123;</span><br><span class="line">                         <span class="keyword">if</span>(res.<span class="built_in">empty</span>()||right-left+<span class="number">1</span>&lt;res.<span class="built_in">size</span>())</span><br><span class="line">                             <span class="comment">//res.empty()表示的最开始的时候，需要直接运行一下。</span></span><br><span class="line">                             <span class="comment">//right-left+1表示的是此时的覆盖子串。res.size()表示的是之前的覆盖子串。当此时的覆盖子串小于现在的覆盖子串长度时，用现在的覆盖子串来代替，因为它更小</span></span><br><span class="line">                             res=s.<span class="built_in">substr</span>(left,right-left+<span class="number">1</span>);</span><br><span class="line">                             </span><br><span class="line">                     &#125;</span><br><span class="line">                     </span><br><span class="line">        &#125;<span class="comment">//只需要遍历一遍即可，因为指针都是严格单调递增的</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//作者：lin-shen-shi-jian-lu-k</span></span><br><span class="line"><span class="comment">//链接：https://leetcode-cn.com/problems/minimum-window-substring/solution/leetcode-76-zui-xiao-fu-gai-zi-chuan-cja-lmqz/</span></span><br></pre></td></tr></table></figure><blockquote><p>补充： 意思是将t容器中的每一个元素从前往后枚举出来，并用 count 来表示，类似于Java中的 for each 语句 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123; <span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> count:nums)</span><br><span class="line">    cout &lt;&lt; count &lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">//注意这里是count不是nums</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);<span class="comment">//输出为 0 2 1 1 0 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string <span class="title function_">minWindow</span><span class="params">(string s, string t)</span> &#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hs, ht;</span><br><span class="line">        <span class="keyword">for</span> (auto count: t) ht[count] ++ ;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>, left = <span class="number">0</span>; right &lt; s.size(); right ++ ) &#123;</span><br><span class="line">            hs[s[right]] ++ ; </span><br><span class="line">            <span class="keyword">if</span> (hs[s[right]] &lt;= ht[s[right]]) </span><br><span class="line">            count ++ ;      </span><br><span class="line">        <span class="keyword">while</span> (hs[s[left]] &gt; ht[s[left]]) </span><br><span class="line">        &#123;</span><br><span class="line">            hs[s[left]]--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (count == t.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.empty() || right - left + <span class="number">1</span> &lt; res.size())</span><br><span class="line">                res = s.substr(left, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>empty函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; nums = &#123; <span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">empty</span>()) <span class="comment">//判断是不是空，如果是空的话就运行，不是空的话就不运行</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ture&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt;<span class="string">&quot;false&quot;</span>;  <span class="comment">//这个不是空，所以运行false</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="142，环形链表-2-mid"><a href="#142，环形链表-2-mid" class="headerlink" title="142，环形链表 2 mid"></a>142，环形链表 2 mid</h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p><p>第一眼思路，没有思路…图都看不懂</p><p>head&#x3D;[1,6,4,7,2,5]</p><p>pos&#x3D;1，说明该链表的链尾是返回head[]的一号元素，即head[1]。</p><p>如果是pos&#x3D;0,说明返回0号元素，即head[0]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。 看样子之后要系统地学习一下hash表了，用的太多太多了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode *&gt; visited;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.<span class="built_in">count</span>(head)) &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.<span class="built_in">insert</span>(head);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>快指针和慢指针：终于用到了一个我自己比较熟悉的了，方式也很简单,不过主要就考察数学公式了。其实这种题目自己模拟一下就能够发现了。</p><p>快慢指针相类似的题目还有：<strong>408出现过的</strong></p><p>求中位数；求倒数第n个数等等；</p><p><img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1641458310365.png" alt="1641458310365"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="comment">//这里注意一下while的条件是fast和fast-&gt;next！=null</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                ListNode* index1 = fast;</span><br><span class="line">                ListNode* index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index2; <span class="comment">// 返回环的入口</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里提供一个更方便的题解</p><p><img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1641457870892.png" alt="1641457870892"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast=head,*low=head;<span class="comment">//定义两个指针类型 *表示是一个指针变量</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;low!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            low=low-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==low)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fast==<span class="literal">NULL</span>||fast-&gt;next==<span class="literal">NULL</span>) <span class="comment">//无环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        ListNode *record=fast; </span><br><span class="line">        low=low-&gt;next;</span><br><span class="line">        <span class="type">int</span> n=<span class="number">1</span>;<span class="comment">//用来记录这个环有多少个节点 这里应该要从1开始 之前已经走过一个点了。经过了一个next</span></span><br><span class="line">        <span class="keyword">while</span>(low!=fast) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            low=low-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *fast2=head,*low2=head;  <span class="comment">//再次从头开始读取</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            fast2=fast2-&gt;next;</span><br><span class="line">        <span class="comment">//这里注意其实不是求的倒数第n个节点而是n+1个，画一下图就出来了</span></span><br><span class="line">        <span class="keyword">while</span>(fast2!=low2)&#123;</span><br><span class="line">            fast2=fast2-&gt;next;</span><br><span class="line">            low2=low2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="31，下一个队列"><a href="#31，下一个队列" class="headerlink" title="31，下一个队列"></a>31，下一个队列</h3><p>实现获取 <strong>下一个排列</strong> 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地 </a>**修改，只允许使用额外常数空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;<span class="comment">//从右往左 找到第一个左小于右的数nums[i]</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;<span class="comment">//从右往左 找到第一个大于nums[i]的数 nums[j] 并进行交换</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>() + i + <span class="number">1</span>, nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//reverse(nums.begin() + i + 1, nums.end()); 这里无论是用reverse还是sort都是对的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>考察的其实就是字典序，<a href="https://blog.csdn.net/qq_37050329/article/details/86637183">https://blog.csdn.net/qq_37050329/article/details/86637183</a><br><img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1641795661129.png" alt="1641795661129"></p></blockquote><h3 id="38-剑指offer-字符串的排列"><a href="#38-剑指offer-字符串的排列" class="headerlink" title="38,剑指offer 字符串的排列"></a>38,剑指offer 字符串的排列</h3><p><img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1641795973059.png" alt="1641795973059"></p><p>这里比较难的一点在于两个，一个是全排列，直接输出，另外一个是去重，去重可以使用hash map来进行去重</p><blockquote><p><img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1641796040727.png" alt="1641796040727"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码真漂亮，虽然回溯和递归我现在用的都不够熟练，之后再好好学吧</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//为了让递归函数添加结果方便，定义到函数之外，这样无需带到递归函数的参数列表中</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//同；但是其赋值依赖c，定义声明分开</span></span><br><span class="line">    <span class="type">char</span>[] c;</span><br><span class="line">    <span class="keyword">public</span> String[] <span class="built_in">permutation</span>(String s) &#123;</span><br><span class="line">        c = s.<span class="built_in">toCharArray</span>();</span><br><span class="line">        <span class="comment">//从第一层开始递归</span></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//将字符串数组ArrayList转化为String类型数组</span></span><br><span class="line">        <span class="keyword">return</span> list.<span class="built_in">toArray</span>(<span class="keyword">new</span> String[list.<span class="built_in">size</span>()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当递归函数到达第三层，就返回，因为此时第二第三个位置已经发生了交换</span></span><br><span class="line">        <span class="keyword">if</span> (x == c.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//将字符数组转换为字符串</span></span><br><span class="line">            list.<span class="built_in">add</span>(String.<span class="built_in">valueOf</span>(c));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为了防止同一层递归出现重复元素</span></span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//这里就很巧妙了,第一层可以是a,b,c那么就有三种情况，这里i = x,正巧dfs(0)，正好i = 0开始</span></span><br><span class="line">        <span class="comment">// 当第二层只有两种情况，dfs(1）i = 1开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt; c.length; i++)&#123;</span><br><span class="line">            <span class="comment">//发生剪枝，当包含这个元素的时候，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (set.<span class="built_in">contains</span>(c[i]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.<span class="built_in">add</span>(c[i]);</span><br><span class="line">            <span class="comment">//交换元素，这里很是巧妙，当在第二层dfs(1),x = 1,那么i = 1或者 2， 不是交换1和1，要就是交换1和2</span></span><br><span class="line">            <span class="built_in">swap</span>(i,x);</span><br><span class="line">            <span class="comment">//进入下一层递归</span></span><br><span class="line">            <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//返回时交换回来，这样保证到达第1层的时候，一直都是abc。这里捋顺一下，开始一直都是abc，那么第一位置总共就3个交换</span></span><br><span class="line">            <span class="comment">//分别是a与a交换，这个就相当于 x = 0, i = 0;</span></span><br><span class="line">            <span class="comment">//     a与b交换            x = 0, i = 1;</span></span><br><span class="line">            <span class="comment">//     a与c交换            x = 0, i = 2;</span></span><br><span class="line">            <span class="comment">//就相当于上图中开始的三条路径</span></span><br><span class="line">            <span class="comment">//第一个元素固定后，每个引出两条路径,</span></span><br><span class="line">            <span class="comment">//     b与b交换            x = 1, i = 1;</span></span><br><span class="line">            <span class="comment">//     b与c交换            x = 1, i = 2;</span></span><br><span class="line">            <span class="comment">//所以，结合上图，在每条路径上标注上i的值，就会非常容易好理解了</span></span><br><span class="line">            <span class="built_in">swap</span>(i,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> temp = c[i];</span><br><span class="line">        c[i] = c[x];</span><br><span class="line">        c[x] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全排列+哈希表去重( 解题思路参考 46.全排列 )</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(s,<span class="number">0</span>,n);</span><br><span class="line">        unordered_map&lt;string,<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            hash[res[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=hash.<span class="built_in">begin</span>();it!=hash.<span class="built_in">end</span>();it++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(it-&gt;first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string&amp; s,<span class="type">int</span> first,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first==n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=first;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i],s[first]);</span><br><span class="line">            <span class="built_in">dfs</span>(s,first+<span class="number">1</span>,n);</span><br><span class="line">            <span class="built_in">swap</span>(s[i],s[first]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="283，移动0"><a href="#283，移动0" class="headerlink" title="283，移动0"></a>283，移动0</h3><p> 给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序 </p><p><img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1641796326094.png" alt="1641796326094"></p><p>这里提到了不能拷贝其他的数组，感觉空间复杂度只能为O(1),那么就不好用hash map之类的,感觉有点点像是双指针，但不好怎么去使用，</p><p>使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。</p><p>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</p><p>注意到以下性质：</p><p>左指针左边均为非零数；</p><p>右指针左边直到左指针处均为零。</p><p>因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左右指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[left], nums[right]); <span class="comment">//这一部分画个图就知道了 0 1 0 3 12 5 6 相当于不断地让0往后面移动</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法二，这个其实就是有点类似于整个辅助数组或者说快慢指针之类的，r永远走的比l快，那么非0的数字都赋给nums[l]，l++，最后再让l之后的都变为0 一次遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> r=<span class="number">0</span>,l=<span class="number">0</span>,size=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (r&lt;size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[r])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[l++]=nums[r];            &#125;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;size;i++) <span class="comment">//注意这里的i=l不是i=l+1，原因是已经加过1了 在nums[l++]里面</span></span><br><span class="line">        nums[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串 哈希表</title>
      <link href="/2021/02/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%20%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2021/02/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%20%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h3 id="基本知识点"><a href="#基本知识点" class="headerlink" title="基本知识点"></a>基本知识点</h3><p>参考c++基础</p><p>总结一下，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p><p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a href="https://leetcode-cn.com/problems/valid-anagram/">242. 有效的字母异位词</a></h3><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>因为要统计出现的次数，所以使用unordered_map统计key，然后 value,然后再两个map遍历比较，看看是否全部相等。</p><h4 id="两个哈希表-比较"><a href="#两个哈希表-比较" class="headerlink" title="两个哈希表 比较"></a>两个哈希表 比较</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; maps,mapt;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()!=t.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            maps[s[i]]++;</span><br><span class="line">            mapt[t[i]]++;<span class="comment">//统计出现的次数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:maps)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.second!=mapt[p.first])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h3><p> 给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的交集</em> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。 </p><p>![1643458699610](C:\Users\DELL\Desktop\LeetCode\字符串 哈希表.assets\1643458699610.png)</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>哈希表</p><h4 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res,num;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; set1,set2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:nums1)</span><br><span class="line">        set1.<span class="built_in">insert</span>(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:nums2)</span><br><span class="line">        set2.<span class="built_in">insert</span>(p); <span class="comment">//用两个set实现去重</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:set1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(set2.<span class="built_in">find</span>(p)!=set2.<span class="built_in">end</span>())<span class="comment">//没找到会返回end，找到了会返回对应的迭代器,不等于说明找到了</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;<span class="comment">//这里也可以直接定义一个哈希表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h4><p>这里注意一下好像是直接把res转换为了vector<int>,这个技巧可以学一学，没必要再建一个容器了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result_set; <span class="comment">// 存放结果</span></span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">nums_set</span><span class="params">(nums1.begin(), nums1.end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="comment">// 发现nums2的元素 在nums_set里又出现过</span></span><br><span class="line">            <span class="keyword">if</span> (nums_set.<span class="built_in">find</span>(num) != nums_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result_set.<span class="built_in">insert</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());<span class="comment">//这一步挺不错的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a href="https://leetcode-cn.com/problems/happy-number/">202. 快乐数</a></h3><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」 定义为：</p><p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。<br>如果这个过程 结果为 1，那么这个数就是快乐数。<br>如果 n 是 快乐数 就返回 true ；不是，则返回 false </p><p>![1643459096125](C:\Users\DELL\Desktop\LeetCode\字符串 哈希表.assets\1643459096125.png)</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>这道题目看上去貌似一道数学问题，其实并不是！</p><p>题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现，这对解题很重要！</strong></p><p>正如：<a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于哈希表，你该了解这些！ (opens new window)</a>中所说，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。</strong></p><p>所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</p><p>判断sum是否重复出现就可以使用unordered_set。</p><p><strong>还有一个难点就是求和的过程，如果对取数值各个位上的单数操作不熟悉的话，做这道题也会比较艰难。</strong></p><p> 所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。 </p><h4 id="哈希表-2"><a href="#哈希表-2" class="headerlink" title="哈希表"></a>哈希表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getsum</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> sum=<span class="built_in">getsum</span>(n);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(sum==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//这个要先运行</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(set.<span class="built_in">find</span>(sum)!=set.<span class="built_in">end</span>())<span class="comment">//说明sum重复出现了，陷入了死循环</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span>  set.<span class="built_in">insert</span>(sum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            n=sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h3><p>梦开始的地方</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="type">int</span> size=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">find</span>(target-nums[i])==map.<span class="built_in">end</span>())<span class="comment">//9-2=7 如果7没有找到的话</span></span><br><span class="line">            map[nums[i]]=i;<span class="comment">//key是对应的值，value是对应的下标</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> &#123;i,map[target-nums[i]]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="454-四数相加-II-mid"><a href="#454-四数相加-II-mid" class="headerlink" title="454. 四数相加 II(mid)"></a><a href="https://leetcode-cn.com/problems/4sum-ii/">454. 四数相加 II</a>(mid)</h3><p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p><p>0 &lt;&#x3D; i, j, k, l &lt; n<br>nums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>暴力破解</p><p>哈希表：其实有点像是两数之和，只不过是把target变成了0，把四数之和变成了两个（两数）之和</p><ol><li>首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。</li><li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。</li><li>定义int变量count，用来统计 a+b+c+d &#x3D; 0 出现的次数。</li><li>在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</li><li>最后返回统计值 count 就可以了</li></ol><h4 id="哈希表-3"><a href="#哈希表-3" class="headerlink" title="哈希表"></a>哈希表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums1)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j:nums2)</span><br><span class="line">            map[i+j]++;<span class="comment">//i+j的key代表ab两数之和 value 代表</span></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums3)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j:nums4)</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">find</span>(<span class="number">0</span>-(i+j))!=map.<span class="built_in">end</span>())<span class="comment">//说明找到了</span></span><br><span class="line">            count+=map[<span class="number">0</span>-(i+j)];</span><br><span class="line">        <span class="keyword">return</span> count; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a><a href="https://leetcode-cn.com/problems/ransom-note/">383. 赎金信</a></h3><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p><p>如果可以，返回 true ；否则返回 false 。</p><p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>构造哈希表，找得到且value&gt;0的时候就return true 否则return false</p><h4 id="哈希表-4"><a href="#哈希表-4" class="headerlink" title="哈希表"></a>哈希表</h4><p>不难</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:magazine)</span><br><span class="line">        &#123;</span><br><span class="line">            map[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:ransomNote)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">find</span>(c)==map.<span class="built_in">end</span>()||map[c]==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            map[c]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>涉及到单个数字或者单个字母的时候用数组的时间空间复杂度都会更好一点， <strong>因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！</strong> ，但如果是涉及到<strong>字符串，或者多个数字</strong>比如说92,322，这种的话那还是建议使用哈希表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度: O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; magazine.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 通过recode数据记录 magazine里各个字符出现次数</span></span><br><span class="line">            record[magazine[i]-<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ransomNote.<span class="built_in">length</span>(); j++) &#123;</span><br><span class="line">            <span class="comment">// 遍历ransomNote，在record里对应的字符个数做--操作</span></span><br><span class="line">            record[ransomNote[j]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="comment">// 如果小于零说明ransomNote里出现的字符，magazine没有</span></span><br><span class="line">            <span class="keyword">if</span>(record[ransomNote[j]-<span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:magazine)</span><br><span class="line">        &#123;</span><br><span class="line">            num[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:ransomNote)</span><br><span class="line">        &#123;</span><br><span class="line">            num[c-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span>(num[c-<span class="string">&#x27;a&#x27;</span>]&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">//auto 还是快啊</span></span><br></pre></td></tr></table></figure><h3 id="15-三数之和-mid"><a href="#15-三数之和-mid" class="headerlink" title="15. 三数之和(mid)"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a>(mid)</h3><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p><p>0 &lt;&#x3D; a, b, c, d &lt; n<br>a、b、c 和 d 互不相同<br>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target<br>你可以按 任意顺序 返回答案 </p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><h4 id="哈希表法"><a href="#哈希表法" class="headerlink" title="哈希表法"></a>哈希表法</h4><p>这道题目如果是用哈希表的话里面注意的细节会比较多所以其实更加建议使用双指针法去做。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[j], c = -(a + b)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，那么不可能凑成三元组</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123; <span class="comment">//三元组元素a去重</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unordered_set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">2</span></span><br><span class="line">                        &amp;&amp; nums[j] == nums[j<span class="number">-1</span>]</span><br><span class="line">                        &amp;&amp; nums[j<span class="number">-1</span>] == nums[j<span class="number">-2</span>]) &#123; <span class="comment">// 三元组元素b去重</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> c = <span class="number">0</span> - (nums[i] + nums[j]);</span><br><span class="line">                <span class="keyword">if</span> (set.<span class="built_in">find</span>(c) != set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], c&#125;);</span><br><span class="line">                    set.<span class="built_in">erase</span>(c);<span class="comment">// 三元组元素c去重</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    set.<span class="built_in">insert</span>(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <strong>双指针法将时间复杂度：$O(n^2)$的解法优化为 $O(n)$的解法。也就是降一个数量级，题目如下：</strong> </p><ul><li><a href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html">27.移除元素(opens new window)</a></li><li><a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">15.三数之和(opens new window)</a></li><li><a href="https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html">18.四数之和(opens new window)</a></li></ul><p>操作链表：</p><ul><li><a href="https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html">206.反转链表(opens new window)</a></li><li><a href="https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html">19.删除链表的倒数第N个节点(opens new window)</a></li><li><a href="https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html">面试题 02.07. 链表相交(opens new window)</a></li><li><a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html">142题.环形链表II</a></li></ul><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode-cn.com/problems/reverse-string/">344. 反转字符串</a></h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>()/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i],s[s.<span class="built_in">size</span>()-i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a><a href="https://leetcode-cn.com/problems/reverse-string-ii/">541. 反转字符串 II</a></h3><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>s<strong>wap部分没有处理好 导致花了很多不必要的时间</strong>，这里其实是没有整清楚里面到底是谁和谁换 其实是s[left+i]和s[left+k-1-i]去进行替换</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverse</span><span class="params">(string &amp;s,<span class="type">int</span> k,<span class="type">int</span> left)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> right=s.<span class="built_in">length</span>();<span class="comment">//右边界</span></span><br><span class="line">        <span class="keyword">if</span>(right&lt;left) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//剩余字符大于2k个</span></span><br><span class="line">        <span class="keyword">while</span>(right-left&gt;=<span class="number">2</span>*k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k/<span class="number">2</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(s[left+i],s[left+k<span class="number">-1</span>-i]);</span><br><span class="line">            &#125;</span><br><span class="line">            left=left+<span class="number">2</span>*k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(right-left&lt;<span class="number">2</span>*k&amp;&amp;right-left&gt;=k) <span class="comment">//剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</span></span><br><span class="line">                &#123;</span><br><span class="line">                     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k/<span class="number">2</span>;i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">swap</span>(s[left+i],s[left+k<span class="number">-1</span>-i]);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> s;</span><br><span class="line">                &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//剩余字符小于k个全部翻转</span></span><br><span class="line">        <span class="keyword">if</span>(right-left&lt;k)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;(right+left)/<span class="number">2</span>;i++)</span><br><span class="line">            <span class="built_in">swap</span>(s[i],s[right+left-i<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(s,k,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反转字符串s中左闭又闭的区间[start, end]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//这一部分的代码真的很惊艳，太妙了</span></span><br></pre></td></tr></table></figure><h4 id="代码随想录-1"><a href="#代码随想录-1" class="headerlink" title="代码随想录"></a>代码随想录</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += (<span class="number">2</span> * k)) &#123;</span><br><span class="line">            <span class="comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span></span><br><span class="line">            <span class="comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span></span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s, i, i + k - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转。</span></span><br><span class="line">            <span class="built_in">reverse</span>(s, i, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h3><p> 请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。 </p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先计算有多少个空格</span></span><br><span class="line">        <span class="type">int</span> length=s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                 res.<span class="built_in">push_back</span>(<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">                 res.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            res.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="双指针法-之后自己写一下"><a href="#双指针法-之后自己写一下" class="headerlink" title="双指针法(之后自己写一下)"></a><strong>双指针法</strong>(之后自己写一下)</h4><p>从后往前 代码随想录</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 统计空格的个数</span></span><br><span class="line">        <span class="type">int</span> sOldSize = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩充字符串s的大小，也就是每个空格替换成&quot;%20&quot;之后的大小</span></span><br><span class="line">        s.<span class="built_in">resize</span>(s.<span class="built_in">size</span>() + count * <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> sNewSize = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 从后先前将空格替换为&quot;%20&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = sNewSize - <span class="number">1</span>, j = sOldSize - <span class="number">1</span>; j &lt; i; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                s[i] = s[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                s[i - <span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[i - <span class="number">2</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                i -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151. 翻转字符串里的单词"></a><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">151. 翻转字符串里的单词</a></h3><p>给你一个字符串 s ，逐个翻转字符串中的所有 单词 。</p><p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p><p>请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。</p><p>说明：</p><p>输入字符串 s 可以在前面、后面或者单词间包含多余的空格。<br>翻转后单词间应当仅用一个空格分隔。<br>翻转后的字符串中不应包含额外的空格。</p><p>![1643517247673](C:\Users\DELL\Desktop\LeetCode\字符串 哈希表.assets\1643517247673.png)</p><h4 id="低效思路"><a href="#低效思路" class="headerlink" title="低效思路"></a>低效思路</h4><p>开容器：建立一个vector<string> strl;先存储单词进去，然后再逆序输出并增加’ ‘(空格)，不时间复杂度O（2n） 空间复杂度O（n），其实还是比较高了，方法比较简陋。</p><p>感觉应该可以用双指针去做，这样的话应该<strong>空间复杂度只要O（1）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; str;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        s=<span class="string">&#x27; &#x27;</span>+s; <span class="comment">//第一个做特殊处理，直接前面加个空格</span></span><br><span class="line">        <span class="comment">//将单词都存储到vector中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">&#x27; &#x27;</span>)<span class="comment">//前面一个有空格,且自己不是空格，说明这是一个新单词</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        str.<span class="built_in">push_back</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                        num++;</span><br><span class="line">                    &#125;</span><br><span class="line">            str[num<span class="number">-1</span>]+=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//翻转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=str.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            res=res+str[i]+<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;            </span><br><span class="line">        res=res+str[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="高效翻转"><a href="#高效翻转" class="headerlink" title="高效翻转"></a>高效翻转</h4><p> 1，消除多余空格（前面的空格、中间多余的空格、后面的空格）。 </p><p>2，将整个字符串翻转，reverse</p><p>3，<strong>依次将单词翻转，这个是最关键的</strong></p><blockquote><p>前面很多大佬都总结了，无非只有三步：</p><p>消除多余空格（前面的空格、中间多余的空格、后面的空格）。<br>本题解使用快慢指针，也可以使用erase，快慢指针的思路是参@carlsun-2<br>快慢指针的具体解释：fast用于向前遍历字符串，slow用于记录我们最终想要的字符串。依次去除前面的空格、中间多余的空格、后面的空格。去除中间多余空格的代码让最后只有两种情况：最后一个字符是空格（倒数第二个字符不是空格）和最后一个字符也不是空格。据此写出消除末尾空格的代码。<br>将整个字符串翻转。本题解写了一个翻转函数，也可以用reverse<br>利用首尾指针<br>依次将每个单词翻转。<br>用i去遍历字符串，当遇到空格时，说明前面是一个单词，将前面的单词翻转。<br>i到末尾时没有空格，但是最后一个单词还没有被翻转，所以翻转一下最后一个单词</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//反转字符串</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp; s,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[start++],s[end--]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移除多余空格，利用快慢指针</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeExtraSpaces</span><span class="params">(string&amp;s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> slow=<span class="number">0</span>,fast=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//移除开始位置的空格</span></span><br><span class="line">        <span class="keyword">while</span>(s[fast]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//移除中间位置多余的空格</span></span><br><span class="line">        <span class="keyword">while</span>(fast&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast&gt;<span class="number">0</span> &amp;&amp; s[fast]==<span class="string">&#x27; &#x27;</span> &amp;&amp;s[fast<span class="number">-1</span>]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s[slow]=s[fast];</span><br><span class="line">                slow++;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果末尾仅有一个空格，则上述无法将该空格移除；如果末尾有很多空格，则上述将保留一个空格，也不符合要求；所以最终可能的情况有二：末尾有一个空格/末尾无空格 </span></span><br><span class="line">        <span class="keyword">if</span>(slow<span class="number">-1</span>&gt;<span class="number">0</span> &amp;&amp; s[slow<span class="number">-1</span>]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            slow--;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//step1.移除多余空格</span></span><br><span class="line">        <span class="built_in">removeExtraSpaces</span>(s);</span><br><span class="line">        <span class="comment">//step2.反转整个字符串</span></span><br><span class="line">        <span class="built_in">reverse</span>(s,<span class="number">0</span>,s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//step3.依次反转每个单词</span></span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s,start,i<span class="number">-1</span>);</span><br><span class="line">                start=i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//最后一个单词后面不是空格，所以需要单独考虑</span></span><br><span class="line">            <span class="keyword">if</span>(i==s.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s,start,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：xiao-bo-bian-huan</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/reverse-words-in-a-string/solution/kong-jian-fu-za-du-o1-c-zhu-shi-xiang-xi-biaw/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my first blog</title>
      <link href="/2019/11/02/my-first-blog/"/>
      <url>/2019/11/02/my-first-blog/</url>
      
        <content type="html"><![CDATA[<p>关于自己的第一个blog 有点简单 希望从此之后能够好好地经营能够写点东西</p><h3 id="felling"><a href="#felling" class="headerlink" title="felling"></a>felling</h3><p>  难但是挺有用的，以后应该能从中做点东西</p><h3 id="gaining"><a href="#gaining" class="headerlink" title="gaining"></a>gaining</h3><p>  比我想象中要难一点，不过也还行，学会了用B站建blog</p>]]></content>
      
      
      
        <tags>
            
            <tag> feelings </tag>
            
            <tag> gaining </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2019/11/02/%E6%A0%91/"/>
      <url>/2019/11/02/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树-1"><a href="#树-1" class="headerlink" title="树"></a>树</h2><h3 id="树的基本定义"><a href="#树的基本定义" class="headerlink" title="树的基本定义"></a>树的基本定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的基本定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span> *rchild,*lchild;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h4><p><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html</a></p><p>参考的代码随想录</p><p>这里帮助大家确定下来递归算法的三个要素。</p><p><strong>每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</strong></p><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><p>这个引⽤符号 &amp; 要和C语⾔⾥⾯的取地址运算符 &amp; 区分开来，他们没有什么关系，C++⾥⾯的引⽤是 </p><p><strong>指在变量名之前加⼀个 &amp; 符号，⽐如在函数传⼊的参数中 int &amp;a ，那么对这个引⽤变量 a 做的所有</strong> </p><p>操作都是直接对传⼊的原变量进⾏的操作，并没有像原来 int a ⼀样只是拷⻉⼀个副本（传值），</p><p>（具体参考柳诺）</p><p>树是通过递归顶一顶，构造一棵树基本上都是通过递归来构造，找到相似的递归结构才能构造</p><h3 id="94-树的中序遍历"><a href="#94-树的中序遍历" class="headerlink" title="94,树的中序遍历"></a>94,树的中序遍历</h3><p> 给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。 </p><p>中序遍历：左根右</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//  注意递归函数都要放在前面</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode *root,vector&lt;<span class="type">int</span>&gt; &amp;res)</span><span class="comment">//注意这里要＋&amp; 表示是对res的引用，不加的话返回不了正确的</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//如果root为nullpur 那么！root就运行 直接返回</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归 左中右 </span></span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left,res); </span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);<span class="comment">//容器的基本操作，比数组方便得多 </span></span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res; <span class="comment">//定义一个res的容器</span></span><br><span class="line">        <span class="built_in">inorder</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="101，对称二叉树"><a href="#101，对称二叉树" class="headerlink" title="101，对称二叉树"></a>101，对称二叉树</h3><p> 给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。 </p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>树的题目感觉很多都需要用到<strong>递归</strong>，递归往往是比较好的办法，要灵活掌握</p><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的本质是什么 递归 嘿嘿</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">panduan</span><span class="params">(TreeNode *l,TreeNode *r,<span class="type">bool</span> &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!l&amp;&amp;!r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((!l&amp;&amp;r)||(l&amp;&amp;!r))</span><br><span class="line">        &#123;</span><br><span class="line">            res=<span class="literal">false</span> ;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l-&gt;val!=r-&gt;val) res=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">panduan</span>(l-&gt;left,r-&gt;right,res);</span><br><span class="line">        <span class="built_in">panduan</span>(l-&gt;right,r-&gt;left,res);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode *l=root-&gt;left,*r=root-&gt;right;</span><br><span class="line">        <span class="type">bool</span> res=<span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">panduan</span>(l,r,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="102-层序遍历"><a href="#102-层序遍历" class="headerlink" title="102 层序遍历"></a>102 层序遍历</h3><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。 </p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>正常用队列做</p><blockquote><p>注意：这里不是返回一个数组，而是返回一个数组的数组，<strong>思路没有问题，只是一些细节的地方需要改改</strong>，需要学习这种写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> error: no viable conversion from returned value of type <span class="string">&#x27;vector&lt;int&gt;&#x27;</span> to function <span class="keyword">return</span> type <span class="string">&#x27;vector&lt;vector&lt;int&gt;&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">从答案这里可以看出来还是有区别的</span><br><span class="line">输入：root = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">输出：[[<span class="number">3</span>],[<span class="number">9</span>,<span class="number">20</span>],[<span class="number">15</span>,<span class="number">7</span>]]</span><br></pre></td></tr></table></figure></blockquote><h4 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="comment">//先写边界条件</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        q.<span class="built_in">push</span>(root);<span class="comment">//根节点入队</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())<span class="comment">//它是里面还得再生成一个数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size=q.<span class="built_in">size</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(vector &lt;<span class="type">int</span>&gt; ()); <span class="comment">//每次都新插入一个vector 然后再在里面写入数据 </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode *top=q.<span class="built_in">front</span>();</span><br><span class="line">                res.<span class="built_in">back</span>().<span class="built_in">push_back</span>(top-&gt;val); <span class="comment">//注意这种vector&lt;vector&lt;int&gt;&gt;的写法  [[3],[9,20],[15,7]]</span></span><br><span class="line">            <span class="comment">//  ret.back().push_back(node-&gt;val);</span></span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(top-&gt;left) </span><br><span class="line">                q.<span class="built_in">push</span>(top-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(top-&gt;right)<span class="comment">//细节啊 </span></span><br><span class="line">                q.<span class="built_in">push</span>(top-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//    lorder(root,res,q);</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个感觉写的更好一点，不用像答案那样 res.back().push_back()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103,二叉树的锯齿形层序遍历"></a>103,二叉树的锯齿形层序遍历</h3><p> 给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">输出：[[<span class="number">3</span>],[<span class="number">20</span>,<span class="number">9</span>],[<span class="number">15</span>,<span class="number">7</span>]]</span><br></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>加个deep判断深度就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="type">int</span> deep=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            deep++;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(deep%<span class="number">2</span>==<span class="number">0</span>)   <span class="built_in">reverse</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h3><p>给定一个二叉树，找出其最大深度。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1642668469603.png" alt="1642668469603" style="zoom:50%;" /><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p> 深度优先遍历,当前结点的最大深度等于左右子树最大深度的最大值加一  返回的结果是3 </p><h4 id="递归-DFS"><a href="#递归-DFS" class="headerlink" title="递归 DFS"></a><strong>递归</strong> DFS</h4><p>之后找个专题好好学学递归</p><p>秒，真的是太妙了，感觉就是能看懂，但是要自己写肯定就写不出来了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="comment">// 节点为空返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)) + <span class="number">1</span>; <span class="comment">// 左/右子树最大深度+1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> Max = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(TreeNode* r, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!r) <span class="comment">// 节点为空返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Max = <span class="built_in">max</span>(Max, d); <span class="comment">// 更新最大深度</span></span><br><span class="line">        <span class="built_in">DFS</span>(r-&gt;left, d+<span class="number">1</span>); <span class="comment">// 深搜左子树，深度+1</span></span><br><span class="line">        <span class="built_in">DFS</span>(r-&gt;right, d+<span class="number">1</span>); <span class="comment">// // 深搜右子树，深度+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="comment">// 树为空，最大深度为0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(root, <span class="number">1</span>); <span class="comment">// 从根节点深搜，初始深度为1</span></span><br><span class="line">        <span class="keyword">return</span> Max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="层次遍历-x2F-BFS"><a href="#层次遍历-x2F-BFS" class="headerlink" title="层次遍历&#x2F;BFS"></a>层次遍历&#x2F;BFS</h4><p>和上一题一样 就改一点点地方</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"> queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="type">int</span> deep=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            deep++;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(deep%<span class="number">2</span>==<span class="number">0</span>)   <span class="built_in">reverse</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h3><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点</p><p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1642918487443.png" alt="1642918487443"></p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>和最大深度一样，不过有个需要注意的地方</p><p>另外这道题的关键是搞清楚递归结束条件</p><p>叶子节点的定义是左孩子和右孩子都为 null 时叫做叶子节点<br><strong>当 root 节点左右孩子都为空时，返回 1</strong><br><strong>当 root 节点左右孩子有一个为空时，返回不为空的孩子节点的深度</strong><br><strong>当 root 节点左右孩子都不为空时，返回左右孩子较小深度的节点值</strong></p><p> <strong>求二叉树的最小深度和求二叉树的最大深度的差别主要在于处理左右孩子不为空的逻辑。</strong> </p><p> 左右孩子都为空的节点才是叶子节点！ 一开始错了是因为只要有一个孩子为空就返回了，但实际需要两个都为空才返回</p><h4 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>&amp;&amp;root-&gt;right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">minDepth</span>(root-&gt;right)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(root-&gt;left&amp;&amp;root-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">minDepth</span>(root-&gt;left)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>(<span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left),<span class="built_in">minDepth</span>(root-&gt;right)))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">//求最小深度时将Math.max换成Math.min即可，但要注意如果根节点的左或右子树为空的话是构不成子树的。而最小深度是要求从根节点到子树的。当左或右子树为空时，不符合要求。</span></span><br></pre></td></tr></table></figure><p>自己模拟一下就能出来了。</p><h4 id="迭代（队列）"><a href="#迭代（队列）" class="headerlink" title="迭代（队列）"></a>迭代（队列）</h4><p>代码随想录</p><p> <strong>需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            depth++; <span class="comment">// 记录最小深度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) &#123; <span class="comment">// 当左右孩子都为空的时候，说明是最低点的一层了，退出 这一句话</span></span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h3><p> 给定一棵树的前序遍历 <code>preorder</code> 与中序遍历 <code>inorder</code>。请构造二叉树并返回其根节点。 </p><p>Input: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>Output: [3,9,20,null,null,15,7]</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>手算比较简单 关键是代码的实现，这种题目感觉还是得用递归，一个个找，直到pre和in相同</p><p>思路</p><p>对于任意一颗树而言，前序遍历的形式总是</p><p>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]<br>即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是</p><p>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]<br>只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。</p><p>这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。</p><p>细节</p><p>在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。<strong>我们可以考虑使用哈希表来帮助我们快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值）</strong>，（注意这里没有重复元素）值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 O(1)O(1) 的时间对根节点进行定位了。</p><p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1642817908346.png" alt="1642817908346"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">myBuildTree</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; preorder, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> preorder_left, <span class="type">int</span> preorder_right, <span class="type">int</span> inorder_left, <span class="type">int</span> inorder_right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder_left &gt; preorder_right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 前序遍历中的第一个节点就是根节点</span></span><br><span class="line">        <span class="type">int</span> preorder_root = preorder_left;</span><br><span class="line">        <span class="comment">// 在中序遍历中定位根节点</span></span><br><span class="line">        <span class="type">int</span> inorder_root = index[preorder[preorder_root]]; <span class="comment">//在中序遍历中找到根节点，那么根节点左边就是左子树，右边就是右子树</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先把根节点建立出来</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[preorder_root]);</span><br><span class="line">        <span class="comment">// 得到左子树中的节点数目</span></span><br><span class="line">        <span class="type">int</span> size_left_subtree = inorder_root - inorder_left;</span><br><span class="line">        <span class="comment">// 递归地构造左子树，并连接到根节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下面的一部分看上面的图就能看出来了</span></span><br><span class="line">        <span class="comment">// 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span></span><br><span class="line">        root-&gt;left = <span class="built_in">myBuildTree</span>(preorder, inorder, preorder_left + <span class="number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归地构造右子树，并连接到根节点</span></span><br><span class="line">        <span class="comment">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span></span><br><span class="line">        root-&gt;right = <span class="built_in">myBuildTree</span>(preorder, inorder, preorder_left + size_left_subtree + <span class="number">1</span>, preorder_right, inorder_root + <span class="number">1</span>, inorder_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = preorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 构造哈希映射，帮助我们快速定位根节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            index[inorder[i]] = i;  <span class="comment">//key是中序遍历的值 value是对应的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">myBuildTree</span>(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);<span class="comment">//这里表示的是左右的边界</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="106，中序和后序遍历"><a href="#106，中序和后序遍历" class="headerlink" title="106，中序和后序遍历"></a>106，中序和后序遍历</h3><p> 跟105题类似的思路，不过是后序遍历中最后一个结点是根节点，通过确定根结点然后将中序遍历中的左右子树划分开。<br>然后再在左右子树中递归地进行构造二叉树 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不知道哪里错了，显示内存出错，但别的应该问题不大</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">myBuildTree</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; postorder, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> postorder_left, <span class="type">int</span> postorder_right, <span class="type">int</span> inorder_left, <span class="type">int</span> inorder_right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder_left &gt; postorder_right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 后序遍历中的最后一个节点就是根节点</span></span><br><span class="line">        <span class="type">int</span> postorder_root = postorder_right;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> inorder_root = index[postorder[postorder_root]]; <span class="comment">//找到最后一个节点</span></span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(postorder[postorder_root]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> size_left_subtree = inorder_root - inorder_left;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">myBuildTree</span>(postorder, inorder, postorder_left, postorder_left + size_left_subtree<span class="number">-1</span>, inorder_left, inorder_root - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">myBuildTree</span>(postorder, inorder, postorder_left + size_left_subtree , postorder_right<span class="number">-1</span>, inorder_root + <span class="number">1</span>, inorder_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = postorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 构造哈希映射，快速定位根节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            index[inorder[i]] = i;  <span class="comment">//key是中序遍历的值 value是对应的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">myBuildTree</span>(postorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);<span class="comment">//这里表示的是左右的边界</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = inorder.length;</span><br><span class="line">        <span class="comment">// 将中序遍历放到map中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            map.<span class="built_in">put</span>(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">myBuildTree</span>(inorder, postorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">myBuildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder, <span class="type">int</span> inorder_left, <span class="type">int</span> inorder_right, <span class="type">int</span> postorder_left, <span class="type">int</span> postorder_right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder_left &gt; inorder_right) &#123;</span><br><span class="line">            <span class="keyword">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根节点在后序遍历中的下标</span></span><br><span class="line">        <span class="type">int</span> postorder_root = postorder_right;</span><br><span class="line">        <span class="comment">// 根节点在中序遍历中的根节点</span></span><br><span class="line">        <span class="type">int</span> inorder_root = map.<span class="built_in">get</span>(postorder[postorder_root]);</span><br><span class="line">        <span class="comment">// 左子树的长度</span></span><br><span class="line">        <span class="type">int</span> size_left_subtree = inorder_root - inorder_left;</span><br><span class="line">        <span class="comment">// 建立根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(postorder[postorder_root]);</span><br><span class="line">        root.left = <span class="built_in">myBuildTree</span>(inorder, postorder, inorder_left, inorder_root - <span class="number">1</span>, postorder_left, postorder_left + size_left_subtree - <span class="number">1</span>);</span><br><span class="line">        root.right = <span class="built_in">myBuildTree</span>(inorder, postorder, inorder_root + <span class="number">1</span>, inorder_right, postorder_left + size_left_subtree, postorder_right - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h3><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p><p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>基本上树相关的题目就是迭代和递归了</p><h4 id="递归-4"><a href="#递归-4" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; l;</span><br><span class="line">        <span class="built_in">preorderTraversal</span>(root, l);</span><br><span class="line">        <span class="type">int</span> n = l.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            TreeNode *prev = l.<span class="built_in">at</span>(i - <span class="number">1</span>), *curr = l.<span class="built_in">at</span>(i);</span><br><span class="line">            prev-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            prev-&gt;right = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode* root, vector&lt;TreeNode*&gt; &amp;l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            l.<span class="built_in">push_back</span>(root);</span><br><span class="line">            <span class="built_in">preorderTraversal</span>(root-&gt;left, l);</span><br><span class="line">            <span class="built_in">preorderTraversal</span>(root-&gt;right, l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>观察可以发现将二叉树前序展开为链表，**相当于把一A结点的左孩子L整个完整的树替换到此结点的右孩子R上(同时把此结点原来的右孩子R接到此节点左孩子L的最右结点的右孩子上)**，然后将当前结点替换为此结点的右孩子(也就是原来的L)进行迭代(注意每次要将结点的左孩子设置为nullptr)。</p><p>前两种方法都借助前序遍历，前序遍历过程中需要使用栈存储节点。有没有空间复杂度是 O(1)O(1) 的做法呢？</p><p>注意到前序遍历访问各节点的顺序是根节点、左子树、右子树。如果一个节点的左子节点为空，则该节点不需要进行展开操作。如果一个节点的左子节点不为空，则该节点的左子树中的最后一个节点被访问之后，该节点的右子节点被访问。该节点的左子树中最后一个被访问的节点是左子树中的最右边的节点，也是该节点的前驱节点。因此，问题转化成寻找当前节点的前驱节点。</p><p>具体做法是，对于当前节点，如果其左子节点不为空，则在其左子树中找到最右边的节点，作为前驱节点，将当前节点的右子节点赋给前驱节点的右子节点，然后将当前节点的左子节点赋给当前节点的右子节点，并将当前节点的左子节点设为空。对当前节点处理结束后，继续处理链表中的下一个节点，直到所有节点都处理结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *l=root-&gt;left;</span><br><span class="line">            <span class="keyword">if</span>(l)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(l&amp;&amp;l-&gt;right)</span><br><span class="line">                l=l-&gt;right;<span class="comment">//需要让root的right接到左子树的最右的子树这</span></span><br><span class="line"></span><br><span class="line">                 l-&gt;right=root-&gt;right;</span><br><span class="line">                root-&gt;right=root-&gt;left;</span><br><span class="line">                root-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           root=root-&gt;right;</span><br><span class="line">        &#125;<span class="comment">//其实自己去花几个图就能看出来了 它的好处在于空间复杂度为O（1）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h3><p> 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 </p><p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1642854960270.png" alt="1642854960270"></p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>采用DFS，最大的深度应该是左子树的最大深度+右子树的最大深度 然后+1 -1这种最好是到时候试试看最后的结果。</p><blockquote><p>  直径 &#x3D; 左子树高度 + 右子树高度； 我理解应该是 (左树高度 - 1) + (右子树高度 - 1) ， 因为直径是边的个数，而非节点的个数。 </p></blockquote><p>把104结合起来，先是求得左右子树的最大深度，然后再加起来，与max相比较。</p><h4 id="递归（之后照着官方解答写一下）"><a href="#递归（之后照着官方解答写一下）" class="headerlink" title="递归（之后照着官方解答写一下）"></a>递归（<strong>之后照着官方解答写一下</strong>）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//感觉还是不够简约 需要继续改进  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="comment">// 节点为空返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)) + <span class="number">1</span>; <span class="comment">// 左/右子树最大深度+1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">finddeep</span><span class="params">(TreeNode*root,<span class="type">int</span> &amp;maxd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxl=<span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> maxr=<span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">        <span class="built_in">finddeep</span>(root-&gt;left,maxd);</span><br><span class="line">        <span class="built_in">finddeep</span>(root-&gt;right,maxd);</span><br><span class="line">        maxd=<span class="built_in">max</span>(maxd,maxr+maxl);</span><br><span class="line">        <span class="keyword">return</span>  maxd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxd=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">finddeep</span>(root,maxd);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxd=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="keyword">return</span> maxd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">depth</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">Left</span> <span class="operator">=</span> depth(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">Right</span> <span class="operator">=</span> depth(node.right);</span><br><span class="line">        maxd=Math.max(Left+Right,maxd);<span class="comment">//将每个节点最大直径(左子树深度+右子树深度)当前最大值比较并取大者</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(Left,Right)+<span class="number">1</span>;<span class="comment">//返回节点深度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><p>就正常翻转即可，换个位置</p><p>这里如果用中序遍历的话可能就会出错了，因为可能会翻转两次。这道题目感觉是能遍历基本上就能翻转（除了中序） </p><h4 id="递归-5"><a href="#递归-5" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!root)</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">            TreeNode* i=root-&gt;left;</span><br><span class="line">            root-&gt;left=root-&gt;right;</span><br><span class="line">            root-&gt;right=i;<span class="comment">//直接用swap(root-&gt;left,root-&gt;right)更快一点</span></span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">swap</span>(node-&gt;left, node-&gt;right);          <span class="comment">// 节点处理逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h3><p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>直接按照普通二叉树来判断，全部遍历</p><p>1，<strong>确定递归函数的参数和返回值</strong></p><p>​    参数应该是root 和res 返回值是res 因为最后是返回节点个数</p><p>2，<strong>确定终止条件</strong></p><p>​    终止条件应该是！root，但遍历到的节点为空的时候就返回</p><p>3，<strong>确定单层递归逻辑</strong></p><p>相当于是中左右 因为之前已经判断了root不为0，那么就res++，之后再继续遍历左右子树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(TreeNode *root,<span class="type">int</span> &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="built_in">count</span>(root-&gt;left,res);</span><br><span class="line">        <span class="built_in">count</span>(root-&gt;right,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">count</span>(root,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="完全二叉树做法"><a href="#完全二叉树做法" class="headerlink" title="完全二叉树做法"></a>完全二叉树做法</h4><p>参考代码随想录</p><p>完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。</p><p>对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。</p><p>对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode* left = root-&gt;left;</span><br><span class="line">        TreeNode* right = root-&gt;right;</span><br><span class="line">        <span class="type">int</span> leftHeight = <span class="number">0</span>, rightHeight = <span class="number">0</span>; <span class="comment">// 这里初始为0是有目的的，为了下面求指数方便</span></span><br><span class="line">        <span class="keyword">while</span> (left) &#123;  <span class="comment">// 求左子树深度</span></span><br><span class="line">            left = left-&gt;left;</span><br><span class="line">            leftHeight++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right) &#123; <span class="comment">// 求右子树深度</span></span><br><span class="line">            right = right-&gt;right;</span><br><span class="line">            rightHeight++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftHeight == rightHeight) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftHeight) - <span class="number">1</span>; <span class="comment">// 注意(2&lt;&lt;1) 相当于2^2，所以leftHeight初始为0</span></span><br><span class="line">        &#125;<span class="comment">//当遍历到是满二叉树的时候那么可以直接2^x-1 然后再相加</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right) + <span class="number">1</span>;<span class="comment">//左子树节点个数+右子树节点个数+1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 </p></blockquote><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>计算左孩子的<strong>最大深度</strong>以及计算右孩子的<strong>最大深度</strong>，如果高度差大于1，那么就返回false 否则就返回true。</p><p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1642922579488.png" alt="1642922579488"></p><p>这里高度和深度的概念其实是不一样的，<strong>具体情况还是得依照它所给的例子去分析</strong></p><p>思路三步走</p><p>1，明确递归参数和返回值</p><p>递归的参数只有root 返回值为false或者true</p><p>2，确定终止条件 </p><p>终止条件就是全部都遍历完，然后有一个返回值</p><p>3，确定单层逻辑</p><p>对于每一个root，如果abs(左-右)&lt;&#x3D;1，那么继续遍历它下面的子树，得到下面子树的返回值，否则&gt;1的话就直接返回false；</p><h4 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Maxdepth</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">Maxdepth</span>(root-&gt;left),<span class="built_in">Maxdepth</span>(root-&gt;right))+<span class="number">1</span>;<span class="comment">//这里加一不加一都一样的，因为是同时+1，但实际上</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(<span class="built_in">Maxdepth</span>(root-&gt;left)-<span class="built_in">Maxdepth</span>(root-&gt;right))&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">isBalanced</span>(root-&gt;left)&amp;&amp;<span class="built_in">isBalanced</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="257-二叉树的所有路径-好题啊"><a href="#257-二叉树的所有路径-好题啊" class="headerlink" title="**257. 二叉树的所有路径**好题啊"></a>**<a href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径</a>**好题啊</h3><blockquote><p>以为只用了递归，其实还用了回溯 </p></blockquote><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1642923293931.png" alt="1642923293931"></p><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p><strong>好好看看代码随想录的部分</strong></p><p>首先这里出现了[“1-&gt;2-&gt;5”,”1-&gt;3”]这个东西，那么应该是返回的字符串，如果说是[[132,12],[35,84]]那么应该是vector&lt;vector<int>&gt; ,这个之前做过类似的题目</p><p>所以这里应该要定义vector<string> ，然后是说从根节点到叶子节点的路径，显然就是dfs了，然后这里还需要用到回溯，因为需要不断地返回上一个节点。</p><p>感觉最后应该是return(root-&gt;string),这样不断地返回上一层。</p><p>方法一：深度优先搜索<br>思路与算法</p><p>最直观的方法是使用深度优先搜索。在深度优先搜索遍历二叉树时，我们需要考虑当前的节点以及它的孩子节点。</p><p>如果当前节点不是<strong>叶子节点</strong>，则在当前的路径末尾添加该节点，并继续递归遍历该节点的每一个孩子节点。<br>如果当前节点是<strong>叶子节点</strong>，则在当前路径末尾添加该节点后我们就得到了一条从根节点到叶子节点的路径，将该路径加入到答案即可</p><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">construct_paths</span><span class="params">(TreeNode*root,string path,vector&lt;string&gt; &amp;allpath)</span></span>&#123; <span class="comment">//path用来存储这条路径所有的节点</span></span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        path+=<span class="built_in">to_string</span>(root-&gt;val);<span class="comment">//int转string</span></span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right)<span class="comment">//如果两个都不是空节点的话,不能这样，这样是错的，有一个是不空也需要+ -&gt;,应该要改成如果是叶子节点的话</span></span><br><span class="line">            allpath.<span class="built_in">push_back</span>(path);<span class="comment">// 把路径加入到答案中</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">                path+=<span class="string">&quot;-&gt;&quot;</span>; <span class="comment">// 当前节点不是叶子节点，继续递归遍历</span></span><br><span class="line">                <span class="built_in">construct_paths</span>(root-&gt;left,path,allpath);</span><br><span class="line">                <span class="built_in">construct_paths</span>(root-&gt;right,path,allpath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; allpath;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">construct_paths</span>(root,<span class="string">&quot;&quot;</span>,allpath);</span><br><span class="line">        <span class="keyword">return</span> allpath;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="代码随想录-递归-回溯"><a href="#代码随想录-递归-回溯" class="headerlink" title="代码随想录 递归+回溯"></a>代码随想录 递归+回溯</h4><p><a href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html#%E9%80%92%E5%BD%92">https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html#%E9%80%92%E5%BD%92</a></p><ol start="257"><li><p><strong>二叉树的所有路径</strong></p><p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1642925930485.png" alt="1642925930485"></p></li></ol><p><strong>那么为什么使用了vector 结构来记录路径呢？</strong> 因为在下面处理单层递归逻辑的时候，要做回溯，使用vector方便来做回溯。</p><p>可能有的同学问了，我看有些人的代码也没有回溯啊。</p><p><strong>其实是有回溯的，只不过隐藏在函数调用时的参数赋值里</strong>，下文我还会提到。</p><p>这里我们先使用vector结构的path容器来记录路径</p><p>回溯：返回之前的地方再重新进行计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; path, vector&lt;string&gt;&amp; result)</span> </span>&#123; <span class="comment">//这里注意是对原来的path的引用，只有这样才能够实现回溯</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="comment">// 这才到了叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left == <span class="literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            string sPath;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                sPath += <span class="built_in">to_string</span>(path[i]);</span><br><span class="line">                sPath += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sPath += <span class="built_in">to_string</span>(path[path.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">            result.<span class="built_in">push_back</span>(sPath);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;left, path, result);</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;right, path, result);</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯 把</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">traversal</span>(root, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h3><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p><p>叶子节点 是指没有子节点的节点</p><blockquote><p>相似的一道题</p></blockquote><p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1642928630284.png" alt="1642928630284"></p><h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">allpath</span><span class="params">(TreeNode* root ,vector&lt;<span class="type">int</span>&gt;&amp;path,vector&lt;<span class="type">int</span>&gt;&amp;res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right)<span class="comment">//说明是叶子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;path.<span class="built_in">size</span>();i++)</span><br><span class="line">                sum+=path[i];</span><br><span class="line">            res.<span class="built_in">push_back</span>(sum);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">allpath</span>(root-&gt;left,path,res);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">allpath</span>(root-&gt;right,path,res);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;<span class="comment">//path用来保存路径 res用来保存所有路径的值</span></span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">allpath</span>(root,path,res);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">if</span>(res[i]==targetSum)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a></h3><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1643179897001.png" alt="1643179897001"></p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>和上一题的区别就是在于它要把所有的路径都写出来，并且放到pathsum函数中，这个与之前做过的某一道题相似，可以写成path.push_back(res)这么写感觉更加形象一点。</p><h4 id="深度遍历DFS"><a href="#深度遍历DFS" class="headerlink" title="深度遍历DFS"></a>深度遍历DFS</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findall</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt;path,<span class="type">int</span> targetSum,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right)<span class="comment">//如果是叶子节点的话</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size=path.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">            sum+=path[i];</span><br><span class="line">            <span class="keyword">if</span>(sum==targetSum)</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="built_in">findall</span>(root-&gt;left,path,targetSum,res);</span><br><span class="line">            <span class="built_in">findall</span>(root-&gt;right,path,targetSum,res);</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">findall</span>(root,path,targetSum,res);</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">404. 左叶子之和</a></h3><p> 计算给定二叉树的所有左叶子之和。 </p><p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1642928761136.png" alt="1642928761136"></p><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>1，确定递归参数和返回值</p><p>递归参数，左右子树，返回值和相加</p><p>2，确定终止条件</p><p>！root 还是得到叶节点才知道需不需要加，如果只有右节点还是得继续遍历</p><p>3，确定单层逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> lv=<span class="built_in">sumOfLeftLeaves</span>(root-&gt;left);<span class="comment">//左子树的左叶子之和</span></span><br><span class="line">        <span class="type">int</span> rv=<span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);<span class="comment">//右子树左叶子之和</span></span><br><span class="line">        <span class="type">int</span> mv=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left&amp;&amp;!root-&gt;left-&gt;right&amp;&amp;!root-&gt;left-&gt;left)<span class="comment">//说明是左节点</span></span><br><span class="line">            mv=root-&gt;left-&gt;val;</span><br><span class="line">        <span class="type">int</span> sum=mv+lv+rv;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更加简洁 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>&amp;&amp;root-&gt;left-&gt;right==<span class="literal">NULL</span>&amp;&amp;root-&gt;left-&gt;left==<span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right)+root-&gt;left-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left)+<span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">654. 最大二叉树</a></h3><p>给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:</p><p>创建一个根节点，其值为 nums 中的最大值。<br>递归地在最大值 左边 的 子数组前缀上 构建左子树。<br>递归地在最大值 右边 的 子数组后缀上 构建右子树。<br>返回 nums 构建的 最大二叉树 。</p><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><p>这个其实就是<strong>先序遍历</strong>，先构建根节点再构建左子树和右子树。</p><p>有点类似于中序遍历和后序遍历构造二叉树，这道题目不难，主要就找到一些边界条件,这里<strong>注意一下</strong>带入的是0和n-1，然后如果left&gt;right那么就会返回，就直接代入下标了，不然可能会出现数组越界的现象</p><p>分治法构建二叉树，左边一个右边一个。</p><h4 id="递归构建二叉树"><a href="#递归构建二叉树" class="headerlink" title="递归构建二叉树"></a>递归构建二叉树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">createtree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)<span class="comment">//这个条件要注意一下</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> max=INT_MIN;</span><br><span class="line">        <span class="type">int</span> loc;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (max&lt;nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                max=nums[i];</span><br><span class="line">                loc=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//找到最大值</span></span><br><span class="line">        TreeNode *root=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(max);<span class="comment">//TreeNode* node = new TreeNode(0);如果不知道可以初始化为0，如果初始化为-1说明还得再加一个</span></span><br><span class="line">        root-&gt;left=<span class="built_in">createtree</span>(nums,left,loc<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right=<span class="built_in">createtree</span>(nums,loc+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">createtree</span>(nums,<span class="number">0</span>,size<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h3><p> 给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。 </p><p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1642858943926.png" alt="1642858943926"></p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>这道题目还是好好看官方答案解析吧，其实看懂了就会了,G(n)</p><p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1642860127985.png" alt="1642860127985"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">G</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        G[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                G[i] += G[j - <span class="number">1</span>] * G[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> G[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h4><p>卡特兰数<br>$$<br>C_0&#x3D;1 \qquad C_n&#x3D;\frac{2(2n+1)}{n+2}<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> C = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            C = C * <span class="number">2</span> * (<span class="number">2</span> * i + <span class="number">1</span>) / (i + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)C;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><p>构建一个vector容器，按照中序遍历依次输入到vector中，然后再来一个for循环，如果对于任意 满足res[i]&lt;res[i+1] return true 否则 return false。</p><h4 id="递归-6"><a href="#递归-6" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode*root,vector&lt;<span class="type">int</span>&gt; &amp;res)</span> <span class="comment">//这里是引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;left,res);</span><br><span class="line">    res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">inorder</span>(root-&gt;right,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">inorder</span>(root,res);</span><br><span class="line">        <span class="type">int</span> size=res.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res[i]&gt;=res[i+<span class="number">1</span>])<span class="comment">//这里注意一下是等于 222 就不满足 需要严格大于</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>还有一种思路是直接用一个指针代替前面的val然后再比较，这样的话会快很多，而且空间复杂度不要那么高,这里不能用int，只能用long，因为太大 了</p><p>先看左子树，然后赋值，再看右子树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> pre = LONG_MIN; <span class="comment">// 前一节点设为最小值</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isValidBST</span>(root-&gt;left))&#123; <span class="comment">// 验证左子树</span></span><br><span class="line">            <span class="keyword">if</span>(pre &lt; root-&gt;val)&#123; <span class="comment">// 前一节点(当前节点左子树最大值)小于当前节点</span></span><br><span class="line">                pre = root-&gt;val; <span class="comment">// 前一节点变为当前节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;right); <span class="comment">// 验证右子树</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>LONG_MAX LONG_MIN </p><p>INT_MAX INT_MIN  这种还是挺方便的 </p></blockquote><h3 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h3><p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。</p><p>你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。</p><p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1643183984991.png" alt="1643183984991"></p><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><p>1，参数，root val 返回值 root</p><p>2，终止条件 读到树底了或者说是读到了root-&gt;val&#x3D;&#x3D;val</p><p>3，<strong>单层逻辑</strong> 等于的时候就返回root，大于往右读 小于往左读 然后要返回nullpur 不然不能返回所有的值</p><h4 id="递归-7"><a href="#递归-7" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;<span class="comment">//读到底还没命中就返回错误了</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val==val) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val&gt;val) <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left,val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val&lt;val) <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right,val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h3><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><p>说的任意两个不同节点值，由于是二叉搜索树，是按照顺序来的，所以其实只要按照左中右的中序遍历就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findmin</span><span class="params">(TreeNode *root,<span class="type">int</span> &amp;pre,<span class="type">int</span> &amp;minroot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">findmin</span>(root-&gt;left,pre,minroot);<span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span>(pre==<span class="number">-1</span>)</span><br><span class="line">            pre=root-&gt;val;<span class="comment">//先找到最后面的值 </span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            minroot=<span class="built_in">min</span>(minroot,root-&gt;val-pre);<span class="comment">//pre表示的是前一个节点  中间一部分是对根节点的操作</span></span><br><span class="line">            pre = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">findmin</span>(root-&gt;right,pre,minroot);<span class="comment">//右</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> minroot=INT_MAX;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">findmin</span>(root,pre,minroot);</span><br><span class="line">        <span class="keyword">return</span> minroot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a><a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h3><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 任意顺序 返回。</p><p>假定 BST 满足如下定义：</p><p>结点左子树中所含节点的值 小于等于 当前节点的值<br>结点右子树中所含节点的值 大于等于 当前节点的值<br>左子树和右子树都是二叉搜索树</p><h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><p>1，建立一个哈希表，construct_map,之后遍历哈希表，找到那个众数max_value，再遍历一遍，把value值等于众数的key push进res中，res就是对应的需要返回的数组</p><h4 id="非二叉搜索树解法"><a href="#非二叉搜索树解法" class="headerlink" title="非二叉搜索树解法"></a>非二叉搜索树解法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">constructmap</span><span class="params">(TreeNode *root,unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        map[root-&gt;val]++;</span><br><span class="line">        <span class="built_in">constructmap</span>(root-&gt;left,map);</span><br><span class="line">        <span class="built_in">constructmap</span>(root-&gt;right,map);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">constructmap</span>(root,map);<span class="comment">//构造哈希表</span></span><br><span class="line">        <span class="type">int</span> size=map.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxvalue=<span class="number">0</span>,key;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;p:map)<span class="comment">//遍历哈希表,找到那个最大值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.second&gt;maxvalue)</span><br><span class="line">            &#123;</span><br><span class="line">                maxvalue=p.second;</span><br><span class="line">                key=p.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;p:map)<span class="comment">//遍历哈希表</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.second==maxvalue)</span><br><span class="line">            &#123;</span><br><span class="line">               res.<span class="built_in">push_back</span>(p.first);<span class="comment">//把key放进去</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//补充一个更快速的解法，参照了代码随想录</span></span><br><span class="line"><span class="comment">/*主要是遍历的部分变快了 可以少一步循环</span></span><br><span class="line"><span class="comment">        for(auto&amp;p:map)//遍历哈希表,找到那个最大值</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            if(p.second==maxvalue)</span></span><br><span class="line"><span class="comment">             res.push_back(p.first);//把key放进去</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            if(p.second&gt;maxvalue)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                res.clear();  //这一步是关键 如果发现不是那么就清空</span></span><br><span class="line"><span class="comment">                maxvalue=p.second;</span></span><br><span class="line"><span class="comment">                key=p.first;</span></span><br><span class="line"><span class="comment">                res.push_back(p.first);//把key放进去</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h4 id="代码随想录-1"><a href="#代码随想录-1" class="headerlink" title="代码随想录"></a>代码随想录</h4><p>2，搜索树解法：直接建立，左中右，如果相同就count++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> maxCount; <span class="comment">// 最大频率</span></span><br><span class="line">    <span class="type">int</span> count; <span class="comment">// 统计频率</span></span><br><span class="line">    TreeNode* pre;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">searchBST</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">searchBST</span>(cur-&gt;left);       <span class="comment">// 左</span></span><br><span class="line">                                    <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">NULL</span>) &#123; <span class="comment">// 第一个节点</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == cur-&gt;val) &#123; <span class="comment">// 与前一个节点数值相同</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 与前一个节点数值不同</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur; <span class="comment">// 更新上一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count == maxCount) &#123; <span class="comment">// 如果和最大值相同，放进result中</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &gt; maxCount) &#123; <span class="comment">// 如果计数大于最大值频率</span></span><br><span class="line">            maxCount = count;   <span class="comment">// 更新最大频率</span></span><br><span class="line">            result.<span class="built_in">clear</span>();     <span class="comment">// 很关键的一步，不要忘记清空result，之前result里的元素都失效了</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">searchBST</span>(cur-&gt;right);      <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        maxCount = <span class="number">0</span>;</span><br><span class="line">        TreeNode* pre = <span class="literal">NULL</span>; <span class="comment">// 记录前一个节点</span></span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">searchBST</span>(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1643269918208.png" alt="1643269918208"></p><h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h4><p>首先我们要找到p，q节点的路径，返回一个vector<int> path ,然后再构造哈希表，或者数组，之后再一个个地去比较，找到深度最深的那个公共祖先。<strong>这道题目的正经做法应该是回溯的</strong>。</p><p>错误示范&#x2F;&#x2F;不写了 太丢脸了 好好学学人家</p><h4 id="参考的"><a href="#参考的" class="headerlink" title="参考的"></a>参考的</h4><p> 因为是递归，<strong>使用函数后可认为左右子树已经算出结果</strong>，这句话要记住，道出了递归的精髓 </p><p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1643274571181.png" alt="1643274571181"></p><p>代码简洁明了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q) </span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">            </span><br><span class="line">        TreeNode* left =  <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">NULL</span>) <span class="comment">//说明不在左边</span></span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">NULL</span>)<span class="comment">//说明不在右边</span></span><br><span class="line">            <span class="keyword">return</span> left;      </span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right) <span class="comment">// p和q在两侧</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 必须有返回值 不然会报错，很多题目都会出现这种不能全部打出来的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者：Wilson79</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/c-jing-dian-di-gui-si-lu-fei-chang-hao-li-jie-shi-/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h3 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h4><p>由于树是二叉搜索树，那么可以利用二叉搜索树的性质，即左子树的结点的值都小于根结点，右子树的结点都大于根结点。可以分为3种情况。</p><p>1.若p的值小于root的值，q的值大于根的值，那么root就是最近公共祖先。<br>2.若p的值和q的值都小于root的值，那么代表最近祖先一定在root的左子树中<br>3.若p的值和q的值都大于root的值，那么代表最近祖先一定在root的右子树中<br>2.3情况发生的话，只需要继续递归即可，而 1则是递归出口。</p><h4 id="递归-8"><a href="#递归-8" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==q||root==p)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&gt;=p-&gt;val&amp;&amp;root-&gt;val&gt;=q-&gt;val) <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;=p-&gt;val&amp;&amp;root-&gt;val&lt;=q-&gt;val) <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">return</span> root;  <span class="comment">//它这个是返回来一个最近的值 就是两边都满足了 不断地返回最接近的root</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h3><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p><h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h4><p>只需要在叶子节点这里删除就可以了</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; val) root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; val) root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span> root;<span class="comment">//这里返回的root其实就是原来的root-&gt;right,和root-&gt;left 这里有点难理解，模拟一下就出来了。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="迭代-3"><a href="#迭代-3" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *node=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *cur=root;</span><br><span class="line">        TreeNode *parent=root;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            parent=cur;<span class="comment">//保存父节点</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val&gt;val) cur=cur-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> cur=cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *node=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(parent-&gt;val&gt;val)</span><br><span class="line">        parent-&gt;left=node;</span><br><span class="line">        <span class="keyword">else</span> parent-&gt;right=node;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h3><h4 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h4><p>根据二叉搜索树的性质</p><p>如果目标节点大于当前节点值，则去右子树中删除；<br>如果目标节点小于当前节点值，则去左子树中删除；<br>如果目标节点就是当前节点，分为以下三种情况：<br>其无左子：其右子顶替其位置，删除了该节点；<br>其无右子：其左子顶替其位置，删除了该节点；<br>其左右子节点都有：其左子树转移到其右子树的最左节点的左子树上，然后右子树顶替其位置，由此删除了该节点。</p><p>之前也有链表删除的题目</p><p><strong>删除的本质是返回root节点的左节点或者右节点</strong>，就像是链表的题，返回的是假设进入的是p，那么返回的是p-&gt;next，那么p就被删除了，当然正常还应该加个free（），但好像lc都没加</p><h4 id="参考的递归"><a href="#参考的递归" class="headerlink" title="参考的递归"></a>参考的递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &gt; root-&gt;val)    root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);     <span class="comment">// 去右子树删除</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; root-&gt;val)    root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);  <span class="comment">// 去左子树删除</span></span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">// 当前节点就是要删除的节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (! root-&gt;left)   <span class="keyword">return</span> root-&gt;right; <span class="comment">// 情况1，欲删除节点无左子</span></span><br><span class="line">            <span class="keyword">if</span> (! root-&gt;right)  <span class="keyword">return</span> root-&gt;left;  <span class="comment">// 情况2，欲删除节点无右子</span></span><br><span class="line">            TreeNode* node = root-&gt;right;           <span class="comment">// 情况3，欲删除节点左右子都有 </span></span><br><span class="line">            <span class="keyword">while</span> (node-&gt;left)          <span class="comment">// 寻找欲删除节点右子树的最左节点</span></span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            node-&gt;left = root-&gt;left;    <span class="comment">// 将欲删除节点的左子树成为其右子树的最左节点的左子树</span></span><br><span class="line">            root = root-&gt;right;         <span class="comment">// 欲删除节点的右子顶替其位置，节点被删除</span></span><br><span class="line">            <span class="comment">//这里也可以直接返回root-&gt;right 不返回root 也相当于被删除了 return root-&gt;right;  </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h3><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1643355350843.png" alt="1643355350843"></p><h4 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h4><p>这道题目其实就是删除二叉树中的节点的加强版，只不过不是删除一个节点，而是删除一些节点。就还是返照上面的去做就好了。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        root-&gt;left=<span class="built_in">trimBST</span>(root-&gt;left,low,high);</span><br><span class="line">        root-&gt;right=<span class="built_in">trimBST</span>(root-&gt;right,low,high);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;low||root-&gt;val&gt;high)<span class="comment">//确定是要删除的节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (! root-&gt;left)   <span class="keyword">return</span> root-&gt;right; <span class="comment">// 情况1，欲删除节点无左子</span></span><br><span class="line">            <span class="keyword">if</span> (! root-&gt;right)  <span class="keyword">return</span> root-&gt;left;  <span class="comment">// 情况2，欲删除节点无右子</span></span><br><span class="line">            TreeNode* node = root-&gt;right;           <span class="comment">// 情况3，欲删除节点左右子都有 </span></span><br><span class="line">            <span class="keyword">while</span> (node-&gt;left)          <span class="comment">// 寻找欲删除节点右子树的最左节点</span></span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            node-&gt;left = root-&gt;left;    <span class="comment">// 将欲删除节点的左子树成为其右子树的最左节点的左子树</span></span><br><span class="line">            <span class="keyword">return</span> root-&gt;right;         <span class="comment">// 欲删除节点的右子顶替其位置，节点被删除</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里也可以直接返回root-&gt;right 不返回root 也相当于被删除了 return root-&gt;right;  </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="代码随想录-2"><a href="#代码随想录-2" class="headerlink" title="代码随想录"></a>代码随想录</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; low) <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;right, low, high);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; high) <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;left, low, high);</span><br><span class="line">        root-&gt;left = <span class="built_in">trimBST</span>(root-&gt;left, low, high);</span><br><span class="line">        root-&gt;right = <span class="built_in">trimBST</span>(root-&gt;right, low, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h3><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p><p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1643356655425.png" alt="1643356655425"></p><h4 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h4><p>每次都找中间节点，中间节点的左边构造左子树，中间节点的右边构造右子树,具体可以参照654，先序遍历构造二叉树，先根节点再左右子树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造树基本上就是</span></span><br><span class="line"><span class="keyword">if</span>(!root)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">root-&gt;left=<span class="built_in">function</span>();</span><br><span class="line">root-&gt;right=<span class="built_in">function</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="递归-9"><a href="#递归-9" class="headerlink" title="递归"></a>递归</h4><p>这里可以发现，传入数据里面是没有root的，因为如果有root的话需要重新去定义，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cnostruct_tree</span>(nums,root-&gt;left,low,high)<span class="comment">//如果是这样的话会报错的，因为root-&gt;left并不存在，所以我们不需要传入root-&gt;left，直接传入(nums,low,mid-1)，然后再在函数里面去建立Treenode就可以了，654里面中也没有传入root，说明构建</span></span><br></pre></td></tr></table></figure><p><strong>构建二叉树的题目不需要传入root-&gt;left或者root-&gt;right,直接在里面进行创建就行了</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">construct_tree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;nums,<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(low&gt;high)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        TreeNode *root=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">        root-&gt;val=nums[mid];</span><br><span class="line">        root-&gt;left=<span class="built_in">construct_tree</span>(nums,low,mid<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right=<span class="built_in">construct_tree</span>(nums,mid+<span class="number">1</span>,high);<span class="comment">//这里需要注意一下需要排除掉mid，即变成mid+1和mid-1</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size=nums.<span class="built_in">size</span>();</span><br><span class="line">        TreeNode *root=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">        root=<span class="built_in">construct_tree</span>(nums,<span class="number">0</span>,size<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h3><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><p>节点的左子树仅包含键 小于 节点键的节点。<br>节点的右子树仅包含键 大于 节点键的节点。<br>左右子树也必须是二叉搜索树。</p><p><img src="C:\Users\DELL\Desktop\LeetCode\树.assets\1643358490718.png" alt="1643358490718"></p><h4 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h4><p>首先先确定是中序遍历，左&gt;中&gt;右。但似乎这道题目是要累加，可以定义一个数组，先访问右子树，然后压进去，再根 再左子树，然后每次再累加，依次类推。</p><p>感觉这道题目也可以利用栈来做，直接记录栈的值就行，或者直接累加试试，记录sum的值。</p><p><strong>反中序</strong> 其实看一眼就发现了</p><h4 id="递归，数组"><a href="#递归，数组" class="headerlink" title="递归，数组"></a>递归，数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">transTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,TreeNode* root)</span></span>&#123;<span class="comment">//这里注意 &amp;nums 这里是引用，而不是单纯地取值，因为如果单纯地取值的话返回时是返回前一个num，即空数组 那么就不变了</span></span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        root-&gt;right=<span class="built_in">transTree</span>(nums,root-&gt;right); <span class="comment">//右</span></span><br><span class="line"></span><br><span class="line">        nums.<span class="built_in">push_back</span>(root-&gt;val);<span class="comment">//中  把之前记录的数据全部累加</span></span><br><span class="line">        <span class="type">int</span> size=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;val+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left=<span class="built_in">transTree</span>(nums,root-&gt;left);<span class="comment">//左</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">transTree</span>(nums,root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="递归，sum求和"><a href="#递归，sum求和" class="headerlink" title="递归，sum求和"></a>递归，sum求和</h4><p>递归三部曲：</p><p>1，返回值：root，调用参数：root和sum</p><p>2，终止条件： 读到空节点 ！root return nullptr</p><p>3,中间逻辑，root-&gt;left &#x3D;;&#x2F;&#x2F;<strong>因为返回的是节点 所以肯定是root的叶子节点等于巴拉巴拉之类的</strong> 然后这里发现最好是先遍历右子树，然后从后往前依次累加即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">transTree</span><span class="params">(<span class="type">int</span> &amp;sum,TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        root-&gt;right=<span class="built_in">transTree</span>(sum,root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        sum+=root-&gt;val;</span><br><span class="line">        root-&gt;val=sum;</span><br><span class="line"></span><br><span class="line">        root-&gt;left=<span class="built_in">transTree</span>(sum,root-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">transTree</span>(sum,root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//执行时间 击败80%  内存消耗 击败 90% 因为这里不需要定义数组了  时间空间复杂度都是O（n）</span></span><br></pre></td></tr></table></figure><h4 id="栈，递归"><a href="#栈，递归" class="headerlink" title="栈，递归"></a>栈，递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈反中序</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>* <span class="built_in">convertBST</span>(<span class="keyword">struct</span> TreeNode* root)&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>** stack = (<span class="keyword">struct</span> TreeNode**)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode*) * <span class="number">10001</span>);</span><br><span class="line">    <span class="type">int</span> top = <span class="number">-1</span>, num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* p = root;</span><br><span class="line">    <span class="keyword">while</span>(p || top!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            stack[++top] = p;</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        p = stack[top--];</span><br><span class="line">        num += p-&gt;val;</span><br><span class="line">        p-&gt;val = num;</span><br><span class="line">        p = p-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网公式总结</title>
      <link href="/2019/11/02/2021-11-29%20%E8%AE%A1%E7%BD%91%E5%85%AC%E5%BC%8F%E6%80%BB%E7%BB%93%20144013/"/>
      <url>/2019/11/02/2021-11-29%20%E8%AE%A1%E7%BD%91%E5%85%AC%E5%BC%8F%E6%80%BB%E7%BB%93%20144013/</url>
      
        <content type="html"><![CDATA[<h3 id="奈奎斯特定理"><a href="#奈奎斯特定理" class="headerlink" title="奈奎斯特定理"></a>奈奎斯特定理</h3><p>$$<br>理想低通道下的极限数据传输率&#x3D;2W\log_2V<br>$$</p><h3 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h3><p>$$<br>信道的极限数据传输率&#x3D;Wlog_2(1+S&#x2F;N) (单位为b&#x2F;s)<br>$$</p><p>W：信道的带宽。 S：信道所传输信号的平均功率。 S&#x2F;N：信噪比 </p><p>信噪比&#x3D;10log10(S&#x2F;N) 当S&#x2F;N&#x3D;1000时，信噪比为30dB</p><h3 id="比特率和波特率的转换关系"><a href="#比特率和波特率的转换关系" class="headerlink" title="比特率和波特率的转换关系"></a>比特率和波特率的转换关系</h3><p>$$<br>比特率&#x3D;波特率*log_2n<br>$$</p><p>一个码元含有n个比特的信息量。</p><p>P43 采用8种相位，每种相位各有两种幅度的QAM调制方法，在1200Baud的信号传输速率能为 4800b&#x2F;s。</p><blockquote><p>$log_216&#x3D;4<br>$ </p><p>$数据传输率&#x3D;1200*4&#x3D;4800b&#x2F;s$</p></blockquote><h2 id="计网的基本指标："><a href="#计网的基本指标：" class="headerlink" title="计网的基本指标："></a>计网的基本指标：</h2><ul><li><p>带宽：单位是b&#x2F;s</p></li><li><p>时延</p><p>$整个传输过程的总时延&#x3D;发送时延+传播时延+（处理时延+传播时延 （后面两个一般忽略不计））$</p><p>$发送时延&#x3D;分组帧长&#x2F;信道宽度$</p><p>$传播时延&#x3D;信道长度&#x2F;传播速率$</p><p><strong>ps:信号的传播速率是信号在信道上传播的速率，与信道的发送速率无关。</strong><br><strong>信道表示为端对端的距离，一般单位为km。传播速率单位一般为km&#x2F;s</strong></p><p><strong>信道的数据发送&#x2F;数据传输速率一般为Mb&#x2F;s</strong></p></li><li><p>往返时延RTT<br>这个地方经常有坑，会说单向的传播时间为，需要注意。</p><p>$RTT&#x3D;2*端与端的距离&#x2F;传播速度$ </p></li><li><p>吞吐量。指单位的时间内通过某个网络的数据量.<br>$$<br>吞吐量&#x3D;\frac{有效数据}{发送周期}<br>$$</p></li><li><p>信道利用率：指在整个过程中有多少数据是通过的。即</p><p>$信道利用率&#x3D;(L&#x2F;C)&#x2F;T $ </p><p>L:表示T内发送L比特的数据    C：表示发送方数据传输率<br>T：发送周期，指从开始发送数据，到收到第一个确认帧数为止</p></li></ul><ul><li>最小帧长度&#x3D;数据传输速率*RTT，这里还需要注意一点最小帧长度一般是用B(字节)表示，而数据传输速率往往是用b（比特来表示），转换时别忘记$\times$8</li></ul><h2 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h2><p>​    $发送窗口+接收窗口\leq2^n$</p><ol><li>停等协议：发送窗口&#x3D;1，接受窗口&#x3D;1</li><li>后退N帧协议：发送窗口&gt;1,接收窗口&#x3D;1</li><li>选择重传协议：发送窗口&gt;1,接收窗口&gt;1。一般取发送窗口&#x3D;接收窗口&#x3D;$2^{n-1}$</li></ol><h3 id="停等协议例题："><a href="#停等协议例题：" class="headerlink" title="停等协议例题："></a><strong>停等协议例题：</strong></h3><p>​    一个信道的传播速率为4kb&#x2F;s，单向传播时延为30ms，如果使停等协议的信道利用率达到80%，要求的数据帧长至少为（）</p><blockquote><p>解析：<br>$$<br>80%&#x3D;\frac{L&#x2F;4}{L&#x2F;4+RTT}&#x3D;\frac{L&#x2F;4}{L&#x2F;4+2*30ms}<br>$$<br>解得 L&#x3D;960bit</p></blockquote><h3 id="GBN例题"><a href="#GBN例题" class="headerlink" title="GBN例题"></a><strong>GBN例题</strong></h3><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211128192022881.png" alt="image-20211128192022881"></p><blockquote><p>解析：</p><p>捎带确认：不需要考虑传输时延，只需要考虑传播时延</p><p>最大传输率需要考虑信道带宽和GBN协议，</p><p>最大传输率&#x3D;min{信道带宽，根据GBN协议算得的传输率}</p><p>信道带宽&#x3D;100Mb&#x2F;s</p><p>GBN：</p><p>甲的发送窗口尺寸为1000，即最多可发1000*1000B&#x3D;1MB</p><p>$$<br>最大传输率&#x3D;\frac{1MB}{1000B&#x2F;100MB+50ms+50ms}&#x3D;80Mb&#x2F;s<br>$$<br>则选取最小的为80Mb&#x2F;s</p></blockquote><p><strong>ch3 3.4.5</strong><br><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211128192940513.png" alt="image-20211128192940513"></p><blockquote><p>解析：</p><p><strong>停等协议</strong><br>    发一帧，都要应答。需要考虑接收端的传输时延<br>$$<br>最大利用率&#x3D;\frac{传播长度&#x2F;数据传输率}{2<em>单向传播时延+2</em>传播长度&#x2F;数据传输率}<br>\&#x3D;\frac{1k&#x2F;50k}{2<em>270+2</em>1k&#x2F;50k}\&#x3D;\frac{0.02}{0.58}&#x3D;3.4%<br>$$<br><strong>GBN</strong></p><p>发送窗口满足$1&lt;W\leq2^n-1$  则有发送窗口为7，则有在第一帧的数据传输周几内，总共发送了7帧数<br>$$<br>最大利用率&#x3D;\frac{7<em>传播长度&#x2F;数据传输率}{2</em>单向传播时延+2<em>传播长度&#x2F;数据传输率}\&#x3D;7</em>3.4%<br>$$</p><h3 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a><strong>选择重传</strong></h3><p>发送窗口&#x3D;接收窗口&#x3D;$2^{n-1}&#x3D;4$<br>$$<br>最大利用率&#x3D;4*3.4%&#x3D;13.8%<br>$$</p></blockquote><p>[2017真题]<img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211128195043044.png" alt="image-20211128195043044"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211128195058752.png" alt="image-20211128195058752"></p><blockquote><p>解析：</p><p>确认序号和发送序号均为3bit，捎带确认，由GBN协议得，发送窗口为$2^{n}-1&#x3D;7$<br>$$<br>最大信道利用率&#x3D;\frac{7<em>单帧发送时延}{单帧发送时延+传播时延}\&#x3D;\frac{7</em>8<em>1000b&#x2F;100Mb&#x2F;s}{0.96</em>10^{-3}+2<em>8</em>1000b&#x2F;100Mb}\&#x3D;50%<br>$$<br><strong>很经典的题目</strong></p></blockquote><p><strong>距离变化</strong></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211128200615636.png" alt="image-20211128200615636"></p><blockquote><p>$$<br>最小帧长度&#x3D;数据传输速率<em>RTT &#x3D;数据传输速度</em>2*端与端的距离&#x2F;传播速度<br>$$</p><p>$$<br>\Delta l&#x3D;数据传输速度<em>2</em>\Delta s&#x2F;传播速度&#x3D;80m<br>$$</p><p>最小帧长度和距离是成正比的关系，只要把公式写清楚就很容易得到答案为D选项。</p><p>补充：<strong>以太网最小数据帧为64B，数据长度为46-1500B，即IP数据报小于46B时需要填充</strong></p><p>详见【2012年真题】<img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211129140255618.png" alt="image-20211129140255618"><br>最后是3,5号分组总长度为40（28H)字节小于46字节，说明需要填充</p></blockquote><h3 id="吞吐率-x2F-吞吐量"><a href="#吞吐率-x2F-吞吐量" class="headerlink" title="吞吐率&#x2F;吞吐量"></a>吞吐率&#x2F;吞吐量</h3><p>P82 <img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211129142220989.png" alt="image-20211129142220989"></p><blockquote><p>一个发送周期的时间为$512B<em>8&#x2F;(64kb&#x2F;s)+2</em>270ms&#x3D;0.604s$ </p><p>吞吐量&#x2F;吞吐率&lt;&#x3D;数据发送速率</p><ul><li>发送窗口尺寸为1时，吞吐率为1x512Bx8&#x2F;0.604s&#x3D;6.8kb&#x2F;s </li><li>发送窗口尺寸为7时，吞吐率为7x512Bx8&#x2F;0.604s&#x3D;47.56kb&#x2F;s</li><li>发送窗口尺寸为17时，<strong>注意</strong>当发送窗口大于0.604&#x2F;0.064即$\geq$10,发送窗口能保证连续发送，此时吞吐率&#x3D;64kb&#x2F;s</li></ul></blockquote><p>P234</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211129143809736.png" alt="image-20211129143809736"></p><blockquote><p>这里提到了带宽，需要注意吞吐量$\leq$带宽。</p><p>RTT&#x3D;40ms 则<br>$$<br>吞吐率&#x3D;<br>$$</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 408 </tag>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公式总结</title>
      <link href="/2019/11/02/%E5%85%AC%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2019/11/02/%E5%85%AC%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h3 id="奈奎斯特定理"><a href="#奈奎斯特定理" class="headerlink" title="奈奎斯特定理"></a>奈奎斯特定理</h3><p>$$<br>理想低通道下的极限数据传输率&#x3D;2W\log_2V<br>$$</p><h3 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h3><p>$$<br>信道的极限数据传输率&#x3D;Wlog_2(1+S&#x2F;N) (单位为b&#x2F;s)<br>$$</p><p>W：信道的带宽。 S：信道所传输信号的平均功率。 S&#x2F;N：信噪比 </p><p>信噪比&#x3D;10log10(S&#x2F;N) 当S&#x2F;N&#x3D;1000时，信噪比为30dB</p><h3 id="比特率和波特率的转换关系"><a href="#比特率和波特率的转换关系" class="headerlink" title="比特率和波特率的转换关系"></a>比特率和波特率的转换关系</h3><p>$$<br>比特率&#x3D;波特率*log_2n<br>$$</p><p>一个码元含有n个比特的信息量。</p><p>P43 采用8种相位，每种相位各有两种幅度的QAM调制方法，在1200Baud的信号传输速率能为 4800b&#x2F;s。</p><blockquote><p>$log_216&#x3D;4<br>$ </p><p>$数据传输率&#x3D;1200*4&#x3D;4800b&#x2F;s$</p></blockquote><h3 id="计网的基本指标："><a href="#计网的基本指标：" class="headerlink" title="计网的基本指标："></a>计网的基本指标：</h3><ul><li><p>带宽：单位是b&#x2F;s<br>带宽&#x3D;数据传输速率*宽带。（宽带：n位）</p></li><li><p>时延</p><p>$整个传输过程的总时延&#x3D;发送时延+传播时延+（处理时延+传播时延 （后面两个一般忽略不计））$</p><p>$发送时延&#x3D;分组帧长&#x2F;信道宽度$</p><p>$传播时延&#x3D;信道长度&#x2F;传播速率$</p><p><strong>ps:信号的传播速率是信号在信道上传播的速率，与信道的发送速率无关。</strong><br><strong>信道表示为端对端的距离，一般单位为km。传播速率单位一般为km&#x2F;s</strong></p><p><strong>信道的数据发送&#x2F;数据传输速率一般为Mb&#x2F;s</strong></p></li><li><p>往返时延RTT<br>这个地方经常有坑，会说单向的传播时间为，需要注意。</p><p>$RTT&#x3D;2*端与端的距离&#x2F;传播速度$ </p></li><li><p>吞吐量。指单位的时间内通过某个网络的数据量.<br>$$<br>吞吐量&#x3D;\frac{有效数据}{发送周期}<br>$$</p></li><li><p>信道利用率：指在整个过程中有多少数据是通过的。即</p><p>$信道利用率&#x3D;(L&#x2F;C)&#x2F;T $ </p><p>L:表示T内发送L比特的数据    C：表示发送方数据传输率<br>T：发送周期，指从开始发送数据，到收到第一个确认帧数为止</p></li></ul><ul><li>最小帧长度&#x3D;数据传输速率*RTT，这里还需要注意一点最小帧长度一般是用B(字节)表示，而数据传输速率往往是用b（比特来表示），转换时别忘记$\times$8</li><li>直通交换方式只检查帧的目的地址 6B</li></ul><h3 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h3><p>​    $发送窗口+接收窗口\leq2^n$ 滑动窗口的作用是进行流量控制</p><ol><li>停等协议：发送窗口&#x3D;1，接受窗口&#x3D;1</li><li>后退N帧协议：发送窗口&gt;1,接收窗口&#x3D;1</li><li>选择重传协议：发送窗口&gt;1,接收窗口&gt;1。一般取发送窗口&#x3D;接收窗口&#x3D;$2^{n-1}$</li></ol><h3 id="停等协议例题："><a href="#停等协议例题：" class="headerlink" title="停等协议例题："></a><strong>停等协议例题：</strong></h3><p>​    一个信道的传播速率为4kb&#x2F;s，单向传播时延为30ms，如果使停等协议的信道利用率达到80%，要求的数据帧长至少为（）</p><blockquote><p>解析：<br>$$<br>80%&#x3D;\frac{L&#x2F;4}{L&#x2F;4+RTT}&#x3D;\frac{L&#x2F;4}{L&#x2F;4+2*30ms}<br>$$<br>解得 L&#x3D;960bit</p></blockquote><h3 id="GBN例题"><a href="#GBN例题" class="headerlink" title="GBN例题"></a><strong>GBN例题</strong></h3><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211128192022881.png" alt="image-20211128192022881"></p><blockquote><p>解析：</p><p>捎带确认：不需要考虑传输时延，只需要考虑传播时延</p><p>最大传输率需要考虑信道带宽和GBN协议，</p><p>最大传输率&#x3D;min{信道带宽，根据GBN协议算得的传输率}</p><p>信道带宽&#x3D;100Mb&#x2F;s</p><p>GBN：</p><p>甲的发送窗口尺寸为1000，即最多可发1000*1000B&#x3D;1MB</p><p>$$<br>最大传输率&#x3D;\frac{1MB}{1000B&#x2F;100MB+50ms+50ms}&#x3D;80Mb&#x2F;s<br>$$<br>则选取最小的为80Mb&#x2F;s</p></blockquote><p><strong>ch3 3.4.5</strong><br><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211128192940513.png" alt="image-20211128192940513"></p><blockquote><p>解析：</p><p><strong>停等协议</strong><br>    发一帧，都要应答。需要考虑接收端的传输时延<br>$$<br>最大利用率&#x3D;\frac{传播长度&#x2F;数据传输率}{2<em>单向传播时延+2</em>传播长度&#x2F;数据传输率}<br>\&#x3D;\frac{1k&#x2F;50k}{2<em>270+2</em>1k&#x2F;50k}\&#x3D;\frac{0.02}{0.58}&#x3D;3.4%<br>$$<br><strong>GBN</strong></p><p>发送窗口满足$1&lt;W\leq2^n-1$  则有发送窗口为7，则有在第一帧的数据传输周几内，总共发送了7帧数<br>$$<br>最大利用率&#x3D;\frac{7<em>传播长度&#x2F;数据传输率}{2</em>单向传播时延+2<em>传播长度&#x2F;数据传输率}\&#x3D;7</em>3.4%<br>$$</p></blockquote><h3 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a><strong>选择重传</strong></h3><p>发送窗口&#x3D;接收窗口&#x3D;$2^{n-1}&#x3D;4$<br>$$<br>最大利用率&#x3D;4*3.4%&#x3D;13.8%<br>$$</p><p>[2017真题]<img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211128195043044.png" alt="image-20211128195043044"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211128195058752.png" alt="image-20211128195058752"></p><blockquote><p>解析：</p><p>确认序号和发送序号均为3bit，捎带确认，由GBN协议得，发送窗口为$2^{n}-1&#x3D;7$<br>$$<br>最大信道利用率&#x3D;\frac{7<em>单帧发送时延}{单帧发送时延+传播时延}\&#x3D;\frac{7</em>8<em>1000b&#x2F;100Mb&#x2F;s}{0.96</em>10^{-3}+2<em>8</em>1000b&#x2F;100Mb}\&#x3D;50%<br>$$<br><strong>很经典的题目</strong></p></blockquote><h3 id="距离变化"><a href="#距离变化" class="headerlink" title="距离变化"></a><strong>距离变化</strong></h3><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211128200615636.png" alt="image-20211128200615636"></p><blockquote><p>$$<br>最小帧长度&#x3D;数据传输速率<em>RTT &#x3D;数据传输速度</em>2*端与端的距离&#x2F;传播速度<br>$$</p><p>$$<br>\Delta l&#x3D;数据传输速度<em>2</em>\Delta s&#x2F;传播速度&#x3D;80m<br>$$</p><p>最小帧长度和距离是成正比的关系，只要把公式写清楚就很容易得到答案为D选项。</p><blockquote><p>补充：<strong>以太网最小数据帧为64B，数据长度为46-1500B，即IP数据报小于46B时需要填充</strong>详见【2012年真题】<img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211129140255618.png" alt="image-20211129140255618"><br>最后是3,5号分组总长度为40（28H)字节小于46字节，说明需要填充</p></blockquote></blockquote><h3 id="吞吐率-x2F-吞吐量"><a href="#吞吐率-x2F-吞吐量" class="headerlink" title="吞吐率&#x2F;吞吐量"></a>吞吐率&#x2F;吞吐量</h3><p>吞吐量表示IP数据报总的大小，而有效数据传输速度只考虑数据的传输。</p><p>但如果除去首部则吞吐量和有效数据传输意思一样。</p><p>P82 <img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211129142220989.png" alt="image-20211129142220989"></p><blockquote><p>一个发送周期的时间为$512B<em>8&#x2F;(64kb&#x2F;s)+2</em>270ms&#x3D;0.604s$ </p><p>吞吐量&#x2F;吞吐率&lt;&#x3D;数据发送速率</p><ul><li>发送窗口尺寸为1时，吞吐率为1x512Bx8&#x2F;0.604s&#x3D;6.8kb&#x2F;s </li><li>发送窗口尺寸为7时，吞吐率为7x512Bx8&#x2F;0.604s&#x3D;47.56kb&#x2F;s</li><li>发送窗口尺寸为17时，<strong>注意</strong>当发送窗口大于0.604&#x2F;0.064即$\geq$10,发送窗口能保证连续发送，此时吞吐率&#x3D;64kb&#x2F;s</li></ul></blockquote><p>P234</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211129143809736.png" alt="image-20211129143809736"></p><blockquote><p>这里提到了带宽，需要注意吞吐量$\leq$带宽。</p><p>RTT&#x3D;40ms 则<br>$$<br>吞吐率&#x3D;\frac{65535*8b}{40ms}&#x3D;13.107Mb&#x2F;s<br>$$<br>$线道效率&#x3D;吞吐率&#x2F;信道带宽&#x3D;\frac{13.107Mb&#x2F;s}{1000Mb&#x2F;s}$  </p><p><font color='red'>注意单位</font></p></blockquote><h3 id="分片问题"><a href="#分片问题" class="headerlink" title="分片问题"></a>分片问题</h3><p>一种8片首4</p><p>重点还是知道片偏移的基本单位是8B，MTU&#x3D;800B，总长度为1580B的IP数据报分片，数据部分只能分为776（内部只能是8的倍数）+20， 776+20，8+20. </p><p>之前计网也出过类似的大题 （忘记哪一年了，最后是画个图）<strong>去年考过了 感觉今年考的概率不大。</strong></p><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>​    基本概念：</p><p>​    MSS：一个最大的报文长度,一般为1KB左右</p><p>​    <strong>发送窗口的上限值&#x3D;min{拥塞窗口（cwnd），接收窗口（rwnd）}</strong></p><p>​    拥塞窗口</p><ol><li>慢开始+拥塞避免：先指数规律增长，之后达到门限值后加法增长，达到拥塞窗口后发送网络拥塞，经过一个RTT后变为1.</li><li>快重传快恢复：先指数规律增长，之后达到门限值后加法增长，达到拥塞窗口后收到三个冗余ACK，经过一个RTT后<strong>变为拥塞窗口的1&#x2F;2</strong>.再线性增大<br>特征：发三个冗余的ACK报文，新的rwnd&#x3D;1&#x2F;2rwnd，开始线性增长。门限值也变为原来的一半</li></ol><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211129164125266.png" alt="image-20211129164125266"></p><blockquote><p><strong>收到3个ACK后</strong>，拥塞窗口和门限值都变成了17KB，之后线性增大。经过4个RTT后变为了21KB</p></blockquote><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211129164326088.png" alt="image-20211129164326088"></p><blockquote><p>这个其实就是问发送窗口是多少，发送窗口的上限值&#x3D;min{cwnd，rwnd}，一定要注意发送窗口大小 </p><p>cwnd&#x3D;4&gt;ss,说明是线性增长，经过一个RTT后，cmwd&#x3D;5，接收窗口字段从确认报文中得到，rwnd&#x3D;2，则取2KB</p></blockquote><p>TCP三次握手的第一次握手的第一个握手不携带数据，但是要消耗一个序号，之前好像有道真题涉及过这个内容。使得好像是从501-1500，总共1000B</p><h2 id="协议问题"><a href="#协议问题" class="headerlink" title="协议问题"></a>协议问题</h2><p>PPP 数据链路层 不可靠传输，具有错误检测能力，但不具备纠错能力</p><h1 id="计组"><a href="#计组" class="headerlink" title="计组"></a>计组</h1><h2 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章 计算机系统概述"></a>第一章 计算机系统概述</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>CPU时钟周期，主频，CPI,CPU执行时间，MIPS,MFLOPS</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211129181056384.png" alt="image-20211129181056384"></p><p>常用的CPU主频有1.8GHz,2.4GHz,2.8GHz.</p><p>CPU的执行一段程序时间与CPI，和该程序段所含指令数目成正比和主频成反比，想象一下，主频越大，运行速度越快，执行一条指令所花的时间就越短。</p><p>指令字长是机器字长的整数倍。</p><p>机器字长是指的用于CPU内部用于证书运算的数据通路的宽度，因此CPU内部进行数据运算，存储传送的不见，宽度需要一直，机器字长等于CPOU内部用于整数运算的位数和通用寄存器宽度（通用寄存器可以存储数据）</p><h3 id="主频和时钟周期数的对应关系"><a href="#主频和时钟周期数的对应关系" class="headerlink" title="主频和时钟周期数的对应关系"></a>主频和时钟周期数的对应关系</h3><p>$$<br>1s&#x3D;10^3ms&#x3D;10^6μs&#x3D;10^9ns<br>$$</p><p>主频往往都是几十MHz，则选取几个比较常见的作为记忆。</p><p>8MHz&#x3D;125ns    50MHz&#x3D;20ns    500MHz&#x3D;2ns  （ns*M&#x3D;1000）</p><h3 id="CPU-执行时间的基本计算"><a href="#CPU-执行时间的基本计算" class="headerlink" title="CPU 执行时间的基本计算"></a>CPU 执行时间的基本计算</h3><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211129182738286.png" alt="image-20211129182738286"></p><blockquote><p>18，CPU速度提高50%，是变成了原来的1.5倍，则所需时间变为16s，总共花70s</p><p>19，0.7x1.2x20&#x3D;16.8</p><p>20,   2&#x2F;1.5:1&#x2F;1.2&#x3D;1.6</p></blockquote><h3 id="MIPS相关"><a href="#MIPS相关" class="headerlink" title="MIPS相关"></a>MIPS相关</h3><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211129183256640.png" alt="image-20211129183256640"><br>$$<br>MIPS&#x3D;\frac{主频}{CPI*10^6}<br>$$<br>若含有多种指令，那么CPI则为这多种指令的数学期望。CPI&#x3D;3，则经过计算得                $MIPS&#x3D;1200MHz&#x2F;3M&#x3D;400$</p><h2 id="第二章-数据计算"><a href="#第二章-数据计算" class="headerlink" title="第二章 数据计算"></a>第二章 数据计算</h2><h3 id="数据基本概念"><a href="#数据基本概念" class="headerlink" title="数据基本概念"></a>数据基本概念</h3><p>混个脸熟，2的次方</p><table><thead><tr><th align="center">2^14</th><th align="center">2^16</th><th align="center">2^18</th><th align="center">2^20</th></tr></thead><tbody><tr><td align="center">16384</td><td align="center">65536</td><td align="center">262144</td><td align="center">1048576</td></tr></tbody></table><p>PEZ</p><h3 id="补码运算"><a href="#补码运算" class="headerlink" title="补码运算"></a>补码运算</h3><p>负数补码转十进制技巧：找和它相加为2^n的最小整数再取反</p><p>例子int型 FFFF FFFFH为-1 FFFF FFFE为-2。</p><p>【2018】</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211129185842186.png" alt="image-20211129185842186"></p><blockquote><p>x&#x3D;FFFF FFDFH，只需要看前两位DF，对应的为-(256-13*16+15)或者这么想DF+21刚好进位，则x&#x3D;-21H&#x3D;-33</p><p>y&#x3D;0000 0041H,y&#x3D;65（<font color='red'><strong>这里注意41H对应的是4*16+1&#x3D;65</strong></font>）,x-y&#x3D;-98，98转为16进制为62H，则对应的机器数为FFFF FF9EH,因为9EH+62H&#x3D;2^8. 选C</p></blockquote><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211129190819237.png" alt="image-20211129190819237"></p><blockquote><p>注意一下补码的范围为<br>$$<br>-2^{n-1}&lt;&#x3D;x&lt;&#x3D;2^{n-1}-1<br>$$<br>这道题刚好没有溢出，因为左边符号位和进位是一样的，取到了-128</p></blockquote><h3 id="小端方式存储"><a href="#小端方式存储" class="headerlink" title="小端方式存储"></a>小端方式存储</h3><p>低位数据存储在低位地址，高位数据存储在高位地址，<strong>和我们正常的思考是不一样的</strong>，但是<strong>内部是正常顺序</strong></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211129191253260.png" alt="image-20211129191253260"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211129191323812.png" alt="image-20211129191323812"></p><p>计算机是用的小端存储</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211129191736216.png" alt="image-20211129191736216"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211129191625700.png" alt="image-20211129191625700"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211129191633140.png" alt="image-20211129191633140"></p><p>算数右移：负数高位补1，正数高位补0</p><p>逻辑右移：都补0</p><h3 id="浮点数的计算"><a href="#浮点数的计算" class="headerlink" title="浮点数的计算"></a>浮点数的计算</h3><p><strong>IEE754符1阶8尾23</strong></p><p>尾数的范围为1~2-2^-23(1.0-1.111…1(后面23个1))</p><p>阶数的范围为-127-126    偏置值为127</p><p>表示范围为<br>$$<br>2^{-126}-2^{127}*(2-2^{-23})<br>$$</p><p>左规相当于x2，右规相当于&#x2F;2</p><p>【2015】</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211129192857365.png" alt="image-20211129192857365"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211129193419319.png" alt="image-20211129193419319"></p><p><strong>补充：</strong></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211129193504155.png" alt="image-20211129193504155"></p><p><strong>具体题目可以再去研究一下【2017年】的真题大题</strong></p><h3 id="算数逻辑单元"><a href="#算数逻辑单元" class="headerlink" title="算数逻辑单元"></a>算数逻辑单元</h3><p>无符号数看CF：$最高位进位\oplus sub$  1:为溢出 0为不溢出</p><p>有符号数看OF:$最高位进位\oplus 次高位进位$ 1:为溢出 0为不溢出</p><p>SF：符号标志位，只看最高位</p><p>零标志位：ZF&#x3D;1，说明结果为0，否则为1；</p><h2 id="第三章-存储系统"><a href="#第三章-存储系统" class="headerlink" title="第三章 存储系统"></a>第三章 存储系统</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p>存储速度：数据传输率&#x3D;数据的宽度&#x2F;存储周期</p><blockquote><ol><li>存储时间（Ta）指启动一次存储器的操作到完成该操作所经历的时间，分为<strong>读出和写入时间</strong></li><li>存储周期：一次完整的读写操作所需要的时间</li><li>主存带宽：数据传输率，单位B&#x2F;s或者b&#x2F;s</li></ol></blockquote></li></ul><p>存取周期表示从开始存取到下一次存取一整个时间，存取周期&#x3D;存取时间+恢复时间</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211129200116246.png" alt="image-20211129200116246"></p><p>地址线的宽度和MAR相同，数据线总线的宽度和MDR相同</p><h3 id="Cache命中率问题："><a href="#Cache命中率问题：" class="headerlink" title="Cache命中率问题："></a>Cache命中率问题：</h3><p>(剩余见笔记)</p><p>Cache的总命中次数为Nc，访问主存的总次数为Nm，则命中率H为<br>$$<br>H&#x3D;N_c&#x2F;(N_c+N_m)<br>$$<br>为跳过</p><ol><li><p>主存和Cache不同时访问：</p><p>设命中率为x，Cache的存取时间为$t_1$,主存的存取时间为$t_2,那么总时间t为<br>$$<br>t&#x3D;t_1+(1-x)*t_2<br>$$</p></li><li><p>主存和Cache同时访问</p><p>设命中率为x，Cache的存取时间为$t_1$,主存的存取时间为$t_2,那么总时间t为<br>$$<br>t&#x3D;x*t_1+(1-x)*t_2<br>$$</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130133157946.png"></p></li></ol><blockquote><p>将上式代入得<br>$$<br>115&#x3D;x<em>100+（1-x）</em>1000<br>$$<br>解得x&#x3D;98.33%</p></blockquote><h3 id="DRAM-SRAM"><a href="#DRAM-SRAM" class="headerlink" title="DRAM,SRAM"></a>DRAM,SRAM</h3><p>​    基本概念：</p><p>​    DRAM采用地址复用技术需要考虑两根行列片选线，按行优先</p><h3 id="存储芯片的问题"><a href="#存储芯片的问题" class="headerlink" title="存储芯片的问题"></a>存储芯片的问题</h3><p>​    8KB*8位，位扩展，后面的位数变化。字拓展KB前面的数字变化。</p><p>​    <strong>MAR的位数决定主存地址空间的大小</strong>【2011真题】</p><p>​    <strong>存储芯片片选问题</strong></p><p>​    线选法：有点：不需要地址译码器，线路简单。每一片都需要一条地址线。缺点：容易造成资源的浪费</p><h4 id="译码片选法：（难点）"><a href="#译码片选法：（难点）" class="headerlink" title="译码片选法：（难点）"></a><strong>译码片选法：（难点）</strong></h4><p>假设需要n个片选信号，则需要$log_2n$位来产生片选信号。低地址位是作为各芯片接入的地址端，而高地址位作为译码器的输入端。</p><p>注意点：</p><p>1，看低地址端是$A_0还是A_{15}$ 有的题目还不一样。</p><p>2，<strong>求最小地址时，只看<font color='red'>组成芯片</font>的地址线即可，不用看数据线</strong>，例子，芯片为A:8Kx4位和B：8Kx8位的地址线都是13位，但是如果组成64Kx8位的存储器，那么需要A芯片的片选线为4位。B芯片的片选线为5位。</p><p>【2010】</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130141117161.png" alt="image-20211130141117161"></p><blockquote><p>总共需要8个片选信号，那么高$long_28&#x3D;3$位为作为片选信号</p><p>0B1FH&#x3D;0000 1011 0001 1111 看2k，对应的为低11位，即0000 1<font color='red'>011 0001 1111 </font>取高三位为片选信号，则该所在芯片为1（从0开始）号芯片，地址范围为 00 001 <font color='red'>000 0000 0000</font>-00 001 <font color='red'>111 1111 1111</font></p><p>即地址范围为0800H-08FFH。</p></blockquote><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130141830176.png" alt="image-20211130141830176"></p><blockquote><p>同样的，不需要看位数，只需要看前面的地址线，地址线为15位，前面三位为片选地址，总共18位，所在为7号芯片，地址为0011 1000 0000 0000 0000（后面15个0）-0011 1111 1111 1111 1111 即38000H-3FFFFH</p></blockquote><h3 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h3><h4 id="高位交叉编址"><a href="#高位交叉编址" class="headerlink" title="高位交叉编址"></a>高位交叉编址</h4><p>​    总是先在一个模块内访问，然后再去范围下一个模块，不能做到并行访问，不能提高存储器的吞吐率。</p><h4 id="低位交叉编址"><a href="#低位交叉编址" class="headerlink" title="低位交叉编址"></a><strong>低位交叉编址</strong></h4><p>​    4年没考了….</p><p>​    四体并行交叉编址：在一个周期内能访问4个模块。</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201163514971.png" alt="image-20211201163514971"></p><p>​    2013年考过8体交叉</p><p>​    P115 低位地址为体号，高位地址为体内地址，采用低位交叉编址后，在不改变每个模块存取周期的前提下，采用流水线方式<strong>并行存取</strong>，提高存储器的带框</p><p>设模块字长等于数据总线宽度，模块存取一个字的存取周期为T，总线传送周期为R，流水线方式存起，存储器模块数应大于等于<br>$$<br>m&#x3D;T&#x2F;r<br>$$<br>m交叉存取度，四体并行交叉，则m&#x3D;4，经过r时间延迟后启动下一个模块，交叉存储器要求其模块数必须大于等于m，以保证经过mxr的时间后再次启动时，上次存取已经完成了。那么连续存取m个字所需要的时间为<br>$$<br>t_1&#x3D;T+(m-1)*r<br>$$<br><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130144847261.png" alt="image-20211130144847261"></p><p>例题：</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130144907109.png" alt="image-20211130144907109"></p><p>并行存储，带宽能大很多。</p><p>【2015】</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130145325267.png" alt="image-20211130145325267"></p><blockquote><p>如果给定的访存地址在相邻的4次访问中出现在同一个模块里，那么就会出现访存冲突，这道题目中出现访存冲突的为8000和8004</p></blockquote><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130145600645.png" alt="image-20211130145600645"></p><blockquote><p>double型为8B，这道题主要是考察画图，四体交叉，每次最多读写32位，那么r&#x3D;1&#x2F;4T，那么读取x所需要的总时间为t&#x3D;T+(m-1)r&#x3D;T+7&#x2F;4T&#x3D;11&#x2F;4T,需要3个存储周期。或者画图也可得到答案。</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130145855772.png" alt="image-20211130145855772"></p></blockquote><p> <img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130145914308.png" alt="image-20211130145914308"></p><blockquote><p>1)32*4&#x3D;128位</p><p>2）错误，意思是100ns内每个个体可以向CPU提供32位二进制信息，但实际上上在一个存储周期内400ns内每个个体才能向CPU提供32位信息，在100ns内整个存储器可以提供32位的信息</p></blockquote><blockquote><p>一个存储体在一个周期内能传输一个字，那么主机最快200&#x2F;4&#x3D;50ns读出一个字</p><p>带宽&#x3D;数据量&#x2F;存储周期&#x3D;16B&#x2F;200ns&#x3D;80MB&#x2F;s</p><p>不能，换成高位交叉后通常起不到存储器读写的速度，不符合局部性原理，通常只有一个存储器在不停地忙碌，其他的都是空闲的。 </p></blockquote><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130153813260.png" alt="image-20211130153813260"></p><h3 id="Cache块的计算"><a href="#Cache块的计算" class="headerlink" title="Cache块的计算"></a><strong>Cache块的计算</strong></h3><p>Cache每行：有效位+脏位+替换控制位（LRU,FIFO之类的）+tag+数据</p><p>tag位通过计算主存地址空间大小来计算</p><p>总线的时钟周期和CPU的时钟周期是不一样的。</p><h3 id="Cache传输的综合题-【2013】"><a href="#Cache传输的综合题-【2013】" class="headerlink" title="Cache传输的综合题 【2013】"></a>Cache传输的综合题 【2013】</h3><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130161700960.png" alt="image-20211130161700960"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130161733047.png" alt="image-20211130161733047" style="zoom:50%;" /><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130161808189.png" alt="image-20211130161808189" style="zoom:50%;" /></p><blockquote><p>r一般是等于一个总线时钟周期</p><p>(3) 突发传送：通过系统总线将首地址和命令传给存储器，存储器把数据传入CPU，CPU再把数据传入到Cache</p><p>总共有3步，传送首地址和命令    存储器准备数据（8体交叉） 传送数据</p><p>传送首地址和命令：5ns（题目中给了）<br>存储器准备数据（8体交叉，其实这里可以看出来是8体交叉，总线的周期为5ns，40ns&#x2F;5ns&#x3D;8）根据公式<br>$$<br>t&#x3D;T+(m-1)*r&#x3D;40ns+(8-1)*5&#x3D;75ns<br>$$<br>传送32字节数据：5ns</p><p>总共花费5+75+5&#x3D;85ns</p></blockquote><blockquote><p>解法2：<img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130162743300.png" alt="image-20211130162743300"></p><p>把数据准备好之后就传送数据</p></blockquote><blockquote><p>第四问：</p><p>总时间分为Cache缺失和Cache不缺失两种情况。</p><p>Cache命中时平均每条指令需要4个CPU时钟周期，4*1.25ns&#x3D;5ns。</p><p>Cache不命中时需要通过一个度突发传送总线事物来完成读取，则为1.2*85ns+5ns&#x3D;107ns（前面是处理缺失，后面是处理完缺失之后还得再读一次，，<strong>不是说主存和Cache同时读</strong>）</p><p>总共时间为：100x0.95x5ns+100x0.05x107ns</p><p>解法2</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130163550106.png" alt="image-20211130163550106"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130163433530.png" alt="image-20211130163433530"></p></blockquote><h3 id="第四章-指令系统"><a href="#第四章-指令系统" class="headerlink" title="第四章 指令系统"></a>第四章 指令系统</h3><h3 id="扩展操作码的指令格式"><a href="#扩展操作码的指令格式" class="headerlink" title="扩展操作码的指令格式"></a>扩展操作码的指令格式</h3><p>​    注意两点：</p><p>1，不允许短码是长码的前缀，符合哈夫曼编码</p><p>2，各个指令的操作码一定不能重复。</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130180028193.png" alt="image-20211130180028193"></p><blockquote><p>二地址指令，地址总共占了24位，还剩下8位，其中250条作为二地址指令，剩余256-250&#x3D;6条，那么总共的单地址条数为6*2^12条，即24K，此时没有一条零地址指令。</p></blockquote><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130180408558.png" alt="image-20211130180408558"></p><blockquote><p>地址字段6位，三地址指令地址位占18位，指令为29条，说明op≥5，但op&#x3D;5时，还剩余3条，则可以表示3*2^6&#x3D;192条，那么最多能表示192条，因此指令最少为23位</p><p><strong>又因为指令是按照字节编址，那么最少为24位</strong></p></blockquote><h3 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h3><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130183618848.png" alt="image-20211130183618848"></p><p>操作码 寻址特征位（用来区分是什么类型的寻址）</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130181330125.png" alt="image-20211130181330125"></p><p>A的范围为2^8</p><p>间接寻址：指向A地址的内容，又因为存储器是按照字编址的，所以间接寻址指向的是16位，即2^16。正常应该是0-2^16-1</p><p>变址寻址：2^16+A</p><p>相对寻址：PC不变，为定值，只能改变A,则为256</p><h2 id="第五章-中央处理器"><a href="#第五章-中央处理器" class="headerlink" title="第五章 中央处理器"></a>第五章 中央处理器</h2><h3 id="微程序控制编码"><a href="#微程序控制编码" class="headerlink" title="微程序控制编码"></a>微程序控制编码</h3><p>​    直接编码：n个微命令要求微指令的操作字段为n位。</p><p>​    字段直接编码，互斥+1</p><p>​        <img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130185159577.png" alt="image-20211130185159577"></p><blockquote><p>14，分别对应 8 4 13 6 7,那么对应的操作控制字段为3+2+4+3+3&#x3D;15</p><p>15，2+4*32&#x3D;130，那么需要$log_2{130}$向上取整为8</p></blockquote><h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><p>流水线的基本公式<br>$$<br>TP&#x3D;\frac{n}{T_k}<br>$$<br>n为任务数，$T_k$为处理完n个任务所用的时间。</p><p>实际吞吐率为<br>$$<br>TP&#x3D;\frac{n}{（k+n-1）\Delta t}<br>$$<br>k表示流水线的段数, $\Delta t$为时钟周期。</p><p>流水线加速比：<br>$$<br>S&#x3D;\frac{kn}{k+n-1}<br>$$<br>当n-&gt;∞时，Smax&#x3D;k</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130190828865.png" alt="image-20211130190828865"></p><blockquote><p>流水线的段数k&#x3D;3，n&#x3D;8 则代入公式得<br>$$<br>S&#x3D;\frac{3*8}{3+8-1}&#x3D;2.4<br>$$</p></blockquote><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130191203004.png" alt="image-20211130191203004"></p><blockquote><p>四段流水线，k&#x3D;4<br>$$<br>吞吐率&#x3D;\frac{100}{100+3-1<em>\Delta t}&#x3D;\frac{100}{103</em>1&#x2F;(1.03<em>10^9)}&#x3D;1</em>10^9<br>$$</p></blockquote><h2 id="第六章-总线"><a href="#第六章-总线" class="headerlink" title="第六章 总线"></a>第六章 总线</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130192241964.png" alt="image-20211130192241964"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130192254687.png" alt="image-20211130192254687"></p><p>带宽：传输率。宽度：16位，32位这些</p><p>n通道的存储器总线，那么对应的总带宽要相应地*n。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130192554050.png" alt="image-20211130192554050"></p><blockquote><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130192615733.png" alt="image-20211130192615733"></p></blockquote><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130192347893.png" alt="image-20211130192347893"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130192634482.png" alt="image-20211130192634482"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130192401804.png" alt="image-20211130192401804"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130192656315.png" alt="image-20211130192656315"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130192714236.png" alt="image-20211130192714236"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211130192722536.png" alt="image-20211130192722536"></p><h2 id="第七章-输入输出系统"><a href="#第七章-输入输出系统" class="headerlink" title="第七章 输入输出系统"></a>第七章 输入输出系统</h2><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><p>​    用OS里面一段印象比较深的一段话来概括：</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201140718571.png" alt="image-20211201140718571"></p><h3 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h3><p>​    CPU和I&#x2F;O串行工作。</p><h3 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h3><h4 id="程序中断流程图："><a href="#程序中断流程图：" class="headerlink" title="程序中断流程图："></a>程序中断流程图：</h4><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201161558473.png"></p><p>​    异常：发生在CPU内部</p><p>​    1，故障： 不能回到断点，比如非法操作码，除数为0</p><p>​    2，自陷：主动陷入，返回自陷的下一条指令否则会陷入循环</p><p>​    3，终止：硬件故障。</p><p>外部中断：</p><p>​    I&#x2F;O中断：键盘输入，esc等，时钟中断</p><p><strong>不同点</strong>：缺页或者溢出是由特定指令在执行过程中产生的。        异常的检测由CPU自己完成，而中断必须通过总线获取中断源的表示信息</p><p>中断隐指令：是由硬件实现的</p><p><strong>硬件完成</strong>：关中断，保存断电，中断服务程序寻址</p><p><strong>软件完成</strong>：保存现场和屏蔽字，开中断，执行中断服务，关中断，恢复现场和屏蔽字，开中断 中断返回。<strong>（保存和恢复现场和屏蔽字需要一气呵成）</strong>需要关中断</p><h4 id="多重中断"><a href="#多重中断" class="headerlink" title="多重中断"></a>多重中断</h4><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201140412711.png" alt="image-20211201140412711"></p><blockquote><p>主要是数一：1越多优先级越高，表示把所有人包括自己的中断源都屏蔽了。</p><p>选C</p></blockquote><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201143517710.png" alt="image-20211201143517710"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201143523994.png" alt="image-20211201143523994"></p><blockquote><p>要满足题意，L1只屏蔽自己和L3，为01010，选C</p></blockquote><h4 id="中断方式的计算"><a href="#中断方式的计算" class="headerlink" title="中断方式的计算"></a>中断方式的计算</h4><p>【2011】【2014】</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201143638109.png" alt="image-20211201143638109"></p><blockquote><p>4,50Mhz,时钟周期为20ns，查询200次，一次500个时钟周期，则总共时长为<br>$$<br>百分比为&#x3D;20<em>200</em>500*10^{-9}&#x3D;0.2%<br>$$</p></blockquote><blockquote><p>5,每400ns就要处理一次中断，在400ns里有100ns是用于中断请求的处理和响应的。那么 占比为100&#x2F;400&#x3D;25%，中断响应的延迟时间意思是最迟可以过50ns再响应，相当于从0-100-&gt;50-150,但<strong>是占比还是没有变化。</strong></p></blockquote><p>【2019】</p><p>​    <img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201140819008.png" alt="image-20211201140819008"></p><blockquote><p>A</p></blockquote><h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h3><p><font color='red'>把22CO的课后题目做好就行，感觉基本上涵盖和IO输入输出的所有计算了。</font></p><h4 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h4><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201163405330.png" alt="image-20211201163405330"></p><p><strong>周期挪用考的比较多类似于2016年的真题</strong></p><p>每个<strong>机器周期</strong>结束后，CPU可以响应DMA请求。DMA与主存交互数据时，通过周期窃取方式，窃取的是<strong>存取周期</strong>。</p><p>DMA（靠硬件电路实现）只用于数据传输，不具备对异常事件的处理能力。中断程序可以对处理异常事件，跳转，或者终止程序之类的</p><p>DMA适用于磁盘机，磁带机等高速设备大批量数据传送。</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201150317918.png" alt="image-20211201150317918"></p><p>注意传送前需要通过程序预处理，结束后需要中断方式处理，（不管怎么样，最后CPU还是要管一下）</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201150430139.png" alt="image-20211201150430139"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201150442643.png" alt="image-20211201150442643"></p><h4 id="DMA的传送方式："><a href="#DMA的传送方式：" class="headerlink" title="DMA的传送方式："></a>DMA的传送方式：</h4><p>​    1）停止CPU访存。DMA控制器发个信号给CPU，让DMA接管总线，之后数据传输完之后，DMA控制器再发个信号给CPU说你可以过来接管了，把总线控制给CPU</p><p>​    2）周期挪用（是对应的存取周期）</p><p>​        I&#x2F;O设备有请求后分为三种：</p><ol><li><p>CPU不在访存，那没啥事。</p></li><li><p>CPU在访存，必须等存取周期结束后，CPU再放弃总线的占有权，（<strong>相当于是非抢占式</strong>）</p></li><li><p>I&#x2F;O和CPU同时访存，I&#x2F;O先访存，I&#x2F;O如果不访存的话可能数据就被新的数据覆盖掉了。</p><p>3）DMA和CPU交替访存，用于CPU的工作周期比主存存取周期长，部分用于DMA访存,部分用于CPU访存。分时控制</p></li></ol><h4 id="DMA的传送过程"><a href="#DMA的传送过程" class="headerlink" title="DMA的传送过程"></a>DMA的传送过程</h4><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201151622332.png" alt="image-20211201151622332"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201151629700.png" alt="image-20211201151629700"></p><h4 id="DMA和中断的区别-（考的较多）"><a href="#DMA和中断的区别-（考的较多）" class="headerlink" title="DMA和中断的区别 （考的较多）"></a>DMA和中断的区别 （考的较多）</h4><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201151656349.png" alt="image-20211201151656349"></p><h4 id="DMA的综合计算"><a href="#DMA的综合计算" class="headerlink" title="DMA的综合计算"></a><font color='red'><strong>DMA的综合计算</strong></font></h4><p>这里大题出的比较多，感觉DMA属于比较好的I&#x2F;O控制方式了。</p><p><font color='red'>【2012DMA】<strong>考的不难，但是很综合</strong></font></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201151950794.png" alt="image-20211201151950794"></p><blockquote><p>1）问的是最少，那么是看主存和Cache的交换</p><p>2）300k</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201161731790.png" alt="image-20211201161731790"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201161741984.png" alt="image-20211201161741984"></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4></blockquote><h4 id="补充知识点："><a href="#补充知识点：" class="headerlink" title="补充知识点："></a><strong>补充知识点：</strong></h4><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201163653554.png" alt="image-20211201163653554"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201163740248.png" alt="image-20211201163740248"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201163952266.png" alt="image-20211201163952266"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201164008647.png" alt="image-20211201164008647"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201164035202.png" alt="image-20211201164035202"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201164053026.png" alt="image-20211201164053026"> </p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201164118891.png" alt="image-20211201164118891"></p><blockquote><p>（1）总共需要传输10位。<strong>（题目里给的信息基本上是有用的，不要忽略）</strong> **<font color='red'>1位起始位</font>**1位奇校验，一位停止位。</p><p>传送一个字符需要花0.5ms，那么1s内能传送1s&#x2F;0.5ms&#x3D;2000个</p><p>（2）其实这道题在最后时可能会有一定的偏差，但问的是大约，不要钻牛角尖。</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201160749556.png" alt="image-20211201160749556"></p><p>时钟周期：20ns。</p><p>0.5ms对应的是25000个时钟周期</p><p>读取一个字符的时间&#x3D;传送时间+响应时间+15条指令的时间&#x3D;25000+10+15*4&#x3D;25070</p><p>那么总共需要25070*1000个时钟周期</p><p>CPU需要做的事情是中断响应和服务程序。就是下面的部分。<strong>中间有个交叠的部分</strong></p><p>那么时间为1000*（10+20x4）&#x3D;9x10^4</p><p>CPU操作：关中断 保存断点，引出中断服务程序</p><p><font color='red'><strong>补充</strong></font></p><p>同步通信：一次通信只传送一帧信息，但这一帧里带有若干数据字符，通过同步字符作为开始</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201161131126.png" alt="image-20211201161131126"></p><p>1，起始位默认都有，校验位可能没有，需要看题目。停止位可能有多位</p><p>2，有效数据传输率只考虑<strong>数据位</strong>，需要乘一个比例，计网考过一个类似的大题</p></blockquote><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201161358091.png" alt="image-20211201161358091"></p><p>【2010年真题】，这里面的有效数据传输率就只有1500B，前面的首部占了18位，<strong>注意</strong></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201163117543.png" alt="image-20211201163117543"></p><blockquote><p>这道题目比较简单，直接发答案了，但比较综合。考察了程序查询，程序中断，DMA三种方式，适合用来复习。</p></blockquote><p><img src="C:\Users\李章杰\Desktop\image-20211201163055386.png" alt="image-20211201163055386"></p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="第二章进程管理"><a href="#第二章进程管理" class="headerlink" title="第二章进程管理"></a>第二章进程管理</h2><h3 id="进程的调度算法"><a href="#进程的调度算法" class="headerlink" title="进程的调度算法"></a>进程的调度算法</h3><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201175736026.png" alt="image-20211201175736026"></p><p>I&#x2F;O的优先级要高于CPU。</p><p>有味道的例子</p><p>（1）CPU利用率–<font color='orange'>厕所有人拉屎的时间&#x2F;总时间</font></p><p>（2）系统吞吐量，这里的系统吞吐量是表示的CPU所能完成的作业数量。其实概念大同小异</p><p>—<font color='orange'>某厕所一秒可以让多少人拉完屎</font></p><p>（3）周转时间：作业提交到作业完成所经历的时间–<font color='orange'>-开始排队到拉完</font><br>$$<br>周转时间&#x3D;作业完成时间-作业提交时间<br>$$<br>（4）平均周转时间：多个作业周转时间与作业实际运行时间的比值<br>$$<br>平均周转时间&#x3D;（作业1+作业2+…）&#x2F;n<br>$$<br>（5）带权周转时间，带权周转时间≥1，越小越好。—-<font color='orange'>开始排队到拉完&#x2F;实际拉屎时间</font><br>（等了多久&#x2F;拉了多久）<br>$$<br>带权周转时间&#x3D;\frac{作业周转时间}{作业实际运行时间}<br>$$<br>平均带权时间&#x3D;（作业1带+作业2带+…）</p><p>（6）等待时间—进程&#x2F;作业等待被服务时间的总和<br>    对于作业而言还要加上在外存预备队列中等待的时间</p><p>（7）响应时间–从提交到首次被响应的时间</p><p>（8）响应比<br>$$<br>响应比&#x3D;\frac{等待时间+要求服务时间}{要求服务时间}<br>$$</p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a><strong>例题</strong></h4><p>1，主要方法是画甘特图，然后细致一点，一步步地画，没有什么技巧性</p><p>2，注意看是抢占性还是非抢占性的</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201175522312.png" alt="image-20211201175522312"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201175340798.png" alt="image-20211201175340798"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201175450095.png" alt="image-20211201175450095"><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201175350848.png" alt="image-20211201175350848"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201175712959.png" alt="image-20211201175712959"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201175824388.png" alt="image-20211201175824388"></p><p>死锁定理：检查死锁</p><h3 id="银行家算法（死锁避免）"><a href="#银行家算法（死锁避免）" class="headerlink" title="银行家算法（死锁避免）"></a>银行家算法（死锁避免）</h3><p>通过模拟来判断是否会死锁，并建立一个安全序列<strong>（可能不唯一）</strong>。</p><p>安全状态，系统一定无死锁进程。</p><p>不安全状态，系统不一定有死锁进程。</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201180625956.png" alt="image-20211201180625956"></p><p><strong>答案很复杂，但手动模拟比较快</strong></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201180756520.png" alt="image-20211201180756520"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201180647373.png" alt="image-20211201180647373"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201180807820.png" alt="image-20211201180807820"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201180655604.png" alt="image-20211201180655604"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211201180814165.png" alt="image-20211201180814165"></p><h2 id="第三章内存管理"><a href="#第三章内存管理" class="headerlink" title="第三章内存管理"></a>第三章内存管理</h2><h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3><table><thead><tr><th align="center">单一连续分配</th><th>固定分区分配</th><th>动态分区分配</th></tr></thead><tbody><tr><td align="center">单用户，可以采用覆盖技术，无外部碎片，有内部碎片</td><td>无外部碎片，但是有内部碎片（当程序小于固定分区时）</td><td>有外部碎片（最佳适应算法最容易产生内存碎片）</td></tr></tbody></table><p>1，连续分配</p><p>2，固定分配</p><p><strong>3，动态分配</strong>（忘了）</p><ul><li>首次适应算法。空闲分区以<strong>地址递增</strong>的次序链接，找到第一个满足的（<strong>最优</strong>）</li><li>最佳适应算法。空闲分区以<strong>容量递增</strong>的方式形成分区连，找到第一个满足要求的空闲分区，先找小的再找大的。<strong>（最容易产生内存碎片）</strong></li><li>最坏适应算法。空闲分区以<strong>容量递减</strong>的方式形成分区连，先找最大的分区，再接着找</li><li>邻近适应算法。分配内存从上次结束位置开始继续查找</li></ul><h3 id="非连续分配管理方式（重点）"><a href="#非连续分配管理方式（重点）" class="headerlink" title="非连续分配管理方式（重点）"></a>非连续分配管理方式（重点）</h3><h3 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h3><p>分页可能会造成内部碎片，因为分页是固定大小的</p><h4 id="分页存储管理"><a href="#分页存储管理" class="headerlink" title="分页存储管理"></a>分页存储管理</h4><p>​    主要考察二级页表</p><table><thead><tr><th>一级页号</th><th>二级页号</th><th>页内偏移</th></tr></thead></table><h4 id="分段存储管理"><a href="#分段存储管理" class="headerlink" title="分段存储管理"></a>分段存储管理</h4><table><thead><tr><th>段号</th><th>段长</th><th>本段在内存中的地址</th></tr></thead></table><h4 id="段页存储管理"><a href="#段页存储管理" class="headerlink" title="段页存储管理"></a>段页存储管理</h4><p>段表只有一个，页表可以有多个</p><table><thead><tr><th>段号S</th><th>页号P</th><th>页内偏移量</th></tr></thead></table><p>访问段表时可能会出现越界异常</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214140642576.png" alt="image-20211214140642576"></p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟存储器的最大容量由计算机的地址结构所决定</p><h4 id="请求分页管理"><a href="#请求分页管理" class="headerlink" title="请求分页管理"></a>请求分页管理</h4><p>1，<strong>页表机制</strong></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214140911253.png" alt="image-20211214140911253"></p><p>2，<strong>缺页中断机制</strong></p><p>​    1，属于内部中断。</p><p>​    2，一条指令在执行期间可能会产生多次缺页中断</p><p>3，<strong>地址变换机构</strong></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214140838269.png" alt="image-20211214140838269"></p><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p>OPT：最优但是无法实现</p><p>FIFO：</p><p>注意：只有FIFO会产生Belady异常。物理块数增大但是页故障数目不减反增的异常现象。</p><p>LRU：最近最久未使用：堆栈类算法。选择最近最长未访问的页面予以淘汰。</p><p>CLOCK置换算法</p><p>与页表机制有关。有使用和修改位。 先看使用再看修改位。优先替换未使用过的。</p><h4 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h4><p>固定分配 局部置换（每次调用都是调用一整页，物理块数目不变，一次全换）</p><p>可变分配 全局置换（最容易实现）</p><p>缺页时，从空闲物理块中取一个给该进程，一块块地取</p><p>可变分配 局部置换</p><p>缺页时，选一页调出。</p><h4 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h4><p>驻留级大小一般不能小于工作集大小</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214142225081.png" alt="image-20211214142225081"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214142524459.png" alt="image-20211214142524459"></p><p>这里注意一下是问的置换总次数而不是缺页数目。页的置换总次数为5次。缺页数目为9次。</p><p>这种题目一个个好好算就行。没有太多技巧。53 276需要置换。</p><h3 id="内存管理大题"><a href="#内存管理大题" class="headerlink" title="内存管理大题"></a><strong>内存管理大题</strong></h3><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214150001912.png" alt="image-20211214150001912"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214150019301.png" alt="image-20211214150019301"></p><p>P201</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214143519308.png" alt="image-20211214143519308"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214143555185.png" alt="image-20211214143555185"></p><p>（3）处理缺页之后还需要返回缺页前的指令再重新执行一次，这个时候所查到的页表项已经在关联寄存器里面了。<strong>所以还需要一次访问1次关联寄存器</strong></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214144339123.png" alt="image-20211214144339123"></p><p><strong>第一小问很经典，感觉可以出成小题，</strong></p><blockquote><p>整个过程：通过访问虚拟地址最终得到物理地址。这里的页框号就是指的<strong>物理页框号</strong></p><p>先访问TLB，TLB未命中的话再访问内存里的页表，</p><p>内存里的页表命中的话合成物理地址后访问物理地址，得到数据。</p><p><font color='red'>未命中的话发生缺页。处理完缺页之后，将所需要的页框放入对应的TLB和页表中（更新TLB和页表）再重新进行访问TLB。</font></p><p>1）</p><p>1，0010 TLB为空 10ns，访问内存 100ns。内存页表命中，合成对应物理地址，之后再访问内存。</p><p>2,   0001 TLB不命中 10ns，访问内存100ns。内存页表不命中，产生缺页。耗时$10^8ns$，之后更新TLB和页表。返回缺页发生前的状态，再次进行访问TLB 10ns，此时TLB命中，合成物理地址，在进行访问内存100ns，总共耗时10^8+220ms</p><p>2）合法驻留级为2，根据LRU算法，淘汰0号页面，所以1565H对应的页框号位101H，即物理地址为101565H</p></blockquote><p>2010</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214145706380.png" alt="image-20211214145706380"></p><blockquote><p>1）0001 01   11 1100 1010H 页内偏移量10bit 页号5</p><p>2）对应的物理地址 应该是   0111  11 1100 1010  1FCAH 是中置换算法 对应的是2号    0010 11 1100 1010 B&#x3D;   0BCAH 注意审题</p></blockquote><p><strong><font color='red'>2013 做了差不多三遍了，还是掌握不是那么透彻</font></strong></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214151301739.png" alt="image-20211214151301739"></p><blockquote><p>1)4KB  已级页表最大为2^20*4B&#x3D;4MB</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214154029439.png" alt="image-20211214154029439"></p><p>逻辑地址为0008 000H，说明页号为8，那么对应页表中的第八个表项。每一个表项长度为4B，八个表项为32B，转换为<strong>16进制</strong>为20H，那么最后的答案为0020 0020H和0020 0024H，因为8KB对应了两页 即两个页表项。 </p><p>物理地址：<strong>（页框号：页内地址）</strong> 通过观察我们可以发现页框号1为00900H，那么页框号2应该为00901H，<strong>因为页号和页框号也是一一对应的</strong></p></blockquote><p>2018</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214154446418.png" alt="image-20211214154446418"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214154521404.png" alt="image-20211214154521404"></p><p>这道题目好好看看就行，<strong>然后注意一下PDBR</strong></p><p>同一进程下的线程共享地址空间</p><h2 id="第四章-文件管理"><a href="#第四章-文件管理" class="headerlink" title="第四章 文件管理"></a>第四章 文件管理</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><h4 id="位图法："><a href="#位图法：" class="headerlink" title="位图法："></a>位图法：</h4><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214173416780.png" alt="image-20211214173416780"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214175855572.png" alt="image-20211214175855572"></p><p> 因为位图法是1位代表一个磁盘的状态，409612&#x2F;（1024x8）&#x3D;50，第50号块，实际上是49号，32号对应的是0号，那么32+49&#x3D;81号。余12，从0开始编号，那么12&#x2F;8&#x3D;1，在1号字节里面。</p><p>22：</p><p><strong>文件系统管理空闲磁盘的方法有</strong> 位图法，空闲链表法，空闲表法，成组链接法</p><p>索引结点：文件目录管理部分。每个文件对应一个索引节点。除了文件名意外的所有信息都放到索引节点中。目录项只包含文件名，索引结点指针。文件有对应的索引表</p><h3 id="文件管理大题"><a href="#文件管理大题" class="headerlink" title="文件管理大题"></a>文件管理大题</h3><h4 id="连续链式索引的区别"><a href="#连续链式索引的区别" class="headerlink" title="连续链式索引的区别"></a>连续链式索引的区别</h4><p>当做知识点去记忆。</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214184459968.png" alt="image-20211214184459968"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214184441241.png" alt="image-20211214184441241"></p><p><strong>关于启动磁盘多少次的问题</strong></p><p>链接分配</p><p>P263 T7</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214181808267.png" alt="image-20211214181808267"></p><blockquote><p>1）10+256（一级索引块）+256*256（二级索引）+256x256x256（）</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214182302359.png" alt="image-20211214182302359"></p><p>2）</p></blockquote><p><strong><font color='red'>通过看图好好理解</font></strong></p><blockquote><p>先找到目录项，再把FCB从外存读入内存，再去寻找文件信息</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214182832872.png" alt="image-20211214182832872"></p><p>4B拉链</p><p>普通文件变为了索引分配的文件 ，目录文件变成了链接分配的形式。不设置专门的FCB</p><p>根目录常驻内存。  第一次：从外存中读入A的目录文件 第二次：读取D的目录文件的数据块， 第三次读取J的FCB </p><p> J读取数据块最多需要4次，最少需要一次。</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214183308617.png" alt="image-20211214183308617"></p><p>3）读W 最少需要5次把W的FCB读入，之后通过FCB，直接索引把外存的数据块读入内存 1次。 6次</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214183534051.png" alt="image-20211214183534051"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214183642412.png" alt="image-20211214183642412"></p><p>读入W的FCB  1次，之后再读入4次<img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214183722669.png" alt="image-20211214183722669" style="zoom:67%;" /></p></blockquote><p>P263T8</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214210919103.png" alt="image-20211214210919103"></p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214210906336.png" alt="image-20211214210906336"></p><h3 id="磁盘组织和管理"><a href="#磁盘组织和管理" class="headerlink" title="磁盘组织和管理"></a>磁盘组织和管理</h3><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214163430151.png" alt="image-20211214163430151"></p><h4 id="磁盘调度公式："><a href="#磁盘调度公式：" class="headerlink" title="磁盘调度公式："></a>磁盘调度公式：</h4><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214162818200.png" alt="image-20211214162818200"><br>$$<br>T_a&#x3D;T_s+\frac{1}{2r}+\frac{b}{rN}<br>$$<br>1）寻找时间 Ts：将磁头移动到指定磁道所需要的时间还包括启动磁臂的时间</p><p>2）延迟时间 Tr：磁头定位到某一磁道扇区所需要的时间，旋转速度为r。相当于是转了半圈<br>$$<br>T_r&#x3D;\frac{1}{2r}<br>$$<br>3）传输时间Tt，从磁盘读出或者向磁盘写入数据所经历的时间。取决于每次读写字节数和旋转速度。</p><p>r：每秒的转速。N为一个磁道上的字节数目。</p><h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><p>2010年磁道：</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214163501891.png" alt="image-20211214163501891"></p><blockquote><p>1）</p><p>用位图法来表示磁盘空闲状态。说了16384（刚好每位表示一个磁盘的空闲状态。一共需要2KB。如果熟悉2进制的话知道2^14&#x3D;16384刚好对应的是2KB。</p><p>2）<strong>沿着磁道号增大的方向移动</strong></p><p>这里的CSCAN默认为CLOOK 那么总共为20+90+20+40&#x3D;170ms</p><p>ps：如果是换成LOOK算法的话那就是20+30+40+20&#x3D;110ms</p><p><strong>计算部分</strong></p><p>T&#x3D;寻到时间+旋转时间+传输时间</p><p>寻道时间&#x3D;170ms。</p><p>旋转时间 1&#x2F;2r  100r&#x2F;s 1r-》10ms，那么旋转时间为5ms。总共旋转时间为5*4&#x3D;20ms</p><p>传输时间：读取一个扇区所花时间为1r 100个磁道。0.01r&#x3D;0.01*10&#x3D;0.1ms，总是0.4ms</p><p>T&#x3D;190.4ms</p><p>3） 有，FIFO先来先服务。因为不需要考虑寻道时间和旋转的延迟，直接按照I&#x2F;O请求的先后顺序服务</p></blockquote><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214163517237.png" alt="image-20211214163517237"></p><blockquote><p>1,300x10x200x0.5kB&#x3D;300MB</p><p>2,·85号柱面 85x10x200&#x2F;2&#x3D;85000号簇，先访问100260 101660 110560 60005</p><p>考察对簇号的计算。</p><p>3）<strong>这里的物理地址指的是磁盘地址</strong></p><p><font color='red'>磁盘地址用：柱面号 盘面号 扇区号 来表示</font></p><p>100530&#x2F;(10x200&#x2F;2)&#x3D;100号簇</p><p>530&#x2F;100&#x3D;5 5号磁道 扇区号 60号扇区</p><p>由磁盘驱动程序来完成磁盘到物理地址的转换</p></blockquote><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214173537037.png" alt="image-20211214173537037"></p><p>3000r&#x2F;min&#x3D;50r&#x2F;s  20ms&#x2F;r。读一个扇区需要2.5ms</p><p>读取时间&#x3D;mxn+s    &#x3D;2.5msx3&#x3D;7.5ms，读取+传送时间</p><p>一整个扇区：<font color='red'>包括了启动磁臂的时间</font>  总共为20&#x2F;2+8*7.5&#x3D;0.07s，因为总共有8块。</p><p>每个磁道的数据量为4KB</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214173550905.png" alt="image-20211214173550905"></p><h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><p>FCFS:先来先服务</p><p>SSTF：最短寻找时间优先。寻找与当前磁头最近的磁道</p><p>磁盘调度算法中，如果没有提到C-LOOK和LOOK算法。默认CSCAN和SCAN当做LOOK和CLOOK。</p><p>CLOOK：达到最远端后立即返回到最小的那个点<font color='red'>（中间不停顿）</font>。然后再从最小的地方出发。</p><p>LOOK:相当于坐电梯，一步步地退回来。</p><p><strong>都不需要达到磁盘的端点</strong></p><p>CSCAN和SCAN需要达到磁盘的端点。</p><h2 id="第五章-I-x2F-O管理"><a href="#第五章-I-x2F-O管理" class="headerlink" title="第五章 I&#x2F;O管理"></a>第五章 I&#x2F;O管理</h2><h4 id="缓冲的计算问题"><a href="#缓冲的计算问题" class="headerlink" title="缓冲的计算问题"></a>缓冲的计算问题</h4><p>单缓冲： max（C（CPU处理时间）,T（从磁盘传入缓冲区时间））+M(从磁盘传入用户时间)</p><p>假设里面是满的，那么处理一块数据所需要的最短时间为1，C&gt;T,要等CPU处理完才能传送给用户，2，T&gt;C，要把缓冲区充满才能算一次数据块的处理。</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214185337470.png" alt="image-20211214185337470"><br><strong>看图会更好记忆一点</strong></p><p>双缓冲：max（C+M,T）</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214185704782.png" alt="image-20211214185704782"></p><p><strong>看图记忆法</strong></p><h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h3><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214190325709.png" alt="image-20211214190325709"></p><blockquote><p>11,    max(C,T)+M&#x3D;120</p><p>12,max(C+M,T) D选项。</p></blockquote><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214190822218.png" alt="image-20211214190822218"></p><p><font color='red'>14，出现多余的数字，50 100之类的，一定要注意，因为可能是自己忽略了某些东西</font></p><p>14：max(C,T)+M&#x3D;150，则总共需要1500.然后再加上处理最后的数据</p><p>​        max（C+M,T）&#x3D;100,10块需要1000ms，<strong>之后最后从缓冲区送到用户区的时间100ms再分析</strong></p><p>15题：最短：单缓冲 100（外设到缓冲）+100（一个外设到缓冲 一个再缓冲+工作）+100（M+C）&#x3D;300.就是正常计算，</p><p><img src="C:\Users\李章杰\AppData\Roaming\Typora\typora-user-images\image-20211214190832263.png" alt="image-20211214190832263"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 408 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/11/02/hello-world/"/>
      <url>/2019/11/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
