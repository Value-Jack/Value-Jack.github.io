<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="树, 感而遂通的博客">
    <meta name="baidu-site-verification" content="fmlEuI34ir" />
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48" />
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7" />
    <meta name="description" content="树树树的基本定义//二叉树的基本定义
typedef struct TreeNode
&amp;#123;
    int val;
    struct TreeNode *rchild,*lchild;
&amp;#125;;

递归二叉树的递归遍历h">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>树 | 感而遂通的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?ce84511d3df71640a9378a69f6293044";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<meta name="generator" content="Hexo 6.0.0"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">感而遂通的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <i class="fa fa-comments"></i>
            
            <span>留言板</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">感而遂通的博客</div>
        <div class="logo-desc">
            
            智慧和纯洁来自努力,无知和纵欲来自懒惰。
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-comments"></i>
                
                留言板
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/value-jack/hexo-matery-modified" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/value-jack/hexo-matery-modified" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/22.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        树
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                        <a href="/tags/LeetCode/" target="_blank">
                            <span class="chip bg-color">LeetCode</span>
                        </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-11-02
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    value-jack
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    13.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    57 分
                </div>
                
                

                
                <div id="busuanzi_container_page_pv" class="info-break-policy">
                    <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                    <span id="busuanzi_value_page_pv"></span>
                </div>
                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树-1"><a href="#树-1" class="headerlink" title="树"></a>树</h2><h3 id="树的基本定义"><a href="#树的基本定义" class="headerlink" title="树的基本定义"></a>树的基本定义</h3><pre><code class="c++">//二叉树的基本定义
typedef struct TreeNode
&#123;
    int val;
    struct TreeNode *rchild,*lchild;
&#125;;
</code></pre>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h4><p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html</a></p>
<p>参考的代码随想录</p>
<p>这里帮助大家确定下来递归算法的三个要素。</p>
<p><strong>每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</strong></p>
<ol>
<li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ol>
<p>这个引⽤符号 &amp; 要和C语⾔⾥⾯的取地址运算符 &amp; 区分开来，他们没有什么关系，C++⾥⾯的引⽤是 </p>
<p><strong>指在变量名之前加⼀个 &amp; 符号，⽐如在函数传⼊的参数中 int &amp;a ，那么对这个引⽤变量 a 做的所有</strong> </p>
<p>操作都是直接对传⼊的原变量进⾏的操作，并没有像原来 int a ⼀样只是拷⻉⼀个副本（传值），</p>
<p>（具体参考柳诺）</p>
<p>树是通过递归顶一顶，构造一棵树基本上都是通过递归来构造，找到相似的递归结构才能构造</p>
<h3 id="94-树的中序遍历"><a href="#94-树的中序遍历" class="headerlink" title="94,树的中序遍历"></a>94,树的中序遍历</h3><p> 给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。 </p>
<p>中序遍历：左根右</p>
<pre><code class="c++">class Solution &#123;
public:
    //  注意递归函数都要放在前面
    void inorder(TreeNode *root,vector&lt;int&gt; &amp;res)//注意这里要＋&amp; 表示是对res的引用，不加的话返回不了正确的
    &#123;
        if(!root)
        return; //如果root为nullpur 那么！root就运行 直接返回

        //递归 左中右 
        inorder(root-&gt;left,res); 
        res.push_back(root-&gt;val);//容器的基本操作，比数组方便得多 
        inorder(root-&gt;right,res);
    &#125;

    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;
        vector&lt;int&gt; res; //定义一个res的容器
        inorder(root,res);
        return res;
    &#125;
&#125;;
</code></pre>
<h3 id="101，对称二叉树"><a href="#101，对称二叉树" class="headerlink" title="101，对称二叉树"></a>101，对称二叉树</h3><p> 给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。 </p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>树的题目感觉很多都需要用到<strong>递归</strong>，递归往往是比较好的办法，要灵活掌握</p>
<h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><pre><code class="c++">//树的本质是什么 递归 嘿嘿
class Solution &#123;
public:
    void panduan(TreeNode *l,TreeNode *r,bool &amp;res)&#123;
        if(!l&amp;&amp;!r)
        return;

        if((!l&amp;&amp;r)||(l&amp;&amp;!r))
        &#123;
            res=false ;
            return;
        &#125;
        if(l-&gt;val!=r-&gt;val) res=false;

        panduan(l-&gt;left,r-&gt;right,res);
        panduan(l-&gt;right,r-&gt;left,res);

    &#125;

    bool isSymmetric(TreeNode* root) &#123;
        TreeNode *l=root-&gt;left,*r=root-&gt;right;
        bool res=true;
        panduan(l,r,res);
        return res;
    &#125;
&#125;;
</code></pre>
<h3 id="102-层序遍历"><a href="#102-层序遍历" class="headerlink" title="102 层序遍历"></a>102 层序遍历</h3><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。 </p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>正常用队列做</p>
<blockquote>
<p>注意：这里不是返回一个数组，而是返回一个数组的数组，<strong>思路没有问题，只是一些细节的地方需要改改</strong>，需要学习这种写法</p>
<pre><code class="c++"> error: no viable conversion from returned value of type &#39;vector&lt;int&gt;&#39; to function return type &#39;vector&lt;vector&lt;int&gt;&gt;&#39;

从答案这里可以看出来还是有区别的
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
</code></pre>
</blockquote>
<h4 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h4><pre><code class="c++">class Solution &#123;
public:


    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;
        queue&lt;TreeNode*&gt; q;
        vector&lt;vector&lt;int&gt;&gt; res;
        //先写边界条件
        
        if(!root)
        return res;

        q.push(root);//根节点入队



        while(!q.empty())//它是里面还得再生成一个数组
        &#123;
            int size=q.size();
            res.push_back(vector &lt;int&gt; ()); //每次都新插入一个vector 然后再在里面写入数据 
            for(int i=0;i&lt;size;i++)
            &#123;
                TreeNode *top=q.front();
                res.back().push_back(top-&gt;val); //注意这种vector&lt;vector&lt;int&gt;&gt;的写法  [[3],[9,20],[15,7]]
            //  ret.back().push_back(node-&gt;val);
                q.pop();

                if(top-&gt;left) 
                q.push(top-&gt;left);
                if(top-&gt;right)//细节啊 
                q.push(top-&gt;right);
            &#125;
           
        &#125;
    //    lorder(root,res,q);
        return res;
    &#125;
&#125;;
</code></pre>
<h4 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h4><pre><code class="c++">//这个感觉写的更好一点，不用像答案那样 res.back().push_back()
class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;
        queue&lt;TreeNode*&gt; que;
        if (root != NULL) que.push(root);
        vector&lt;vector&lt;int&gt;&gt; result;
        while (!que.empty()) &#123;
            int size = que.size();
            vector&lt;int&gt; vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i &lt; size; i++) &#123;
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node-&gt;val);
                if (node-&gt;left) que.push(node-&gt;left);
                if (node-&gt;right) que.push(node-&gt;right);
            &#125;
            result.push_back(vec);
        &#125;
        return result;
    &#125;
&#125;;
</code></pre>
<h3 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103,二叉树的锯齿形层序遍历"></a>103,二叉树的锯齿形层序遍历</h3><p> 给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 </p>
<pre><code class="c++">输入：root = [3,9,20,null,null,15,7]
输出：[[3],[20,9],[15,7]]
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>加个deep判断深度就行了。</p>
<pre><code class="c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;
        queue&lt;TreeNode*&gt; que;
        int deep=0;
        if (root != NULL) que.push(root);
        vector&lt;vector&lt;int&gt;&gt; result;
        while (!que.empty()) &#123;
            deep++;
            int size = que.size();
            vector&lt;int&gt; vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i &lt; size; i++) &#123;
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node-&gt;val);
                if (node-&gt;left) que.push(node-&gt;left);
                if (node-&gt;right) que.push(node-&gt;right);
            &#125;
            if(deep%2==0)   reverse(vec.begin(),vec.end());
            result.push_back(vec);
        &#125;
        return result;
    &#125;
&#125;;
</code></pre>
<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h3><p>给定一个二叉树，找出其最大深度。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1642668469603.png" alt="1642668469603" style="zoom:50%;" />





<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p> 深度优先遍历,当前结点的最大深度等于左右子树最大深度的最大值加一  返回的结果是3 </p>
<h4 id="递归-DFS"><a href="#递归-DFS" class="headerlink" title="递归 DFS"></a><strong>递归</strong> DFS</h4><p>之后找个专题好好学学递归</p>
<p>秒，真的是太妙了，感觉就是能看懂，但是要自己写肯定就写不出来了</p>
<pre><code class="c++">class Solution &#123;
public:
    int maxDepth(TreeNode* root) &#123;
        if(!root) // 节点为空返回
            return 0;
        return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1; // 左/右子树最大深度+1
    &#125;
&#125;;
</code></pre>
<h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><pre><code class="c++">class Solution &#123;
public:
    int Max = 0;
    void DFS(TreeNode* r, int d)&#123;
        if(!r) // 节点为空返回
            return;
        Max = max(Max, d); // 更新最大深度
        DFS(r-&gt;left, d+1); // 深搜左子树，深度+1
        DFS(r-&gt;right, d+1); // // 深搜右子树，深度+1
    &#125;
    int maxDepth(TreeNode* root) &#123;
        if(!root) // 树为空，最大深度为0
            return 0;
        DFS(root, 1); // 从根节点深搜，初始深度为1
        return Max;
    &#125;
&#125;;
</code></pre>
<h4 id="层次遍历-x2F-BFS"><a href="#层次遍历-x2F-BFS" class="headerlink" title="层次遍历&#x2F;BFS"></a>层次遍历&#x2F;BFS</h4><p>和上一题一样 就改一点点地方</p>
<pre><code class="c++">class Solution &#123;
public:
    int maxDepth(TreeNode* root) &#123;
 queue&lt;TreeNode*&gt; que;
        int deep=0;
        if (root != NULL) que.push(root);
        vector&lt;vector&lt;int&gt;&gt; result;
        while (!que.empty()) &#123;
            deep++;
            int size = que.size();
            vector&lt;int&gt; vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i &lt; size; i++) &#123;
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node-&gt;val);
                if (node-&gt;left) que.push(node-&gt;left);
                if (node-&gt;right) que.push(node-&gt;right);
            &#125;
            if(deep%2==0)   reverse(vec.begin(),vec.end());
            result.push_back(vec);
        &#125;
        return deep;
    &#125;
&#125;;
</code></pre>
<h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h3><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明：</strong>叶子节点是指没有子节点的节点</p>
<p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1642918487443.png" alt="1642918487443"></p>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>和最大深度一样，不过有个需要注意的地方</p>
<p>另外这道题的关键是搞清楚递归结束条件</p>
<p>叶子节点的定义是左孩子和右孩子都为 null 时叫做叶子节点<br><strong>当 root 节点左右孩子都为空时，返回 1</strong><br><strong>当 root 节点左右孩子有一个为空时，返回不为空的孩子节点的深度</strong><br><strong>当 root 节点左右孩子都不为空时，返回左右孩子较小深度的节点值</strong></p>
<p> <strong>求二叉树的最小深度和求二叉树的最大深度的差别主要在于处理左右孩子不为空的逻辑。</strong> </p>
<p> 左右孩子都为空的节点才是叶子节点！ 一开始错了是因为只要有一个孩子为空就返回了，但实际需要两个都为空才返回</p>
<h4 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h4><pre><code class="c++">class Solution &#123;
public:
    int minDepth(TreeNode* root) &#123;
        if(!root)
        return 0;
        
        if(root-&gt;left==nullptr&amp;&amp;root-&gt;right)
        return minDepth(root-&gt;right)+1;

         if(root-&gt;left&amp;&amp;root-&gt;right==nullptr)
        return minDepth(root-&gt;left)+1;

        return(min(minDepth(root-&gt;left),minDepth(root-&gt;right)))+1;
    &#125;
&#125;;//求最小深度时将Math.max换成Math.min即可，但要注意如果根节点的左或右子树为空的话是构不成子树的。而最小深度是要求从根节点到子树的。当左或右子树为空时，不符合要求。
</code></pre>
<p>自己模拟一下就能出来了。</p>
<h4 id="迭代（队列）"><a href="#迭代（队列）" class="headerlink" title="迭代（队列）"></a>迭代（队列）</h4><p>代码随想录</p>
<p> <strong>需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点</strong> </p>
<pre><code class="c++">class Solution &#123;
public:

    int minDepth(TreeNode* root) &#123;
        if (root == NULL) return 0;
        int depth = 0;
        queue&lt;TreeNode*&gt; que;
        que.push(root);
        while(!que.empty()) &#123;
            int size = que.size();
            depth++; // 记录最小深度
            for (int i = 0; i &lt; size; i++) &#123;
                TreeNode* node = que.front();
                que.pop();
                if (node-&gt;left) que.push(node-&gt;left);
                if (node-&gt;right) que.push(node-&gt;right);
                if (!node-&gt;left &amp;&amp; !node-&gt;right) &#123; // 当左右孩子都为空的时候，说明是最低点的一层了，退出 这一句话
                    return depth;
                &#125;
            &#125;
        &#125;
        return depth;
    &#125;
&#125;;
</code></pre>
<h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h3><p> 给定一棵树的前序遍历 <code>preorder</code> 与中序遍历 <code>inorder</code>。请构造二叉树并返回其根节点。 </p>
<p>Input: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>Output: [3,9,20,null,null,15,7]</p>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>手算比较简单 关键是代码的实现，这种题目感觉还是得用递归，一个个找，直到pre和in相同</p>
<p>思路</p>
<p>对于任意一颗树而言，前序遍历的形式总是</p>
<p>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]<br>即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是</p>
<p>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]<br>只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。</p>
<p>这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。</p>
<p>细节</p>
<p>在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。<strong>我们可以考虑使用哈希表来帮助我们快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值）</strong>，（注意这里没有重复元素）值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 O(1)O(1) 的时间对根节点进行定位了。</p>
<p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1642817908346.png" alt="1642817908346"></p>
<pre><code class="c++">class Solution &#123;
private:
    unordered_map&lt;int, int&gt; index;

public:
    TreeNode* myBuildTree(const vector&lt;int&gt;&amp; preorder, const vector&lt;int&gt;&amp; inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) &#123;
        if (preorder_left &gt; preorder_right) &#123;
            return nullptr;
        &#125;
        
        // 前序遍历中的第一个节点就是根节点
        int preorder_root = preorder_left;
        // 在中序遍历中定位根节点
        int inorder_root = index[preorder[preorder_root]]; //在中序遍历中找到根节点，那么根节点左边就是左子树，右边就是右子树
        
        // 先把根节点建立出来
        TreeNode* root = new TreeNode(preorder[preorder_root]);
        // 得到左子树中的节点数目
        int size_left_subtree = inorder_root - inorder_left;
        // 递归地构造左子树，并连接到根节点
        
        //下面的一部分看上面的图就能看出来了
        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素
        root-&gt;left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);
        // 递归地构造右子树，并连接到根节点
        // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素
        root-&gt;right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);
        return root;
    &#125;

    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;
        int n = preorder.size();
        // 构造哈希映射，帮助我们快速定位根节点
        for (int i = 0; i &lt; n; ++i) &#123;
            index[inorder[i]] = i;  //key是中序遍历的值 value是对应的下标
        &#125;
        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);//这里表示的是左右的边界
    &#125;
&#125;;
</code></pre>
<h3 id="106，中序和后序遍历"><a href="#106，中序和后序遍历" class="headerlink" title="106，中序和后序遍历"></a>106，中序和后序遍历</h3><p> 跟105题类似的思路，不过是后序遍历中最后一个结点是根节点，通过确定根结点然后将中序遍历中的左右子树划分开。<br>然后再在左右子树中递归地进行构造二叉树 </p>
<pre><code class="c++">//不知道哪里错了，显示内存出错，但别的应该问题不大


class Solution &#123;
private:
    unordered_map&lt;int, int&gt; index;

public:
    TreeNode* myBuildTree(const vector&lt;int&gt;&amp; postorder, const vector&lt;int&gt;&amp; inorder, int postorder_left, int postorder_right, int inorder_left, int inorder_right) &#123;
        if (postorder_left &gt; postorder_right) &#123;
            return nullptr;
        &#125;
        
        // 后序遍历中的最后一个节点就是根节点
        int postorder_root = postorder_right;
        
        int inorder_root = index[postorder[postorder_root]]; //找到最后一个节点

        TreeNode* root = new TreeNode(postorder[postorder_root]);

        int size_left_subtree = inorder_root - inorder_left;

        root-&gt;left = myBuildTree(postorder, inorder, postorder_left, postorder_left + size_left_subtree-1, inorder_left, inorder_root - 1);
        root-&gt;right = myBuildTree(postorder, inorder, postorder_left + size_left_subtree , postorder_right-1, inorder_root + 1, inorder_right);
        return root;
    &#125;

    TreeNode* buildTree(vector&lt;int&gt;&amp; postorder, vector&lt;int&gt;&amp; inorder) &#123;
        int n = postorder.size();
        // 构造哈希映射，快速定位根节点
        for (int i = 0; i &lt; n; ++i) &#123;
            index[inorder[i]] = i;  //key是中序遍历的值 value是对应的下标
        &#125;
        return myBuildTree(postorder, inorder, 0, n - 1, 0, n - 1);//这里表示的是左右的边界
    &#125;
&#125;;
</code></pre>
<pre><code class="c++">class Solution &#123;
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;
        int n = inorder.length;
        // 将中序遍历放到map中
        for (int i = 0; i &lt; n; ++i) &#123;
            map.put(inorder[i], i);
        &#125;
        return myBuildTree(inorder, postorder, 0, n - 1, 0, n - 1);
    &#125;

    public TreeNode myBuildTree(int[] inorder, int[] postorder, int inorder_left, int inorder_right, int postorder_left, int postorder_right) &#123;
        if (inorder_left &gt; inorder_right) &#123;
            return null;
        &#125;
        // 根节点在后序遍历中的下标
        int postorder_root = postorder_right;
        // 根节点在中序遍历中的根节点
        int inorder_root = map.get(postorder[postorder_root]);
        // 左子树的长度
        int size_left_subtree = inorder_root - inorder_left;
        // 建立根节点
        TreeNode root = new TreeNode(postorder[postorder_root]);
        root.left = myBuildTree(inorder, postorder, inorder_left, inorder_root - 1, postorder_left, postorder_left + size_left_subtree - 1);
        root.right = myBuildTree(inorder, postorder, inorder_root + 1, inorder_right, postorder_left + size_left_subtree, postorder_right - 1);
        return root;
    &#125;
&#125;
</code></pre>
<h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h3><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p>
<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>基本上树相关的题目就是迭代和递归了</p>
<h4 id="递归-4"><a href="#递归-4" class="headerlink" title="递归"></a>递归</h4><pre><code class="c++">class Solution &#123;
public:
    void flatten(TreeNode* root) &#123;
        vector&lt;TreeNode*&gt; l;
        preorderTraversal(root, l);
        int n = l.size();
        for (int i = 1; i &lt; n; i++) &#123;
            TreeNode *prev = l.at(i - 1), *curr = l.at(i);
            prev-&gt;left = nullptr;
            prev-&gt;right = curr;
        &#125;
    &#125;

    void preorderTraversal(TreeNode* root, vector&lt;TreeNode*&gt; &amp;l) &#123;
        if (root != NULL) &#123;
            l.push_back(root);
            preorderTraversal(root-&gt;left, l);
            preorderTraversal(root-&gt;right, l);
        &#125;
    &#125;
&#125;;

</code></pre>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>观察可以发现将二叉树前序展开为链表，**相当于把一A结点的左孩子L整个完整的树替换到此结点的右孩子R上(同时把此结点原来的右孩子R接到此节点左孩子L的最右结点的右孩子上)**，然后将当前结点替换为此结点的右孩子(也就是原来的L)进行迭代(注意每次要将结点的左孩子设置为nullptr)。</p>
<p>前两种方法都借助前序遍历，前序遍历过程中需要使用栈存储节点。有没有空间复杂度是 O(1)O(1) 的做法呢？</p>
<p>注意到前序遍历访问各节点的顺序是根节点、左子树、右子树。如果一个节点的左子节点为空，则该节点不需要进行展开操作。如果一个节点的左子节点不为空，则该节点的左子树中的最后一个节点被访问之后，该节点的右子节点被访问。该节点的左子树中最后一个被访问的节点是左子树中的最右边的节点，也是该节点的前驱节点。因此，问题转化成寻找当前节点的前驱节点。</p>
<p>具体做法是，对于当前节点，如果其左子节点不为空，则在其左子树中找到最右边的节点，作为前驱节点，将当前节点的右子节点赋给前驱节点的右子节点，然后将当前节点的左子节点赋给当前节点的右子节点，并将当前节点的左子节点设为空。对当前节点处理结束后，继续处理链表中的下一个节点，直到所有节点都处理结束。</p>
<pre><code class="c++">class Solution &#123;
public:
    void flatten(TreeNode* root) &#123;
        while(root)
        &#123;
            TreeNode *l=root-&gt;left;
            if(l)
            &#123;
                while(l&amp;&amp;l-&gt;right)
                l=l-&gt;right;//需要让root的right接到左子树的最右的子树这

                 l-&gt;right=root-&gt;right;
                root-&gt;right=root-&gt;left;
                root-&gt;left=nullptr;
            &#125;
           root=root-&gt;right;
        &#125;//其实自己去花几个图就能看出来了 它的好处在于空间复杂度为O（1）
    &#125;
&#125;;
</code></pre>
<h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h3><p> 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 </p>
<p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1642854960270.png" alt="1642854960270"></p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>采用DFS，最大的深度应该是左子树的最大深度+右子树的最大深度 然后+1 -1这种最好是到时候试试看最后的结果。</p>
<blockquote>
<p>  直径 &#x3D; 左子树高度 + 右子树高度； 我理解应该是 (左树高度 - 1) + (右子树高度 - 1) ， 因为直径是边的个数，而非节点的个数。 </p>
</blockquote>
<p>把104结合起来，先是求得左右子树的最大深度，然后再加起来，与max相比较。</p>
<h4 id="递归（之后照着官方解答写一下）"><a href="#递归（之后照着官方解答写一下）" class="headerlink" title="递归（之后照着官方解答写一下）"></a>递归（<strong>之后照着官方解答写一下</strong>）</h4><pre><code class="c++">//感觉还是不够简约 需要继续改进  
class Solution &#123;
public:
    int maxDepth(TreeNode* root) &#123;
        if(!root) // 节点为空返回
            return 0;
    return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1; // 左/右子树最大深度+1
    &#125;

    int finddeep(TreeNode*root,int &amp;maxd)&#123;
        if(!root)
        return 0;
        int maxl=maxDepth(root-&gt;left);
        int maxr=maxDepth(root-&gt;right);
        finddeep(root-&gt;left,maxd);
        finddeep(root-&gt;right,maxd);
        maxd=max(maxd,maxr+maxl);
        return  maxd;
    &#125;

    int diameterOfBinaryTree(TreeNode* root) &#123;
        if(!root)
        return 0;
        int maxd=0;
        

        return finddeep(root,maxd);

    &#125;
&#125;;
</code></pre>
<h4 id="官方解答"><a href="#官方解答" class="headerlink" title="官方解答"></a>官方解答</h4><pre><code class="java">//java版本
class Solution &#123;
    int maxd=0;
    public int diameterOfBinaryTree(TreeNode root) &#123;
        depth(root);
        return maxd;
    &#125;
    
    public int depth(TreeNode node)&#123;
        if(node==null)&#123;
            return 0;
        &#125;
        int Left = depth(node.left);
        int Right = depth(node.right);
        maxd=Math.max(Left+Right,maxd);//将每个节点最大直径(左子树深度+右子树深度)当前最大值比较并取大者
        return Math.max(Left,Right)+1;//返回节点深度
    &#125;
&#125;
</code></pre>
<h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><p>就正常翻转即可，换个位置</p>
<p>这里如果用中序遍历的话可能就会出错了，因为可能会翻转两次。这道题目感觉是能遍历基本上就能翻转（除了中序） </p>
<h4 id="递归-5"><a href="#递归-5" class="headerlink" title="递归"></a>递归</h4><pre><code class="c++">class Solution &#123;
public:
    TreeNode* invertTree(TreeNode* root) &#123;
       if(!root)
       return root;
            TreeNode* i=root-&gt;left;
            root-&gt;left=root-&gt;right;
            root-&gt;right=i;//直接用swap(root-&gt;left,root-&gt;right)更快一点
        invertTree(root-&gt;left);
        invertTree(root-&gt;right);
        return root;
    &#125;
&#125;;
</code></pre>
<h4 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h4><pre><code class="c++">class Solution &#123;
public:
    TreeNode* invertTree(TreeNode* root) &#123;
        stack&lt;TreeNode*&gt; st;
        if (root != NULL) st.push(root);
        while (!st.empty()) &#123;
            TreeNode* node = st.top();
            if (node != NULL) &#123;
                st.pop();
                if (node-&gt;right) st.push(node-&gt;right);  // 右
                if (node-&gt;left) st.push(node-&gt;left);    // 左
                st.push(node);                          // 中
                st.push(NULL);
            &#125; else &#123;
                st.pop();
                node = st.top();
                st.pop();
                swap(node-&gt;left, node-&gt;right);          // 节点处理逻辑
            &#125;
        &#125;
        return root;
    &#125;
&#125;;
</code></pre>
<h3 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h3><p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p>
<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>直接按照普通二叉树来判断，全部遍历</p>
<p>1，<strong>确定递归函数的参数和返回值</strong></p>
<p>​    参数应该是root 和res 返回值是res 因为最后是返回节点个数</p>
<p>2，<strong>确定终止条件</strong></p>
<p>​    终止条件应该是！root，但遍历到的节点为空的时候就返回</p>
<p>3，<strong>确定单层递归逻辑</strong></p>
<p>相当于是中左右 因为之前已经判断了root不为0，那么就res++，之后再继续遍历左右子树</p>
<pre><code class="c++">class Solution &#123;
public:
    int count(TreeNode *root,int &amp;res)&#123;
        if(!root)
        return 0;
        res++;
        count(root-&gt;left,res);
        count(root-&gt;right,res);
        return res;
    &#125;


    int countNodes(TreeNode* root) &#123;
        if(!root)
        return 0;

        int res=0;
        return count(root,res);
    &#125;
&#125;;
</code></pre>
<h4 id="完全二叉树做法"><a href="#完全二叉树做法" class="headerlink" title="完全二叉树做法"></a>完全二叉树做法</h4><p>参考代码随想录</p>
<p>完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。</p>
<p>对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。</p>
<p>对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。</p>
<pre><code class="cpp">class Solution &#123;
public:
    int countNodes(TreeNode* root) &#123;
        if (root == nullptr) return 0;
        TreeNode* left = root-&gt;left;
        TreeNode* right = root-&gt;right;
        int leftHeight = 0, rightHeight = 0; // 这里初始为0是有目的的，为了下面求指数方便
        while (left) &#123;  // 求左子树深度
            left = left-&gt;left;
            leftHeight++;
        &#125;
        while (right) &#123; // 求右子树深度
            right = right-&gt;right;
            rightHeight++;
        &#125;
        if (leftHeight == rightHeight) &#123;
            return (2 &lt;&lt; leftHeight) - 1; // 注意(2&lt;&lt;1) 相当于2^2，所以leftHeight初始为0
        &#125;    //当遍历到是满二叉树的时候那么可以直接2^x-1 然后再相加
        return countNodes(root-&gt;left) + countNodes(root-&gt;right) + 1;//左子树节点个数+右子树节点个数+1
    &#125;
&#125;;
</code></pre>
<h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 </p>
</blockquote>
<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>计算左孩子的<strong>最大深度</strong>以及计算右孩子的<strong>最大深度</strong>，如果高度差大于1，那么就返回false 否则就返回true。</p>
<p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1642922579488.png" alt="1642922579488"></p>
<p>这里高度和深度的概念其实是不一样的，<strong>具体情况还是得依照它所给的例子去分析</strong></p>
<p>思路三步走</p>
<p>1，明确递归参数和返回值</p>
<p>递归的参数只有root 返回值为false或者true</p>
<p>2，确定终止条件 </p>
<p>终止条件就是全部都遍历完，然后有一个返回值</p>
<p>3，确定单层逻辑</p>
<p>对于每一个root，如果abs(左-右)&lt;&#x3D;1，那么继续遍历它下面的子树，得到下面子树的返回值，否则&gt;1的话就直接返回false；</p>
<h4 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h4><pre><code class="c++">class Solution &#123;
public:
    int Maxdepth(TreeNode *root)&#123;
        if(!root)
        return 0;
        return max(Maxdepth(root-&gt;left),Maxdepth(root-&gt;right))+1;//这里加一不加一都一样的，因为是同时+1，但实际上

    &#125;

    bool isBalanced(TreeNode* root) &#123;
        if(!root)
        return true;
        if(abs(Maxdepth(root-&gt;left)-Maxdepth(root-&gt;right))&lt;=1)
            return isBalanced(root-&gt;left)&amp;&amp;isBalanced(root-&gt;right);
        else
            return false;
    &#125;
&#125;;
</code></pre>
<h3 id="257-二叉树的所有路径-好题啊"><a href="#257-二叉树的所有路径-好题啊" class="headerlink" title="**257. 二叉树的所有路径**好题啊"></a>**<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径</a>**好题啊</h3><blockquote>
<p>以为只用了递归，其实还用了回溯 </p>
</blockquote>
<p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1642923293931.png" alt="1642923293931"></p>
<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p><strong>好好看看代码随想录的部分</strong></p>
<p>首先这里出现了[“1-&gt;2-&gt;5”,”1-&gt;3”]这个东西，那么应该是返回的字符串，如果说是[[132,12],[35,84]]那么应该是vector&lt;vector<int>&gt; ,这个之前做过类似的题目</p>
<p>所以这里应该要定义vector<string> ，然后是说从根节点到叶子节点的路径，显然就是dfs了，然后这里还需要用到回溯，因为需要不断地返回上一个节点。</p>
<p>感觉最后应该是return(root-&gt;string),这样不断地返回上一层。</p>
<p>方法一：深度优先搜索<br>思路与算法</p>
<p>最直观的方法是使用深度优先搜索。在深度优先搜索遍历二叉树时，我们需要考虑当前的节点以及它的孩子节点。</p>
<p>如果当前节点不是<strong>叶子节点</strong>，则在当前的路径末尾添加该节点，并继续递归遍历该节点的每一个孩子节点。<br>如果当前节点是<strong>叶子节点</strong>，则在当前路径末尾添加该节点后我们就得到了一条从根节点到叶子节点的路径，将该路径加入到答案即可</p>
<h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><pre><code class="c++">class Solution &#123;
public:
    void construct_paths(TreeNode*root,string path,vector&lt;string&gt; &amp;allpath)&#123; //path用来存储这条路径所有的节点
        if(!root)
        return;
        path+=to_string(root-&gt;val);//int转string
        if(!root-&gt;left&amp;&amp;!root-&gt;right)//如果两个都不是空节点的话,不能这样，这样是错的，有一个是不空也需要+ -&gt;,应该要改成如果是叶子节点的话
            allpath.push_back(path);// 把路径加入到答案中
        else &#123;
                path+=&quot;-&gt;&quot;; // 当前节点不是叶子节点，继续递归遍历
                construct_paths(root-&gt;left,path,allpath);
                construct_paths(root-&gt;right,path,allpath);
        &#125;

    &#125;

    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;
        vector&lt;string&gt; allpath;
        
        construct_paths(root,&quot;&quot;,allpath);
        return allpath;

    &#125;
&#125;;
</code></pre>
<h4 id="代码随想录-递归-回溯"><a href="#代码随想录-递归-回溯" class="headerlink" title="代码随想录 递归+回溯"></a>代码随想录 递归+回溯</h4><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html#%E9%80%92%E5%BD%92">https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html#%E9%80%92%E5%BD%92</a></p>
<ol start="257">
<li><p><strong>二叉树的所有路径</strong></p>
<p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1642925930485.png" alt="1642925930485"></p>
</li>
</ol>
<p><strong>那么为什么使用了vector 结构来记录路径呢？</strong> 因为在下面处理单层递归逻辑的时候，要做回溯，使用vector方便来做回溯。</p>
<p>可能有的同学问了，我看有些人的代码也没有回溯啊。</p>
<p><strong>其实是有回溯的，只不过隐藏在函数调用时的参数赋值里</strong>，下文我还会提到。</p>
<p>这里我们先使用vector结构的path容器来记录路径</p>
<p>回溯：返回之前的地方再重新进行计算</p>
<pre><code class="c++">

class Solution &#123;
private:

    void traversal(TreeNode* cur, vector&lt;int&gt;&amp; path, vector&lt;string&gt;&amp; result) &#123; //这里注意是对原来的path的引用，只有这样才能够实现回溯
        path.push_back(cur-&gt;val);
        // 这才到了叶子节点
        if (cur-&gt;left == NULL &amp;&amp; cur-&gt;right == NULL) &#123;
            string sPath;
            for (int i = 0; i &lt; path.size() - 1; i++) &#123;
                sPath += to_string(path[i]);
                sPath += &quot;-&gt;&quot;;
            &#125;
            sPath += to_string(path[path.size() - 1]);
            result.push_back(sPath);
            return;
        &#125;
        if (cur-&gt;left) &#123;
            traversal(cur-&gt;left, path, result);
            path.pop_back(); // 回溯
        &#125;
        if (cur-&gt;right) &#123;
            traversal(cur-&gt;right, path, result);
            path.pop_back(); // 回溯 把
        &#125;
    &#125;

public:
    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;
        vector&lt;string&gt; result;
        vector&lt;int&gt; path;
        if (root == NULL) return result;
        traversal(root, path, result);
        return result;
    &#125;
&#125;;
</code></pre>
<h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h3><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p>
<p>叶子节点 是指没有子节点的节点</p>
<blockquote>
<p>相似的一道题</p>
</blockquote>
<p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1642928630284.png" alt="1642928630284"></p>
<h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><pre><code class="c++">class Solution &#123;
public:
    void allpath(TreeNode* root ,vector&lt;int&gt;&amp;path,vector&lt;int&gt;&amp;res)
    &#123;
        path.push_back(root-&gt;val);
        if(!root-&gt;left&amp;&amp;!root-&gt;right)//说明是叶子节点
        &#123;
            int sum=0;
            for(int i=0;i&lt;path.size();i++)
                sum+=path[i];
            res.push_back(sum);
            return;
        &#125;
        if(root-&gt;left)
        &#123;
            allpath(root-&gt;left,path,res);
            path.pop_back();
        &#125;
        if(root-&gt;right)
        &#123;
            allpath(root-&gt;right,path,res);
            path.pop_back();
        &#125;

    &#125;

    bool hasPathSum(TreeNode* root, int targetSum) &#123;
        int j=0;
        vector&lt;int&gt; res;
        vector&lt;int&gt; path;//path用来保存路径 res用来保存所有路径的值
        if(!root)
        return false;
        allpath(root,path,res);
        for(int i=0;i&lt;res.size();i++)
            if(res[i]==targetSum)
            return true;
        return false;
    &#125;
&#125;;
</code></pre>
<h3 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a></h3><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1643179897001.png" alt="1643179897001"></p>
<h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>和上一题的区别就是在于它要把所有的路径都写出来，并且放到pathsum函数中，这个与之前做过的某一道题相似，可以写成path.push_back(res)这么写感觉更加形象一点。</p>
<h4 id="深度遍历DFS"><a href="#深度遍历DFS" class="headerlink" title="深度遍历DFS"></a>深度遍历DFS</h4><pre><code class="c++">class Solution &#123;
public:
    void findall(TreeNode* root,vector&lt;int&gt;path,int targetSum,vector&lt;vector&lt;int&gt;&gt; &amp;res)
    &#123;
        if(!root)
        return;
        path.push_back(root-&gt;val);
        if(!root-&gt;left&amp;&amp;!root-&gt;right)//如果是叶子节点的话
        &#123;
            int size=path.size();
            int sum=0;
            for(int i=0;i&lt;size;i++)
            sum+=path[i];
            if(sum==targetSum)
            res.push_back(path);
        &#125;
        else&#123;
             findall(root-&gt;left,path,targetSum,res);
            findall(root-&gt;right,path,targetSum,res);
        &#125;
           
        

    &#125;

    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; path;

        if(!root)
        return res;

        findall(root,path,targetSum,res);
        return res;        
    &#125;
&#125;;
</code></pre>
<h3 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-left-leaves/">404. 左叶子之和</a></h3><p> 计算给定二叉树的所有左叶子之和。 </p>
<p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1642928761136.png" alt="1642928761136"></p>
<h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>1，确定递归参数和返回值</p>
<p>递归参数，左右子树，返回值和相加</p>
<p>2，确定终止条件</p>
<p>！root 还是得到叶节点才知道需不需要加，如果只有右节点还是得继续遍历</p>
<p>3，确定单层逻辑。</p>
<pre><code class="c++">class Solution &#123;
public:
    int sumOfLeftLeaves(TreeNode* root) &#123;
        if(!root)
        return 0;
        int lv=sumOfLeftLeaves(root-&gt;left);//左子树的左叶子之和
        int rv=sumOfLeftLeaves(root-&gt;right);//右子树左叶子之和
        int mv=0;
        if(root-&gt;left&amp;&amp;!root-&gt;left-&gt;right&amp;&amp;!root-&gt;left-&gt;left)//说明是左节点
            mv=root-&gt;left-&gt;val;
        int sum=mv+lv+rv;
        return sum;
    &#125;
&#125;;
</code></pre>
<pre><code class="c++">//更加简洁 
class Solution &#123;
public:
    int sumOfLeftLeaves(TreeNode* root) &#123;
        if(root == NULL) return 0;
        if(root-&gt;left!=NULL&amp;&amp;root-&gt;left-&gt;right==NULL&amp;&amp;root-&gt;left-&gt;left==NULL) 
            return sumOfLeftLeaves(root-&gt;right)+root-&gt;left-&gt;val;
        return sumOfLeftLeaves(root-&gt;left)+sumOfLeftLeaves(root-&gt;right);
    &#125;
&#125;;

</code></pre>
<h3 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-binary-tree/">654. 最大二叉树</a></h3><p>给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:</p>
<p>创建一个根节点，其值为 nums 中的最大值。<br>递归地在最大值 左边 的 子数组前缀上 构建左子树。<br>递归地在最大值 右边 的 子数组后缀上 构建右子树。<br>返回 nums 构建的 最大二叉树 。</p>
<h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><p>这个其实就是<strong>先序遍历</strong>，先构建根节点再构建左子树和右子树。</p>
<p>有点类似于中序遍历和后序遍历构造二叉树，这道题目不难，主要就找到一些边界条件,这里<strong>注意一下</strong>带入的是0和n-1，然后如果left&gt;right那么就会返回，就直接代入下标了，不然可能会出现数组越界的现象</p>
<p>分治法构建二叉树，左边一个右边一个。</p>
<h4 id="递归构建二叉树"><a href="#递归构建二叉树" class="headerlink" title="递归构建二叉树"></a>递归构建二叉树</h4><pre><code class="c++">class Solution &#123;
public:
    TreeNode* createtree(vector&lt;int&gt; nums,int left,int right)&#123;
        if(left&gt;right)//这个条件要注意一下
        return nullptr;

        int max=INT_MIN;
        int loc;
        for(int i=left;i&lt;=right;i++)
        &#123;
            if (max&lt;nums[i])
            &#123;
                max=nums[i];
                loc=i;
            &#125;
        &#125;//找到最大值
        TreeNode *root=new TreeNode(max);//TreeNode* node = new TreeNode(0);如果不知道可以初始化为0，如果初始化为-1说明还得再加一个
        root-&gt;left=createtree(nums,left,loc-1);
        root-&gt;right=createtree(nums,loc+1,right);
        return root;

    &#125;

    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;
        int size=nums.size();
        return createtree(nums,0,size-1);
    &#125;
&#125;;
</code></pre>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h3><p> 给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。 </p>
<p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1642858943926.png" alt="1642858943926"></p>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>这道题目还是好好看官方答案解析吧，其实看懂了就会了,G(n)</p>
<p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1642860127985.png" alt="1642860127985"></p>
<pre><code class="c++">class Solution &#123;
public:
    int numTrees(int n) &#123;
        vector&lt;int&gt; G(n + 1, 0);
        G[0] = 1;
        G[1] = 1;

        for (int i = 2; i &lt;= n; ++i) &#123;
            for (int j = 1; j &lt;= i; ++j) &#123;
                G[i] += G[j - 1] * G[i - j];
            &#125;
        &#125;
        return G[n];
    &#125;
&#125;;
</code></pre>
<h4 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h4><p>卡特兰数<br>$$<br>C_0&#x3D;1 \qquad C_n&#x3D;\frac{2(2n+1)}{n+2}<br>$$</p>
<pre><code class="c++">class Solution &#123;
public:
    int numTrees(int n) &#123;
        long long C = 1;
        for (int i = 0; i &lt; n; ++i) &#123;
            C = C * 2 * (2 * i + 1) / (i + 2);
        &#125;
        return (int)C;
    &#125;
&#125;;

</code></pre>
<h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li>
<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><p>构建一个vector容器，按照中序遍历依次输入到vector中，然后再来一个for循环，如果对于任意 满足res[i]&lt;res[i+1] return true 否则 return false。</p>
<h4 id="递归-6"><a href="#递归-6" class="headerlink" title="递归"></a>递归</h4><pre><code class="c++">class Solution &#123;
void inorder(TreeNode*root,vector&lt;int&gt; &amp;res) //这里是引用
&#123;
    if(!root)
    return ;
    inorder(root-&gt;left,res);
    res.push_back(root-&gt;val);
    inorder(root-&gt;right,res);
&#125;
public:
    bool isValidBST(TreeNode* root) &#123;
        vector&lt;int&gt; res;
        inorder(root,res);
        int size=res.size();
        if(size==1)
        return true;

        for(int i=0;i&lt;size-1;i++)
        &#123;
            if(res[i]&gt;=res[i+1])//这里注意一下是等于 222 就不满足 需要严格大于
            return false;
        &#125;
        return true;

    &#125;
&#125;;
</code></pre>
<blockquote>
<p>还有一种思路是直接用一个指针代替前面的val然后再比较，这样的话会快很多，而且空间复杂度不要那么高,这里不能用int，只能用long，因为太大 了</p>
<p>先看左子树，然后赋值，再看右子树</p>
<pre><code class="c++">class Solution &#123;
public:
    long pre = LONG_MIN; // 前一节点设为最小值
    bool isValidBST(TreeNode* root) &#123;
        if(!root)
            return true;
        if(isValidBST(root-&gt;left))&#123; // 验证左子树        
            if(pre &lt; root-&gt;val)&#123; // 前一节点(当前节点左子树最大值)小于当前节点
                pre = root-&gt;val; // 前一节点变为当前节点
                return isValidBST(root-&gt;right); // 验证右子树
            &#125;
        &#125;
        return false;
    &#125;
&#125;;
</code></pre>
<p>LONG_MAX LONG_MIN </p>
<p>INT_MAX INT_MIN  这种还是挺方便的 </p>
</blockquote>
<h3 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h3><p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。</p>
<p>你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。</p>
<p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1643183984991.png" alt="1643183984991"></p>
<h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><p>1，参数，root val 返回值 root</p>
<p>2，终止条件 读到树底了或者说是读到了root-&gt;val&#x3D;&#x3D;val</p>
<p>3，<strong>单层逻辑</strong> 等于的时候就返回root，大于往右读 小于往左读 然后要返回nullpur 不然不能返回所有的值</p>
<h4 id="递归-7"><a href="#递归-7" class="headerlink" title="递归"></a>递归</h4><pre><code class="c++">class Solution &#123;
public:
    TreeNode* searchBST(TreeNode* root, int val) &#123;
        if(!root)
        return nullptr;//读到底还没命中就返回错误了
        if (root-&gt;val==val) return root;
        if (root-&gt;val&gt;val) return searchBST(root-&gt;left,val);
        if (root-&gt;val&lt;val) return searchBST(root-&gt;right,val);
        return nullptr;

    &#125;
&#125;;
</code></pre>
<h3 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h3><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p>
<p>差值是一个正数，其数值等于两值之差的绝对值。</p>
<h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><p>说的任意两个不同节点值，由于是二叉搜索树，是按照顺序来的，所以其实只要按照左中右的中序遍历就可以了</p>
<pre><code class="c++">class Solution &#123;

    

public:
    void findmin(TreeNode *root,int &amp;pre,int &amp;minroot)&#123;
        if(!root)
        return;
        
        findmin(root-&gt;left,pre,minroot);//左
        if(pre==-1)
            pre=root-&gt;val;//先找到最后面的值 
        else&#123;
            minroot=min(minroot,root-&gt;val-pre);//pre表示的是前一个节点  中间一部分是对根节点的操作
            pre = root-&gt;val;
        &#125;
        findmin(root-&gt;right,pre,minroot);//右

    &#125;



    int getMinimumDifference(TreeNode* root) &#123;
        int minroot=INT_MAX;
        int pre=-1;
        findmin(root,pre,minroot);
        return minroot;
    &#125;
&#125;;
</code></pre>
<h3 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h3><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。</p>
<p>如果树中有不止一个众数，可以按 任意顺序 返回。</p>
<p>假定 BST 满足如下定义：</p>
<p>结点左子树中所含节点的值 小于等于 当前节点的值<br>结点右子树中所含节点的值 大于等于 当前节点的值<br>左子树和右子树都是二叉搜索树</p>
<h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><p>1，建立一个哈希表，construct_map,之后遍历哈希表，找到那个众数max_value，再遍历一遍，把value值等于众数的key push进res中，res就是对应的需要返回的数组</p>
<h4 id="非二叉搜索树解法"><a href="#非二叉搜索树解法" class="headerlink" title="非二叉搜索树解法"></a>非二叉搜索树解法</h4><pre><code class="c++">class Solution &#123;
public:
    void constructmap(TreeNode *root,unordered_map&lt;int,int&gt;&amp;map)&#123;
        if(!root)
        return;
        map[root-&gt;val]++;
        constructmap(root-&gt;left,map);
        constructmap(root-&gt;right,map);

    &#125;

    vector&lt;int&gt; findMode(TreeNode* root) &#123;
        unordered_map&lt;int,int&gt; map;
        vector&lt;int&gt; res;
        constructmap(root,map);//构造哈希表
        int size=map.size();
        int maxvalue=0,key;
        for(auto&amp;p:map)//遍历哈希表,找到那个最大值
        &#123;
            if(p.second&gt;maxvalue)
            &#123;
                maxvalue=p.second;
                key=p.first;
            &#125;
        &#125;
            for(auto&amp;p:map)//遍历哈希表
        &#123;
            if(p.second==maxvalue)
            &#123;
               res.push_back(p.first);//把key放进去
            &#125;
        &#125;
        return res;


    &#125;
&#125;;
//补充一个更快速的解法，参照了代码随想录
/*主要是遍历的部分变快了 可以少一步循环
        for(auto&amp;p:map)//遍历哈希表,找到那个最大值
        &#123;
            if(p.second==maxvalue)
             res.push_back(p.first);//把key放进去
            
            if(p.second&gt;maxvalue)
            &#123;
                res.clear();  //这一步是关键 如果发现不是那么就清空
                maxvalue=p.second;
                key=p.first;
                res.push_back(p.first);//把key放进去
            &#125;
     */
</code></pre>
<h4 id="代码随想录-1"><a href="#代码随想录-1" class="headerlink" title="代码随想录"></a>代码随想录</h4><p>2，搜索树解法：直接建立，左中右，如果相同就count++</p>
<pre><code class="c++">class Solution &#123;
private:
    int maxCount; // 最大频率
    int count; // 统计频率
    TreeNode* pre;
    vector&lt;int&gt; result;
    void searchBST(TreeNode* cur) &#123;
        if (cur == NULL) return ;

        searchBST(cur-&gt;left);       // 左
                                    // 中
        if (pre == NULL) &#123; // 第一个节点
            count = 1;
        &#125; else if (pre-&gt;val == cur-&gt;val) &#123; // 与前一个节点数值相同
            count++;
        &#125; else &#123; // 与前一个节点数值不同
            count = 1;
        &#125;
        pre = cur; // 更新上一个节点

        if (count == maxCount) &#123; // 如果和最大值相同，放进result中
            result.push_back(cur-&gt;val);
        &#125;

        if (count &gt; maxCount) &#123; // 如果计数大于最大值频率
            maxCount = count;   // 更新最大频率
            result.clear();     // 很关键的一步，不要忘记清空result，之前result里的元素都失效了
            result.push_back(cur-&gt;val);
        &#125;

        searchBST(cur-&gt;right);      // 右
        return ;
    &#125;

public:
    vector&lt;int&gt; findMode(TreeNode* root) &#123;
        count = 0;
        maxCount = 0;
        TreeNode* pre = NULL; // 记录前一个节点
        result.clear();

        searchBST(root);
        return result;
    &#125;
&#125;;
</code></pre>
<h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1643269918208.png" alt="1643269918208"></p>
<h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h4><p>首先我们要找到p，q节点的路径，返回一个vector<int> path ,然后再构造哈希表，或者数组，之后再一个个地去比较，找到深度最深的那个公共祖先。<strong>这道题目的正经做法应该是回溯的</strong>。</p>
<p>错误示范&#x2F;&#x2F;不写了 太丢脸了 好好学学人家</p>
<h4 id="参考的"><a href="#参考的" class="headerlink" title="参考的"></a>参考的</h4><p> 因为是递归，<strong>使用函数后可认为左右子树已经算出结果</strong>，这句话要记住，道出了递归的精髓 </p>
<p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1643274571181.png" alt="1643274571181"></p>
<p>代码简洁明了</p>
<pre><code class="c++">class Solution &#123;
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;
        if(root == NULL)
            return NULL;
        if(root == p || root == q) 
            return root;
            
        TreeNode* left =  lowestCommonAncestor(root-&gt;left, p, q);
        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);
       
        if(left == NULL) //说明不在左边
            return right;
        if(right == NULL)//说明不在右边
            return left;      
        if(left &amp;&amp; right) // p和q在两侧
            return root;
        
        return NULL; // 必须有返回值 不然会报错，很多题目都会出现这种不能全部打出来的情况
    &#125;
&#125;;


作者：Wilson79
链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/c-jing-dian-di-gui-si-lu-fei-chang-hao-li-jie-shi-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h3 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h4><p>由于树是二叉搜索树，那么可以利用二叉搜索树的性质，即左子树的结点的值都小于根结点，右子树的结点都大于根结点。可以分为3种情况。</p>
<p>1.若p的值小于root的值，q的值大于根的值，那么root就是最近公共祖先。<br>2.若p的值和q的值都小于root的值，那么代表最近祖先一定在root的左子树中<br>3.若p的值和q的值都大于root的值，那么代表最近祖先一定在root的右子树中<br>2.3情况发生的话，只需要继续递归即可，而 1则是递归出口。</p>
<h4 id="递归-8"><a href="#递归-8" class="headerlink" title="递归"></a>递归</h4><pre><code class="c++">
class Solution &#123;
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;
        if(!root)
        return NULL;
        if(root==q||root==p)
        return root;
        if(root-&gt;val&gt;=p-&gt;val&amp;&amp;root-&gt;val&gt;=q-&gt;val) return lowestCommonAncestor(root-&gt;left,p,q);
        if(root-&gt;val&lt;=p-&gt;val&amp;&amp;root-&gt;val&lt;=q-&gt;val) return lowestCommonAncestor(root-&gt;right,p,q);
        return root;  //它这个是返回来一个最近的值 就是两边都满足了 不断地返回最接近的root

    &#125;
&#125;;
</code></pre>
<h3 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h3><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p>
<h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h4><p>只需要在叶子节点这里删除就可以了</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="c++">class Solution &#123;
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;
        if (root == NULL) &#123;
            TreeNode* node = new TreeNode(val);
            return node;
        &#125;
        if (root-&gt;val &gt; val) root-&gt;left = insertIntoBST(root-&gt;left, val);
        if (root-&gt;val &lt; val) root-&gt;right = insertIntoBST(root-&gt;right, val);
        return root;//这里返回的root其实就是原来的root-&gt;right,和root-&gt;left 这里有点难理解，模拟一下就出来了。
    &#125;
&#125;;
</code></pre>
<h4 id="迭代-3"><a href="#迭代-3" class="headerlink" title="迭代"></a>迭代</h4><pre><code class="c++">class Solution &#123;
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;
        if(root==nullptr)
        &#123;
            TreeNode *node=new TreeNode(val);
            return node;
        &#125;
        TreeNode *cur=root;
        TreeNode *parent=root;
        while(cur)
        &#123;
            parent=cur;//保存父节点
            if(cur-&gt;val&gt;val) cur=cur-&gt;left;
            else cur=cur-&gt;right;
        &#125;
        TreeNode *node=new TreeNode(val);
        if(parent-&gt;val&gt;val)
        parent-&gt;left=node;
        else parent-&gt;right=node;
        return root;
    &#125;
&#125;;
</code></pre>
<h3 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h3><h4 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h4><p>根据二叉搜索树的性质</p>
<p>如果目标节点大于当前节点值，则去右子树中删除；<br>如果目标节点小于当前节点值，则去左子树中删除；<br>如果目标节点就是当前节点，分为以下三种情况：<br>其无左子：其右子顶替其位置，删除了该节点；<br>其无右子：其左子顶替其位置，删除了该节点；<br>其左右子节点都有：其左子树转移到其右子树的最左节点的左子树上，然后右子树顶替其位置，由此删除了该节点。</p>
<p>之前也有链表删除的题目</p>
<p><strong>删除的本质是返回root节点的左节点或者右节点</strong>，就像是链表的题，返回的是假设进入的是p，那么返回的是p-&gt;next，那么p就被删除了，当然正常还应该加个free（），但好像lc都没加</p>
<h4 id="参考的递归"><a href="#参考的递归" class="headerlink" title="参考的递归"></a>参考的递归</h4><pre><code class="c++">class Solution &#123;
public:
    TreeNode* deleteNode(TreeNode* root, int key) 
    &#123;
        if (root == nullptr)    return nullptr;
        if (key &gt; root-&gt;val)    root-&gt;right = deleteNode(root-&gt;right, key);     // 去右子树删除
        else if (key &lt; root-&gt;val)    root-&gt;left = deleteNode(root-&gt;left, key);  // 去左子树删除
        else    // 当前节点就是要删除的节点
        &#123;
            if (! root-&gt;left)   return root-&gt;right; // 情况1，欲删除节点无左子
            if (! root-&gt;right)  return root-&gt;left;  // 情况2，欲删除节点无右子
            TreeNode* node = root-&gt;right;           // 情况3，欲删除节点左右子都有 
            while (node-&gt;left)          // 寻找欲删除节点右子树的最左节点
                node = node-&gt;left;
            node-&gt;left = root-&gt;left;    // 将欲删除节点的左子树成为其右子树的最左节点的左子树
            root = root-&gt;right;         // 欲删除节点的右子顶替其位置，节点被删除
            //这里也可以直接返回root-&gt;right 不返回root 也相当于被删除了 return root-&gt;right;  
        &#125;
        return root;    
    &#125;
&#125;;

</code></pre>
<h3 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h3><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。</p>
<p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p>
<p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1643355350843.png" alt="1643355350843"></p>
<h4 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h4><p>这道题目其实就是删除二叉树中的节点的加强版，只不过不是删除一个节点，而是删除一些节点。就还是返照上面的去做就好了。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code class="c++">class Solution &#123;
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;
        if(!root)
        return nullptr;
        root-&gt;left=trimBST(root-&gt;left,low,high);
        root-&gt;right=trimBST(root-&gt;right,low,high);
        
        if(root-&gt;val&lt;low||root-&gt;val&gt;high)//确定是要删除的节点
        &#123;
            if (! root-&gt;left)   return root-&gt;right; // 情况1，欲删除节点无左子
            if (! root-&gt;right)  return root-&gt;left;  // 情况2，欲删除节点无右子
            TreeNode* node = root-&gt;right;           // 情况3，欲删除节点左右子都有 
            while (node-&gt;left)          // 寻找欲删除节点右子树的最左节点
                node = node-&gt;left;
            node-&gt;left = root-&gt;left;    // 将欲删除节点的左子树成为其右子树的最左节点的左子树
            return root-&gt;right;         // 欲删除节点的右子顶替其位置，节点被删除

            //这里也可以直接返回root-&gt;right 不返回root 也相当于被删除了 return root-&gt;right;  
        &#125;
        return root;

    &#125;
&#125;;
</code></pre>
<h4 id="代码随想录-2"><a href="#代码随想录-2" class="headerlink" title="代码随想录"></a>代码随想录</h4><pre><code class="c++">class Solution &#123;
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;
        if (root == nullptr) return nullptr;
        if (root-&gt;val &lt; low) return trimBST(root-&gt;right, low, high);
        if (root-&gt;val &gt; high) return trimBST(root-&gt;left, low, high);
        root-&gt;left = trimBST(root-&gt;left, low, high);
        root-&gt;right = trimBST(root-&gt;right, low, high);
        return root;
    &#125;
&#125;;
</code></pre>
<h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h3><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p>
<p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>
<p><img src="C:\Users\DELL\Desktop\LeetCode\树图.assets\1643356655425.png" alt="1643356655425"></p>
<h4 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h4><p>每次都找中间节点，中间节点的左边构造左子树，中间节点的右边构造右子树,具体可以参照654，先序遍历构造二叉树，先根节点再左右子树</p>
<pre><code class="c++">//构造树基本上就是
if(!root)
    return nullptr;

root-&gt;left=function();
root-&gt;right=function();
</code></pre>
<h4 id="递归-9"><a href="#递归-9" class="headerlink" title="递归"></a>递归</h4><p>这里可以发现，传入数据里面是没有root的，因为如果有root的话需要重新去定义，</p>
<pre><code class="c++">cnostruct_tree(nums,root-&gt;left,low,high)//如果是这样的话会报错的，因为root-&gt;left并不存在，所以我们不需要传入root-&gt;left，直接传入(nums,low,mid-1)，然后再在函数里面去建立Treenode就可以了，654里面中也没有传入root，说明构建
</code></pre>
<p><strong>构建二叉树的题目不需要传入root-&gt;left或者root-&gt;right,直接在里面进行创建就行了</strong></p>
<pre><code class="c++">class Solution &#123;
public:

    TreeNode *construct_tree(vector&lt;int&gt;nums,int low,int high)&#123;

        if(low&gt;high)
        return nullptr;
        int mid=(low+high)/2;
        TreeNode *root=new TreeNode(0);
        root-&gt;val=nums[mid];
        root-&gt;left=construct_tree(nums,low,mid-1);
        root-&gt;right=construct_tree(nums,mid+1,high);//这里需要注意一下需要排除掉mid，即变成mid+1和mid-1
        return root;
        
    &#125;
    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;
        int size=nums.size();
        TreeNode *root=new TreeNode(0);
        root=construct_tree(nums,0,size-1);
        return root;
    &#125;
&#125;;
</code></pre>
<h3 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h3><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<p>节点的左子树仅包含键 小于 节点键的节点。<br>节点的右子树仅包含键 大于 节点键的节点。<br>左右子树也必须是二叉搜索树。</p>
<p><img src="C:\Users\DELL\Desktop\LeetCode\树.assets\1643358490718.png" alt="1643358490718"></p>
<h4 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h4><p>首先先确定是中序遍历，左&gt;中&gt;右。但似乎这道题目是要累加，可以定义一个数组，先访问右子树，然后压进去，再根 再左子树，然后每次再累加，依次类推。</p>
<p>感觉这道题目也可以利用栈来做，直接记录栈的值就行，或者直接累加试试，记录sum的值。</p>
<p><strong>反中序</strong> 其实看一眼就发现了</p>
<h4 id="递归，数组"><a href="#递归，数组" class="headerlink" title="递归，数组"></a>递归，数组</h4><pre><code class="c++">class Solution &#123;
public:
    TreeNode* transTree(vector&lt;int&gt; &amp;nums,TreeNode* root)&#123;//这里注意 &amp;nums 这里是引用，而不是单纯地取值，因为如果单纯地取值的话返回时是返回前一个num，即空数组 那么就不变了
        if(!root)
        return nullptr;
        root-&gt;right=transTree(nums,root-&gt;right); //右

        nums.push_back(root-&gt;val);//中  把之前记录的数据全部累加
        int size=nums.size();
        for(int i=0;i&lt;size-1;i++)
        &#123;
            root-&gt;val+=nums[i];
        &#125;
        root-&gt;left=transTree(nums,root-&gt;left);//左

        return root;

    &#125;

    TreeNode* convertBST(TreeNode* root) &#123;
        vector&lt;int&gt; nums;
        return transTree(nums,root);
    &#125;
&#125;;
</code></pre>
<h4 id="递归，sum求和"><a href="#递归，sum求和" class="headerlink" title="递归，sum求和"></a>递归，sum求和</h4><p>递归三部曲：</p>
<p>1，返回值：root，调用参数：root和sum</p>
<p>2，终止条件： 读到空节点 ！root return nullptr</p>
<p>3,中间逻辑，root-&gt;left &#x3D;;&#x2F;&#x2F;<strong>因为返回的是节点 所以肯定是root的叶子节点等于巴拉巴拉之类的</strong> 然后这里发现最好是先遍历右子树，然后从后往前依次累加即可</p>
<pre><code class="c++">class Solution &#123;
public:
    TreeNode* transTree(int &amp;sum,TreeNode* root)
    &#123;
        if(!root)
        return nullptr;
        
        root-&gt;right=transTree(sum,root-&gt;right);
        
        sum+=root-&gt;val;
        root-&gt;val=sum;

        root-&gt;left=transTree(sum,root-&gt;left);

        return root;

    &#125;
    TreeNode* convertBST(TreeNode* root) &#123;
        int sum=0;
        return transTree(sum,root);
    &#125;
&#125;;
//执行时间 击败80%  内存消耗 击败 90% 因为这里不需要定义数组了  时间空间复杂度都是O（n）
</code></pre>
<h4 id="栈，递归"><a href="#栈，递归" class="headerlink" title="栈，递归"></a>栈，递归</h4><pre><code class="c++">//栈反中序
struct TreeNode* convertBST(struct TreeNode* root)&#123;
    struct TreeNode** stack = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 10001);
    int top = -1, num=0;
    struct TreeNode* p = root;
    while(p || top!=-1)&#123;
        while(p)&#123;
            stack[++top] = p;
            p = p-&gt;right;
        &#125;
        p = stack[top--];
        num += p-&gt;val;
        p-&gt;val = num;
        p = p-&gt;left;
    &#125;
    return root;
&#125;

</code></pre>

            </div>
            <hr />

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《树》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2019/11/02/shu/" property="cc:attributionName"
               rel="cc:attributionURL">
                value-jack
            </a> 采用
            <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
    <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '查教程获取',
        clientSecret: '查教程获取',
        repo: 'value-jack.github.io',
        owner: 'value-jack',
        admin: "value-jack",
        id: '2019/11/02/shu/',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    
    <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script> -->

<script>
    new Valine({
        el: '#vcomments',
        appId: '查教程获取',
        appKey: '查教程获取',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'false' === 'true',
        avatar: 'wavatar',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '如果你没有GitHub账号，还可以在这里评论啦！'
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/11/02/gong-shi-zong-jie/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/7.jpg" class="responsive-img" alt="公式总结">
                        
                        <span class="card-title">公式总结</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            计网奈奎斯特定理$$理想低通道下的极限数据传输率&#x3D;2W\log_2V$$
香农定理$$信道的极限数据传输率&#x3D;Wlog_2(1+S&#x2F;N) (单位为b&#x2F;s)$$
W：信道的带宽。 S：信道所传输信号的平均
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2019-11-02
                        </span>
                        <span class="publish-author">
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/408/" target="_blank">
                        <span class="chip bg-color">408</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                本篇&nbsp;<i class="fa fa-dot-circle-o"></i>
            </div>
            <div class="card">
                <a href="/2019/11/02/shu/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/22.jpg" class="responsive-img" alt="树">
                        
                        <span class="card-title">树</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            树树树的基本定义//二叉树的基本定义
typedef struct TreeNode
&#123;
    int val;
    struct TreeNode *rchild,*lchild;
&#125;;

递归二叉树的递归遍历h
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2019-11-02
                            </span>
                        <span class="publish-author">
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/LeetCode/" target="_blank">
                        <span class="chip bg-color">LeetCode</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 感而遂通的博客<br />'
            + '作者: value-jack<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
    });
</script>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; 2017-2020 WeiYang. 版权所有

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">42.8k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
            <br>
            
            <span id="busuanzi_container_site_pv" style='display:none'>
                <i class="fa fa-heart-o"></i>
                本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
            <span id="busuanzi_container_site_uv" style='display:none'>
                人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
            </span>
            
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/value-jack" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:value-jack@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="https://zhihu.com/people/value-jack" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-inverse">知</i>
    </a>



    <a href="http://wpa.qq.com/msgrd?v=3&uin=1030364680&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>



    <a href="https://weibo.com/value-jack" class="tooltipped" target="_blank" data-tooltip="关注我的微博" data-position="top" data-delay="50">
        <i class="fa fa-weibo"></i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 80000;
        var uvcountOffset = 20000;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2017, 09, 11, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=查教程获取"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '查教程获取');
</script>



    
    <script src="/libs/others/clicklove.js"></script>
    

    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    <!-- 雪花特效 -->
    

</body>

</html>